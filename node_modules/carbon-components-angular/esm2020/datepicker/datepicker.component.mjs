import { Component, Input, Output, EventEmitter, ViewEncapsulation, HostListener, ViewChild } from "@angular/core";
import rangePlugin from "flatpickr/dist/plugins/rangePlugin";
import flatpickr from "flatpickr";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
import { carbonFlatpickrMonthSelectPlugin } from "./carbon-flatpickr-month-select";
import * as languages from "flatpickr/dist/l10n/index";
import * as i0 from "@angular/core";
import * as i1 from "carbon-components-angular/i18n";
import * as i2 from "@angular/common";
import * as i3 from "carbon-components-angular/datepicker-input";
/**
 * Due to type error, we have to use square brackets property accessor
 * There is a webpack issue when attempting to access exported languages from flatpickr l10n Angular 14+ apps
 * languages.default[locale] fails in app consuming CCA library but passes in test
 * languages.default.default[locale] fails in test but works in app consuming CCA library.
 *
 * To please both scenarios, we are adding a condition to prevent tests from failing
 */
if (languages.default?.default["en"]?.weekdays) {
    languages.default.default["en"].weekdays.shorthand = languages.default.default["en"].weekdays.longhand.map(day => {
        if (day === "Thursday") {
            return "Th";
        }
        return day.charAt(0);
    });
}
/**
 * [See demo](../../?path=/story/components-date-picker--single)
 */
export class DatePicker {
    constructor(elementRef, i18n) {
        this.elementRef = elementRef;
        this.i18n = i18n;
        /**
         * Select calendar range mode
         */
        this.range = false;
        /**
         * Format of date
         *
         * For reference: https://flatpickr.js.org/formatting/
         */
        this.dateFormat = "m/d/Y";
        /**
         * Language of the flatpickr calendar.
         *
         * For reference of the possible locales:
         * https://github.com/flatpickr/flatpickr/blob/master/src/l10n/index.ts
         */
        this.language = "en";
        this.placeholder = "mm/dd/yyyy";
        /**
         * Aria label added to datepicker's calendar container.
         */
        this.ariaLabel = "calendar container";
        /**
         * The pattern for the underlying input element
         */
        this.inputPattern = "^\\d{1,2}/\\d{1,2}/\\d{4}$";
        this.id = `datepicker-${DatePicker.datePickerCount++}`;
        /**
         * @deprecated since v5 - Use `cdsLayer` directive instead
         * Set to `"light"` to apply the light style
         */
        this.theme = "dark";
        this.disabled = false;
        /**
         * Set to `true` to display the invalid state.
         */
        this.invalid = false;
        /**
          * Set to `true` to show a warning (contents set by warningText)
          */
        this.warn = false;
        this.size = "md";
        /**
         * Set to `true` to display the invalid state for the second datepicker input.
         */
        this.rangeInvalid = false;
        /**
          * Set to `true` to show a warning in the second datepicker input (contents set by rangeWarningText)
          */
        this.rangeWarn = false;
        this.skeleton = false;
        this.plugins = [];
        this.valueChange = new EventEmitter();
        /**
         * We are overriding onClose event even if users pass it via flatpickr options
         * Emits an event when date picker closes
         */
        this.onClose = new EventEmitter();
        this._value = [];
        this._flatpickrOptions = {
            allowInput: true
        };
        this.flatpickrBaseOptions = {
            mode: "single",
            dateFormat: "m/d/Y",
            plugins: this.plugins,
            onOpen: () => {
                this.updateClassNames();
                this.updateAttributes();
                this.updateCalendarListeners();
            },
            onClose: (date) => {
                // This makes sure that the `flatpickrInstance selectedDates` are in sync with the values of
                // the inputs when the calendar closes.
                if (this.range && this.flatpickrInstance) {
                    if (this.flatpickrInstance.selectedDates.length !== 2) {
                        // we could `this.flatpickrInstance.clear()` but it insists on opening the second picker
                        // in some cases, so instead we do this
                        this.setDateValues([]);
                        this.doSelect([]);
                        return;
                    }
                    const inputValue = this.input.input.nativeElement.value;
                    const rangeInputValue = this.rangeInput.input.nativeElement.value;
                    if (inputValue || rangeInputValue) {
                        const parseDate = (date) => this.flatpickrInstance.parseDate(date, this.dateFormat);
                        this.setDateValues([parseDate(inputValue), parseDate(rangeInputValue)]);
                        this.doSelect(this.flatpickrInstance.selectedDates);
                    }
                }
                this.onClose.emit(date);
            },
            onDayCreate: (_dObj, _dStr, _fp, dayElem) => {
                dayElem.classList.add("cds--date-picker__day");
            },
            nextArrow: this.rightArrowHTML(),
            prevArrow: this.leftArrowHTML(),
            value: this.value
        };
        this.flatpickrInstance = null;
        this.onTouched = () => { };
        this.propagateChange = (_) => { };
        this.preventCalendarClose = event => event.stopPropagation();
    }
    set value(v) {
        if (!v) {
            v = [];
        }
        this._value = v;
    }
    get value() {
        return this._value;
    }
    set flatpickrOptions(options) {
        this._flatpickrOptions = Object.assign({}, this._flatpickrOptions, options);
    }
    get flatpickrOptions() {
        const plugins = [...this.plugins, carbonFlatpickrMonthSelectPlugin];
        if (this.range) {
            plugins.push(rangePlugin({ input: `#${this.id}-rangeInput`, position: "left" }));
        }
        return Object.assign({}, this._flatpickrOptions, this.flatpickrBaseOptions, {
            mode: this.range ? "range" : "single",
            plugins,
            dateFormat: this.dateFormat,
            locale: languages.default?.default[this.language] || languages.default[this.language]
        });
    }
    ngOnInit() {
        // if i18n is set to anything other than en we'll want to change the language
        // otherwise we'll just use the local setting
        if (this.i18n.getLocale() !== "en") {
            this.i18n.getLocaleObservable().subscribe(locale => {
                this.language = locale;
                this.resetFlatpickrInstance();
            });
        }
    }
    ngOnChanges(changes) {
        // Reset the flatpickr instance on input changes that affect flatpickr.
        const flatpickrChangeKeys = [
            "range",
            "dateFormat",
            "language",
            "id",
            "value",
            "plugins",
            "flatpickrOptions"
        ];
        const changeKeys = Object.keys(changes);
        if (changeKeys.some(key => flatpickrChangeKeys.includes(key))) {
            this.resetFlatpickrInstance(changes.value);
        }
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.addInputListeners();
        }, 0);
    }
    // because the actual view may be delayed in loading (think projection into a tab pane)
    // and because we rely on a library that operates outside the Angular view of the world
    // we need to keep trying to load the library, until the relevant DOM is actually live
    ngAfterViewChecked() {
        if (!this.isFlatpickrLoaded()) {
            // @ts-ignore ts is unhappy with the below call to `flatpickr`
            this.flatpickrInstance = flatpickr(`#${this.id}-input`, this.flatpickrOptions);
            // if (and only if) the initialization succeeded, we can set the date values
            if (this.isFlatpickrLoaded()) {
                if (this.value.length > 0) {
                    this.setDateValues(this.value);
                }
            }
        }
    }
    onFocus() {
        // Updates the month manually when calendar mode is range because month
        // will not update properly without manually updating them on focus.
        if (this.range) {
            if (this.rangeInput.input.nativeElement === document.activeElement && this.flatpickrInstance.selectedDates[1]) {
                const currentMonth = this.flatpickrInstance.selectedDates[1].getMonth();
                this.flatpickrInstance.changeMonth(currentMonth, false);
            }
            else if (this.input.input.nativeElement === document.activeElement && this.flatpickrInstance.selectedDates[0]) {
                const currentMonth = this.flatpickrInstance.selectedDates[0].getMonth();
                this.flatpickrInstance.changeMonth(currentMonth, false);
            }
        }
    }
    onFocusOut() {
        this.onTouched();
    }
    /**
     * Writes a value from the model to the component. Expects the value to be `null` or `(Date | string)[]`
     * @param value value received from the model
     */
    writeValue(value) {
        this.value = value;
        setTimeout(() => {
            if (this.isFlatpickrLoaded() && this.flatpickrInstance.config) {
                this.setDateValues(this.value);
            }
        });
    }
    /**
     * `ControlValueAccessor` method to programmatically disable the DatePicker.
     *
     * ex: `this.formGroup.get("myDatePicker").disable();`
     *
     * @param isDisabled `true` to disable the DatePicker
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * Cleans up our flatpickr instance
     */
    ngOnDestroy() {
        if (!this.isFlatpickrLoaded()) {
            return;
        }
        this.flatpickrInstance.destroy();
    }
    /**
     * Handles the `valueChange` event from the primary/single input
     */
    onValueChange(event) {
        if (this.isFlatpickrLoaded()) {
            const date = this.flatpickrInstance.parseDate(event, this.dateFormat);
            if (this.range) {
                this.setDateValues([date, this.flatpickrInstance.selectedDates[1]]);
            }
            else {
                this.setDateValues([date]);
            }
            this.doSelect(this.flatpickrInstance.selectedDates);
        }
    }
    /**
     * Handles the `valueChange` event from the range input
     */
    onRangeValueChange(event) {
        if (this.isFlatpickrLoaded() && this.flatpickrInstance.isOpen) {
            const date = this.flatpickrInstance.parseDate(event, this.dateFormat);
            this.setDateValues([this.flatpickrInstance.selectedDates[0], date]);
            this.doSelect(this.flatpickrInstance.selectedDates);
        }
    }
    /**
     * Handles opening the calendar "properly" when the calendar icon is clicked.
     */
    openCalendar(datepickerInput) {
        if (this.range) {
            datepickerInput.input.nativeElement.click();
            // If the first input's calendar icon is clicked when calendar is in range mode, then
            // the month and year needs to be manually changed to the current selected month and
            // year otherwise the calendar view will not be updated upon opening.
            if (datepickerInput === this.input && this.flatpickrInstance.selectedDates[0]) {
                const currentMonth = this.flatpickrInstance.selectedDates[0].getMonth();
                this.flatpickrInstance.currentYear = this.flatpickrInstance.selectedDates[0].getFullYear();
                this.flatpickrInstance.changeMonth(currentMonth, false);
            }
        }
        else {
            // Single-mode flatpickr handles mousedown but not click, so nativeElement.click() won't
            // work when the calendar icon is clicked. In this case we simply use flatpickr.open().
            this.flatpickrInstance.open();
        }
    }
    updateCalendarListeners() {
        const calendarContainer = document.querySelectorAll(".flatpickr-calendar");
        Array.from(calendarContainer).forEach(calendar => {
            calendar.removeEventListener("click", this.preventCalendarClose);
            calendar.addEventListener("click", this.preventCalendarClose);
        });
    }
    /**
     * Handles the initialization of event listeners for the datepicker input and range input fields.
     */
    addInputListeners() {
        if (!this.isFlatpickrLoaded()) {
            return;
        }
        // Allows focus transition from the datepicker input or range input field to
        // flatpickr calendar using a keyboard.
        const addFocusCalendarListener = (element) => {
            element.addEventListener("keydown", (event) => {
                if (event.key === "ArrowDown") {
                    if (!this.flatpickrInstance.isOpen) {
                        this.flatpickrInstance.open();
                    }
                    const calendarContainer = this.flatpickrInstance.calendarContainer;
                    const dayElement = calendarContainer && calendarContainer.querySelector(".flatpickr-day[tabindex]");
                    if (dayElement) {
                        dayElement.focus();
                        // If the user manually inputs a value into the date field and presses arrow down,
                        // datepicker input onchange will be triggered when focus is removed from it and
                        // `flatpickrInstance.setDate` and `flatpickrInstance.changeMonth` will be invoked
                        // which will automatically change focus to the beginning of the document.
                        if (document.activeElement !== dayElement && this.flatpickrInstance.selectedDateElem) {
                            this.flatpickrInstance.selectedDateElem.focus();
                        }
                    }
                }
            });
        };
        if (this.input && this.input.input) {
            addFocusCalendarListener(this.input.input.nativeElement);
        }
        if (this.rangeInput && this.rangeInput.input) {
            addFocusCalendarListener(this.rangeInput.input.nativeElement);
        }
    }
    /**
     * Resets the flatpickr instance while keeping the date values (or updating them if newDates is provided)
     *
     * Used to pick up input changes or locale changes.
     *
     * @param newDates An optional SimpleChange of date values
     */
    resetFlatpickrInstance(newDates) {
        if (this.isFlatpickrLoaded()) {
            let dates = this.flatpickrInstance.selectedDates;
            if (newDates && this.didDateValueChange(newDates.currentValue, newDates.previousValue)) {
                dates = newDates.currentValue;
            }
            // only reset the flatpickr instance on Input changes
            // @ts-ignore ts is unhappy with the below call to `flatpickr`
            this.flatpickrInstance = flatpickr(`#${this.id}-input`, this.flatpickrOptions);
            this.setDateValues(dates);
        }
    }
    /**
     * Carbon uses a number of specific classnames for parts of the flatpickr - this idempotent method applies them if needed.
     */
    updateClassNames() {
        if (!this.elementRef) {
            return;
        }
        // get all the possible flatpickrs in the document - we need to add classes to (potentially) all of them
        const calendarContainer = document.querySelectorAll(".flatpickr-calendar");
        const monthContainer = document.querySelectorAll(".flatpickr-month");
        const weekdaysContainer = document.querySelectorAll(".flatpickr-weekdays");
        const weekdayContainer = document.querySelectorAll(".flatpickr-weekday");
        const daysContainer = document.querySelectorAll(".flatpickr-days");
        const dayContainer = document.querySelectorAll(".flatpickr-day");
        // add classes to lists of elements
        const addClassIfNotExists = (classname, elementList) => {
            Array.from(elementList).forEach(element => {
                if (!element.classList.contains(classname)) {
                    element.classList.add(classname);
                }
            });
        };
        // add classes (but only if they don't exist, small perf win)
        addClassIfNotExists("cds--date-picker__calendar", calendarContainer);
        addClassIfNotExists("cds--date-picker__month", monthContainer);
        addClassIfNotExists("cds--date-picker__weekdays", weekdaysContainer);
        addClassIfNotExists("cds--date-picker__days", daysContainer);
        // add weekday classes and format the text
        Array.from(weekdayContainer).forEach(element => {
            element.innerHTML = element.innerHTML.replace(/\s+/g, "");
            element.classList.add("cds--date-picker__weekday");
        });
        // add day classes and special case the "today" element based on `this.value`
        Array.from(dayContainer).forEach(element => {
            element.classList.add("cds--date-picker__day");
            if (!this.value) {
                return;
            }
            if (element.classList.contains("today") && this.value.length > 0) {
                element.classList.add("no-border");
            }
            else if (element.classList.contains("today") && this.value.length === 0) {
                element.classList.remove("no-border");
            }
        });
    }
    updateAttributes() {
        const calendarContainer = document.querySelectorAll(".flatpickr-calendar");
        Array.from(calendarContainer).forEach(calendar => {
            calendar.setAttribute("role", "region");
            calendar.setAttribute("aria-label", this.ariaLabel);
        });
    }
    /**
     * Applies the given date value array to both the flatpickr instance and the `input`(s)
     * @param dates the date values to apply
     */
    setDateValues(dates) {
        if (this.isFlatpickrLoaded()) {
            const singleInput = this.elementRef.nativeElement.querySelector(`#${this.id}-input`);
            const rangeInput = this.elementRef.nativeElement.querySelector(`#${this.id}-rangeInput`);
            // `flatpickrInstance.setDate` removes the focus on the selected date element and will
            // automatically change focus to the beginning of the document. If a selected date is
            // focused before `flatpickrInstance.setDate` is invoked then it should remain focused.
            let shouldRefocusDateElement = this.flatpickrInstance.selectedDateElem === document.activeElement;
            // set the date on the instance
            this.flatpickrInstance.setDate(dates);
            if (shouldRefocusDateElement) {
                this.flatpickrInstance.selectedDateElem.focus();
            }
            // we can either set a date value or an empty string, so we start with an empty string
            let singleDate = "";
            // if date is a string, parse and format
            if (typeof this.flatpickrInstance.selectedDates[0] === "string") {
                singleDate = this.flatpickrInstance.parseDate(this.flatpickrInstance.selectedDates[0], this.dateFormat);
                singleDate = this.flatpickrInstance.formatDate(singleDate, this.dateFormat);
                // if date is not a string we can assume it's a Date and we should format
            }
            else if (!!this.flatpickrInstance.selectedDates[0]) {
                singleDate = this.flatpickrInstance.formatDate(this.flatpickrInstance.selectedDates[0], this.dateFormat);
            }
            if (rangeInput) {
                // we can either set a date value or an empty string, so we start with an empty string
                let rangeDate = "";
                // if date is a string, parse and format
                if (typeof this.flatpickrInstance.selectedDates[1] === "string") {
                    rangeDate = this.flatpickrInstance.parseDate(this.flatpickrInstance.selectedDates[1].toString(), this.dateFormat);
                    rangeDate = this.flatpickrInstance.formatDate(rangeDate, this.dateFormat);
                    // if date is not a string we can assume it's a Date and we should format
                }
                else if (!!this.flatpickrInstance.selectedDates[1]) {
                    rangeDate = this.flatpickrInstance.formatDate(this.flatpickrInstance.selectedDates[1], this.dateFormat);
                }
                setTimeout(() => {
                    // apply the values
                    rangeInput.value = rangeDate;
                    singleInput.value = singleDate;
                });
            }
        }
    }
    doSelect(selectedValue) {
        // In range mode, if a date is selected from the first calendar that is from the previous month,
        // the month will not be updated on the calendar until the calendar is re-opened.
        // This will make sure the calendar is updated with the correct month.
        if (this.range && this.flatpickrInstance.selectedDates[0]) {
            const currentMonth = this.flatpickrInstance.selectedDates[0].getMonth();
            // `flatpickrInstance.changeMonth` removes the focus on the selected date element and will
            // automatically change focus to the beginning of the document. If a selected date is
            // focused before `flatpickrInstance.changeMonth` is invoked then it should remain focused.
            let shouldRefocusDateElement = this.flatpickrInstance.selectedDateElem === document.activeElement;
            this.flatpickrInstance.changeMonth(currentMonth, false);
            if (shouldRefocusDateElement) {
                this.flatpickrInstance.selectedDateElem.focus();
            }
        }
        this.valueChange.emit(selectedValue);
        this.propagateChange(selectedValue);
    }
    didDateValueChange(currentValue, previousValue) {
        return currentValue[0] !== previousValue[0] || currentValue[1] !== previousValue[1];
    }
    /**
     * More advanced checking of the loaded state of flatpickr
     */
    isFlatpickrLoaded() {
        // cast the instance to a boolean, and some method that has to exist for the library to be loaded in this case `setDate`
        return !!this.flatpickrInstance && !!this.flatpickrInstance.setDate;
    }
    /**
     * Right arrow HTML passed to flatpickr
     */
    rightArrowHTML() {
        return `
			<svg width="16px" height="16px" viewBox="0 0 16 16">
				<polygon points="11,8 6,13 5.3,12.3 9.6,8 5.3,3.7 6,3 "/>
				<rect width="16" height="16" style="fill:none" />
			</svg>`;
    }
    /**
     * Left arrow HTML passed to flatpickr
     */
    leftArrowHTML() {
        return `
			<svg width="16px" height="16px" viewBox="0 0 16 16">
				<polygon points="5,8 10,3 10.7,3.7 6.4,8 10.7,12.3 10,13 "/>
				<rect width="16" height="16" style="fill:none" />
			</svg>`;
    }
}
DatePicker.datePickerCount = 0;
DatePicker.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DatePicker, deps: [{ token: i0.ElementRef }, { token: i1.I18n }], target: i0.ɵɵFactoryTarget.Component });
DatePicker.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: DatePicker, selector: "cds-date-picker, ibm-date-picker", inputs: { range: "range", dateFormat: "dateFormat", language: "language", label: "label", helperText: "helperText", rangeHelperText: "rangeHelperText", rangeLabel: "rangeLabel", placeholder: "placeholder", ariaLabel: "ariaLabel", inputPattern: "inputPattern", id: "id", value: "value", theme: "theme", disabled: "disabled", invalid: "invalid", invalidText: "invalidText", warn: "warn", warnText: "warnText", size: "size", rangeInvalid: "rangeInvalid", rangeInvalidText: "rangeInvalidText", rangeWarn: "rangeWarn", rangeWarnText: "rangeWarnText", skeleton: "skeleton", plugins: "plugins", flatpickrOptions: "flatpickrOptions" }, outputs: { valueChange: "valueChange", onClose: "onClose" }, host: { listeners: { "focusin": "onFocus()", "focusout": "onFocusOut()" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: DatePicker,
            multi: true
        }
    ], viewQueries: [{ propertyName: "input", first: true, predicate: ["input"], descendants: true, static: true }, { propertyName: "rangeInput", first: true, predicate: ["rangeInput"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
	<div class="cds--form-item">
		<div
			class="cds--date-picker"
			[ngClass]="{
				'cds--date-picker--range' : range,
				'cds--date-picker--single' : !range,
				'cds--date-picker--light' : theme === 'light',
				'cds--skeleton' : skeleton
			}">
			<div class="cds--date-picker-container">
				<cds-date-picker-input
					#input
					[label]="label"
					[placeholder]="placeholder"
					[pattern]="inputPattern"
					[id]="id + '-input'"
					[size]="size"
					[type]="(range ? 'range' : 'single')"
					[hasIcon]="(range ? false : true)"
					[disabled]="disabled"
					[invalid]="invalid"
					[invalidText]="invalidText"
					[warn]="warn"
					[warnText]="warnText"
					[skeleton]="skeleton"
					[helperText]="helperText"
					(valueChange)="onValueChange($event)"
					(click)="openCalendar(input)">
				</cds-date-picker-input>
			</div>

			<div *ngIf="range" class="cds--date-picker-container">
				<cds-date-picker-input
					#rangeInput
					[label]="rangeLabel"
					[placeholder]="placeholder"
					[pattern]="inputPattern"
					[id]="id + '-rangeInput'"
					[size]="size"
					[type]="(range ? 'range' : 'single')"
					[hasIcon]="(range ? true : null)"
					[disabled]="disabled"
					[invalid]="rangeInvalid"
					[invalidText]="rangeInvalidText"
					[warn]="rangeWarn"
					[warnText]="rangeWarnText"
					[skeleton]="skeleton"
					[helperText]="rangeHelperText"
					(valueChange)="onRangeValueChange($event)"
					(click)="openCalendar(rangeInput)">
				</cds-date-picker-input>
			</div>
		</div>
	</div>
	`, isInline: true, dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i3.DatePickerInput, selector: "cds-date-picker-input, ibm-date-picker-input", inputs: ["type", "id", "hasIcon", "label", "placeholder", "pattern", "theme", "disabled", "invalid", "invalidText", "warn", "warnText", "helperText", "skeleton", "value", "size"], outputs: ["valueChange"] }], encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DatePicker, decorators: [{
            type: Component,
            args: [{
                    selector: "cds-date-picker, ibm-date-picker",
                    template: `
	<div class="cds--form-item">
		<div
			class="cds--date-picker"
			[ngClass]="{
				'cds--date-picker--range' : range,
				'cds--date-picker--single' : !range,
				'cds--date-picker--light' : theme === 'light',
				'cds--skeleton' : skeleton
			}">
			<div class="cds--date-picker-container">
				<cds-date-picker-input
					#input
					[label]="label"
					[placeholder]="placeholder"
					[pattern]="inputPattern"
					[id]="id + '-input'"
					[size]="size"
					[type]="(range ? 'range' : 'single')"
					[hasIcon]="(range ? false : true)"
					[disabled]="disabled"
					[invalid]="invalid"
					[invalidText]="invalidText"
					[warn]="warn"
					[warnText]="warnText"
					[skeleton]="skeleton"
					[helperText]="helperText"
					(valueChange)="onValueChange($event)"
					(click)="openCalendar(input)">
				</cds-date-picker-input>
			</div>

			<div *ngIf="range" class="cds--date-picker-container">
				<cds-date-picker-input
					#rangeInput
					[label]="rangeLabel"
					[placeholder]="placeholder"
					[pattern]="inputPattern"
					[id]="id + '-rangeInput'"
					[size]="size"
					[type]="(range ? 'range' : 'single')"
					[hasIcon]="(range ? true : null)"
					[disabled]="disabled"
					[invalid]="rangeInvalid"
					[invalidText]="rangeInvalidText"
					[warn]="rangeWarn"
					[warnText]="rangeWarnText"
					[skeleton]="skeleton"
					[helperText]="rangeHelperText"
					(valueChange)="onRangeValueChange($event)"
					(click)="openCalendar(rangeInput)">
				</cds-date-picker-input>
			</div>
		</div>
	</div>
	`,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: DatePicker,
                            multi: true
                        }
                    ],
                    encapsulation: ViewEncapsulation.None
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.I18n }]; }, propDecorators: { range: [{
                type: Input
            }], dateFormat: [{
                type: Input
            }], language: [{
                type: Input
            }], label: [{
                type: Input
            }], helperText: [{
                type: Input
            }], rangeHelperText: [{
                type: Input
            }], rangeLabel: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], inputPattern: [{
                type: Input
            }], id: [{
                type: Input
            }], value: [{
                type: Input
            }], theme: [{
                type: Input
            }], disabled: [{
                type: Input
            }], invalid: [{
                type: Input
            }], invalidText: [{
                type: Input
            }], warn: [{
                type: Input
            }], warnText: [{
                type: Input
            }], size: [{
                type: Input
            }], rangeInvalid: [{
                type: Input
            }], rangeInvalidText: [{
                type: Input
            }], rangeWarn: [{
                type: Input
            }], rangeWarnText: [{
                type: Input
            }], skeleton: [{
                type: Input
            }], plugins: [{
                type: Input
            }], flatpickrOptions: [{
                type: Input
            }], input: [{
                type: ViewChild,
                args: ["input", { static: true }]
            }], rangeInput: [{
                type: ViewChild,
                args: ["rangeInput"]
            }], valueChange: [{
                type: Output
            }], onClose: [{
                type: Output
            }], onFocus: [{
                type: HostListener,
                args: ["focusin"]
            }], onFocusOut: [{
                type: HostListener,
                args: ["focusout"]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLGlCQUFpQixFQUdqQixZQUFZLEVBTVosU0FBUyxFQUdULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sV0FBVyxNQUFNLG9DQUFvQyxDQUFDO0FBQzdELE9BQU8sU0FBUyxNQUFNLFdBQVcsQ0FBQztBQUNsQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNuRCxPQUFPLEVBQUUsZ0NBQWdDLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUNuRixPQUFPLEtBQUssU0FBUyxNQUFNLDJCQUEyQixDQUFDOzs7OztBQUl2RDs7Ozs7OztHQU9HO0FBQ0gsSUFBSSxTQUFTLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxRQUFRLEVBQUU7SUFDOUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLFNBQXNCLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDOUgsSUFBSSxHQUFHLEtBQUssVUFBVSxFQUFFO1lBQ3ZCLE9BQU8sSUFBSSxDQUFDO1NBQ1o7UUFDRCxPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEIsQ0FBQyxDQUFDLENBQUM7Q0FDSDtBQUVEOztHQUVHO0FBb0VILE1BQU0sT0FBTyxVQUFVO0lBa0x0QixZQUNXLFVBQXNCLEVBQ3RCLElBQVU7UUFEVixlQUFVLEdBQVYsVUFBVSxD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STtzQkFBWixLQUFLO2dCQUlHLFlBQVk7c0JBQXBCLEtBQUs7Z0JBSUcsZ0JBQWdCO3NCQUF4QixLQUFLO2dCQUlHLFNBQVM7c0JBQWpCLEtBQUs7Z0JBSUcsYUFBYTtzQkFBckIsS0FBSztnQkFFRyxRQUFRO3NCQUFoQixLQUFLO2dCQUVHLE9BQU87c0JBQWYsS0FBSztnQkFHRixnQkFBZ0I7c0JBRG5CLEtBQUs7Z0JBaUJnQyxLQUFLO3NCQUExQyxTQUFTO3VCQUFDLE9BQU8sRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBQ1gsVUFBVTtzQkFBbEMsU0FBUzt1QkFBQyxZQUFZO2dCQUViLFdBQVc7c0JBQXBCLE1BQU07Z0JBTUcsT0FBTztzQkFBaEIsTUFBTTtnQkF3R1AsT0FBTztzQkFETixZQUFZO3VCQUFDLFNBQVM7Z0JBZ0J2QixVQUFVO3NCQURULFlBQVk7dUJBQUMsVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0SW5wdXQsXG5cdE91dHB1dCxcblx0RXZlbnRFbWl0dGVyLFxuXHRWaWV3RW5jYXBzdWxhdGlvbixcblx0RWxlbWVudFJlZixcblx0T25EZXN0cm95LFxuXHRIb3N0TGlzdGVuZXIsXG5cdFRlbXBsYXRlUmVmLFxuXHRPbkNoYW5nZXMsXG5cdFNpbXBsZUNoYW5nZXMsXG5cdEFmdGVyVmlld0NoZWNrZWQsXG5cdEFmdGVyVmlld0luaXQsXG5cdFZpZXdDaGlsZCxcblx0T25Jbml0LFxuXHRTaW1wbGVDaGFuZ2Vcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCByYW5nZVBsdWdpbiBmcm9tIFwiZmxhdHBpY2tyL2Rpc3QvcGx1Z2lucy9yYW5nZVBsdWdpblwiO1xuaW1wb3J0IGZsYXRwaWNrciBmcm9tIFwiZmxhdHBpY2tyXCI7XG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xuaW1wb3J0IHsgY2FyYm9uRmxhdHBpY2tyTW9udGhTZWxlY3RQbHVnaW4gfSBmcm9tIFwiLi9jYXJib24tZmxhdHBpY2tyLW1vbnRoLXNlbGVjdFwiO1xuaW1wb3J0ICogYXMgbGFuZ3VhZ2VzIGZyb20gXCJmbGF0cGlja3IvZGlzdC9sMTBuL2luZGV4XCI7XG5pbXBvcnQgeyBEYXRlUGlja2VySW5wdXQgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9kYXRlcGlja2VyLWlucHV0XCI7XG5pbXBvcnQgeyBJMThuIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvaTE4blwiO1xuXG4vKipcbiAqIER1ZSB0byB0eXBlIGVycm9yLCB3ZSBoYXZlIHRvIHVzZSBzcXVhcmUgYnJhY2tldHMgcHJvcGVydHkgYWNjZXNzb3JcbiAqIFRoZXJlIGlzIGEgd2VicGFjayBpc3N1ZSB3aGVuIGF0dGVtcHRpbmcgdG8gYWNjZXNzIGV4cG9ydGVkIGxhbmd1YWdlcyBmcm9tIGZsYXRwaWNrciBsMTBuIEFuZ3VsYXIgMTQrIGFwcHNcbiAqIGxhbmd1YWdlcy5kZWZhdWx0W2xvY2FsZV0gZmFpbHMgaW4gYXBwIGNvbnN1bWluZyBDQ0EgbGlicmFyeSBidXQgcGFzc2VzIGluIHRlc3RcbiAqIGxhbmd1YWdlcy5kZWZhdWx0LmRlZmF1bHRbbG9jYWxlXSBmYWlscyBpbiB0ZXN0IGJ1dCB3b3JrcyBpbiBhcHAgY29uc3VtaW5nIENDQSBsaWJyYXJ5LlxuICpcbiAqIFRvIHBsZWFzZSBib3RoIHNjZW5hcmlvcywgd2UgYXJlIGFkZGluZyBhIGNvbmRpdGlvbiB0byBwcmV2ZW50IHRlc3RzIGZyb20gZmFpbGluZ1xuICovXG5pZiAobGFuZ3VhZ2VzLmRlZmF1bHQ/LmRlZmF1bHRbXCJlblwiXT8ud2Vla2RheXMpIHtcblx0KGxhbmd1YWdlcy5kZWZhdWx0LmRlZmF1bHRbXCJlblwiXS53ZWVrZGF5cy5zaG9ydGhhbmQgYXMgc3RyaW5nW10pID0gbGFuZ3VhZ2VzLmRlZmF1bHQuZGVmYXVsdFtcImVuXCJdLndlZWtkYXlzLmxvbmdoYW5kLm1hcChkYXkgPT4ge1xuXHRcdGlmIChkYXkgPT09IFwiVGh1cnNkYXlcIikge1xuXHRcdFx0cmV0dXJuIFwiVGhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIGRheS5jaGFyQXQoMCk7XG5cdH0pO1xufVxuXG4vKipcbiAqIFtTZWUgZGVtb10oLi4vLi4vP3BhdGg9L3N0b3J5L2NvbXBvbmVudHMtZGF0ZS1waWNrZXItLXNpbmdsZSlcbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImNkcy1kYXRlLXBpY2tlciwgaWJtLWRhdGUtcGlja2VyXCIsXG5cdHRlbXBsYXRlOiBgXG5cdDxkaXYgY2xhc3M9XCJjZHMtLWZvcm0taXRlbVwiPlxuXHRcdDxkaXZcblx0XHRcdGNsYXNzPVwiY2RzLS1kYXRlLXBpY2tlclwiXG5cdFx0XHRbbmdDbGFzc109XCJ7XG5cdFx0XHRcdCdjZHMtLWRhdGUtcGlja2VyLS1yYW5nZScgOiByYW5nZSxcblx0XHRcdFx0J2Nkcy0tZGF0ZS1waWNrZXItLXNpbmdsZScgOiAhcmFuZ2UsXG5cdFx0XHRcdCdjZHMtLWRhdGUtcGlja2VyLS1saWdodCcgOiB0aGVtZSA9PT0gJ2xpZ2h0Jyxcblx0XHRcdFx0J2Nkcy0tc2tlbGV0b24nIDogc2tlbGV0b25cblx0XHRcdH1cIj5cblx0XHRcdDxkaXYgY2xhc3M9XCJjZHMtLWRhdGUtcGlja2VyLWNvbnRhaW5lclwiPlxuXHRcdFx0XHQ8Y2RzLWRhdGUtcGlja2VyLWlucHV0XG5cdFx0XHRcdFx0I2lucHV0XG5cdFx0XHRcdFx0W2xhYmVsXT1cImxhYmVsXCJcblx0XHRcdFx0XHRbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIlxuXHRcdFx0XHRcdFtwYXR0ZXJuXT1cImlucHV0UGF0dGVyblwiXG5cdFx0XHRcdFx0W2lkXT1cImlkICsgJy1pbnB1dCdcIlxuXHRcdFx0XHRcdFtzaXplXT1cInNpemVcIlxuXHRcdFx0XHRcdFt0eXBlXT1cIihyYW5nZSA/ICdyYW5nZScgOiAnc2luZ2xlJylcIlxuXHRcdFx0XHRcdFtoYXNJY29uXT1cIihyYW5nZSA/IGZhbHNlIDogdHJ1ZSlcIlxuXHRcdFx0XHRcdFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG5cdFx0XHRcdFx0W2ludmFsaWRdPVwiaW52YWxpZFwiXG5cdFx0XHRcdFx0W2ludmFsaWRUZXh0XT1cImludmFsaWRUZXh0XCJcblx0XHRcdFx0XHRbd2Fybl09XCJ3YXJuXCJcblx0XHRcdFx0XHRbd2FyblRleHRdPVwid2FyblRleHRcIlxuXHRcdFx0XHRcdFtza2VsZXRvbl09XCJza2VsZXRvblwiXG5cdFx0XHRcdFx0W2hlbHBlclRleHRdPVwiaGVscGVyVGV4dFwiXG5cdFx0XHRcdFx0KHZhbHVlQ2hhbmdlKT1cIm9uVmFsdWVDaGFuZ2UoJGV2ZW50KVwiXG5cdFx0XHRcdFx0KGNsaWNrKT1cIm9wZW5DYWxlbmRhcihpbnB1dClcIj5cblx0XHRcdFx0PC9jZHMtZGF0ZS1waWNrZXItaW5wdXQ+XG5cdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PGRpdiAqbmdJZj1cInJhbmdlXCIgY2xhc3M9XCJjZHMtLWRhdGUtcGlja2VyLWNvbnRhaW5lclwiPlxuXHRcdFx0XHQ8Y2RzLWRhdGUtcGlja2VyLWlucHV0XG5cdFx0XHRcdFx0I3JhbmdlSW5wdXRcblx0XHRcdFx0XHRbbGFiZWxdPVwicmFuZ2VMYWJlbFwiXG5cdFx0XHRcdFx0W3BsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCJcblx0XHRcdFx0XHRbcGF0dGVybl09XCJpbnB1dFBhdHRlcm5cIlxuXHRcdFx0XHRcdFtpZF09XCJpZCArICctcmFuZ2VJbnB1dCdcIlxuXHRcdFx0XHRcdFtzaXplXT1cInNpemVcIlxuXHRcdFx0XHRcdFt0eXBlXT1cIihyYW5nZSA/ICdyYW5nZScgOiAnc2luZ2xlJylcIlxuXHRcdFx0XHRcdFtoYXNJY29uXT1cIihyYW5nZSA/IHRydWUgOiBudWxsKVwiXG5cdFx0XHRcdFx0W2Rpc2FibGVkXT1cImRpc2FibGVkXCJcblx0XHRcdFx0XHRbaW52YWxpZF09XCJyYW5nZUludmFsaWRcIlxuXHRcdFx0XHRcdFtpbnZhbGlkVGV4dF09XCJyYW5nZUludmFsaWRUZXh0XCJcblx0XHRcdFx0XHRbd2Fybl09XCJyYW5nZVdhcm5cIlxuXHRcdFx0XHRcdFt3YXJuVGV4dF09XCJyYW5nZVdhcm5UZXh0XCJcblx0XHRcdFx0XHRbc2tlbGV0b25dPVwic2tlbGV0b25cIlxuXHRcdFx0XHRcdFtoZWxwZXJUZXh0XT1cInJhbmdlSGVscGVyVGV4dFwiXG5cdFx0XHRcdFx0KHZhbHVlQ2hhbmdlKT1cIm9uUmFuZ2VWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcblx0XHRcdFx0XHQoY2xpY2spPVwib3BlbkNhbGVuZGFyKHJhbmdlSW5wdXQpXCI+XG5cdFx0XHRcdDwvY2RzLWRhdGUtcGlja2VyLWlucHV0PlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+XG5cdDwvZGl2PlxuXHRgLFxuXHRwcm92aWRlcnM6IFtcblx0XHR7XG5cdFx0XHRwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcblx0XHRcdHVzZUV4aXN0aW5nOiBEYXRlUGlja2VyLFxuXHRcdFx0bXVsdGk6IHRydWVcblx0XHR9XG5cdF0sXG5cdGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgRGF0ZVBpY2tlciBpbXBsZW1lbnRzXG5cdE9uSW5pdCxcblx0T25EZXN0cm95LFxuXHRPbkNoYW5nZXMsXG5cdEFmdGVyVmlld0NoZWNrZWQsXG5cdEFmdGVyVmlld0luaXQge1xuXHRwcml2YXRlIHN0YXRpYyBkYXRlUGlja2VyQ291bnQgPSAwO1xuXG5cdC8qKlxuXHQgKiBTZWxlY3QgY2FsZW5kYXIgcmFuZ2UgbW9kZVxuXHQgKi9cblx0QElucHV0KCkgcmFuZ2UgPSBmYWxzZTtcblxuXHQvKipcblx0ICogRm9ybWF0IG9mIGRhdGVcblx0ICpcblx0ICogRm9yIHJlZmVyZW5jZTogaHR0cHM6Ly9mbGF0cGlja3IuanMub3JnL2Zvcm1hdHRpbmcvXG5cdCAqL1xuXHRASW5wdXQoKSBkYXRlRm9ybWF0ID0gXCJtL2QvWVwiO1xuXG5cdC8qKlxuXHQgKiBMYW5ndWFnZSBvZiB0aGUgZmxhdHBpY2tyIGNhbGVuZGFyLlxuXHQgKlxuXHQgKiBGb3IgcmVmZXJlbmNlIG9mIHRoZSBwb3NzaWJsZSBsb2NhbGVzOlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vZmxhdHBpY2tyL2ZsYXRwaWNrci9ibG9iL21hc3Rlci9zcmMvbDEwbi9pbmRleC50c1xuXHQgKi9cblx0QElucHV0KCkgbGFuZ3VhZ2UgPSBcImVuXCI7XG5cblx0QElucHV0KCkgbGFiZWw6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cdEBJbnB1dCgpIGhlbHBlclRleHQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cdEBJbnB1dCgpIHJhbmdlSGVscGVyVGV4dDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55Pjtcblx0QElucHV0KCkgcmFuZ2VMYWJlbDogc3RyaW5nO1xuXG5cdEBJbnB1dCgpIHBsYWNlaG9sZGVyID0gXCJtbS9kZC95eXl5XCI7XG5cblx0LyoqXG5cdCAqIEFyaWEgbGFiZWwgYWRkZWQgdG8gZGF0ZXBpY2tlcidzIGNhbGVuZGFyIGNvbnRhaW5lci5cblx0ICovXG5cdEBJbnB1dCgpIGFyaWFMYWJlbCA9IFwiY2FsZW5kYXIgY29udGFpbmVyXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwYXR0ZXJuIGZvciB0aGUgdW5kZXJseWluZyBpbnB1dCBlbGVtZW50XG5cdCAqL1xuXHRASW5wdXQoKSBpbnB1dFBhdHRlcm4gPSBcIl5cXFxcZHsxLDJ9L1xcXFxkezEsMn0vXFxcXGR7NH0kXCI7XG5cblx0QElucHV0KCkgaWQgPSBgZGF0ZXBpY2tlci0ke0RhdGVQaWNrZXIuZGF0ZVBpY2tlckNvdW50Kyt9YDtcblxuXHRASW5wdXQoKSBzZXQgdmFsdWUodjogKERhdGUgfCBzdHJpbmcpW10pIHtcblx0XHRpZiAoIXYpIHtcblx0XHRcdHYgPSBbXTtcblx0XHR9XG5cdFx0dGhpcy5fdmFsdWUgPSB2O1xuXHR9XG5cblx0Z2V0IHZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2NSAtIFVzZSBgY2RzTGF5ZXJgIGRpcmVjdGl2ZSBpbnN0ZWFkXG5cdCAqIFNldCB0byBgXCJsaWdodFwiYCB0byBhcHBseSB0aGUgbGlnaHQgc3R5bGVcblx0ICovXG5cdEBJbnB1dCgpIHRoZW1lOiBcImxpZ2h0XCIgfCBcImRhcmtcIiA9IFwiZGFya1wiO1xuXG5cdEBJbnB1dCgpIGRpc2FibGVkID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIHRvIGRpc3BsYXkgdGhlIGludmFsaWQgc3RhdGUuXG5cdCAqL1xuXHRASW5wdXQoKSBpbnZhbGlkID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBWYWx1ZSBkaXNwbGF5ZWQgaWYgZGF0ZXBpY2tlciBpcyBpbiBhbiBpbnZhbGlkIHN0YXRlLlxuXHQgKi9cblx0QElucHV0KCkgaW52YWxpZFRleHQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cdC8qKlxuXHQgICogU2V0IHRvIGB0cnVlYCB0byBzaG93IGEgd2FybmluZyAoY29udGVudHMgc2V0IGJ5IHdhcm5pbmdUZXh0KVxuXHQgICovXG5cdEBJbnB1dCgpIHdhcm4gPSBmYWxzZTtcblx0LyoqXG5cdCAqIFNldHMgdGhlIHdhcm5pbmcgdGV4dFxuXHQgKi9cblx0QElucHV0KCkgd2FyblRleHQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cblx0QElucHV0KCkgc2l6ZTogXCJzbVwiIHwgXCJtZFwiIHwgXCJsZ1wiID0gXCJtZFwiO1xuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCB0byBkaXNwbGF5IHRoZSBpbnZhbGlkIHN0YXRlIGZvciB0aGUgc2Vjb25kIGRhdGVwaWNrZXIgaW5wdXQuXG5cdCAqL1xuXHRASW5wdXQoKSByYW5nZUludmFsaWQgPSBmYWxzZTtcblx0LyoqXG5cdCAqIFZhbHVlIGRpc3BsYXllZCBpZiB0aGUgc2Vjb25kIGRhdGVwaWNrZXIgaW5wdXQgaXMgaW4gYW4gaW52YWxpZCBzdGF0ZS5cblx0ICovXG5cdEBJbnB1dCgpIHJhbmdlSW52YWxpZFRleHQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cdC8qKlxuXHQgICogU2V0IHRvIGB0cnVlYCB0byBzaG93IGEgd2FybmluZyBpbiB0aGUgc2Vjb25kIGRhdGVwaWNrZXIgaW5wdXQgKGNvbnRlbnRzIHNldCBieSByYW5nZVdhcm5pbmdUZXh0KVxuXHQgICovXG5cdEBJbnB1dCgpIHJhbmdlV2FybiA9IGZhbHNlO1xuXHQvKipcblx0ICogU2V0cyB0aGUgd2FybmluZyB0ZXh0IGZvciB0aGUgc2Vjb25kIGRhdGVwaWNrZXIgaW5wdXRcblx0ICovXG5cdEBJbnB1dCgpIHJhbmdlV2FyblRleHQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cblx0QElucHV0KCkgc2tlbGV0b24gPSBmYWxzZTtcblxuXHRASW5wdXQoKSBwbHVnaW5zID0gW107XG5cblx0QElucHV0KClcblx0c2V0IGZsYXRwaWNrck9wdGlvbnMob3B0aW9ucykge1xuXHRcdHRoaXMuX2ZsYXRwaWNrck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9mbGF0cGlja3JPcHRpb25zLCBvcHRpb25zKTtcblx0fVxuXHRnZXQgZmxhdHBpY2tyT3B0aW9ucygpIHtcblx0XHRjb25zdCBwbHVnaW5zID0gWy4uLnRoaXMucGx1Z2lucywgY2FyYm9uRmxhdHBpY2tyTW9udGhTZWxlY3RQbHVnaW5dO1xuXHRcdGlmICh0aGlzLnJhbmdlKSB7XG5cdFx0XHRwbHVnaW5zLnB1c2gocmFuZ2VQbHVnaW4oeyBpbnB1dDogYCMke3RoaXMuaWR9LXJhbmdlSW5wdXRgLCBwb3NpdGlvbjogXCJsZWZ0XCIgfSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fZmxhdHBpY2tyT3B0aW9ucywgdGhpcy5mbGF0cGlja3JCYXNlT3B0aW9ucywge1xuXHRcdFx0bW9kZTogdGhpcy5yYW5nZSA/IFwicmFuZ2VcIiA6IFwic2luZ2xlXCIsXG5cdFx0XHRwbHVnaW5zLFxuXHRcdFx0ZGF0ZUZvcm1hdDogdGhpcy5kYXRlRm9ybWF0LFxuXHRcdFx0bG9jYWxlOiBsYW5ndWFnZXMuZGVmYXVsdD8uZGVmYXVsdFt0aGlzLmxhbmd1YWdlXSB8fCBsYW5ndWFnZXMuZGVmYXVsdFt0aGlzLmxhbmd1YWdlXVxuXHRcdH0pO1xuXHR9XG5cblx0QFZpZXdDaGlsZChcImlucHV0XCIsIHsgc3RhdGljOiB0cnVlIH0pIGlucHV0OiBEYXRlUGlja2VySW5wdXQ7XG5cdEBWaWV3Q2hpbGQoXCJyYW5nZUlucHV0XCIpIHJhbmdlSW5wdXQ6IERhdGVQaWNrZXJJbnB1dDtcblxuXHRAT3V0cHV0KCkgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cdC8qKlxuXHQgKiBXZSBhcmUgb3ZlcnJpZGluZyBvbkNsb3NlIGV2ZW50IGV2ZW4gaWYgdXNlcnMgcGFzcyBpdCB2aWEgZmxhdHBpY2tyIG9wdGlvbnNcblx0ICogRW1pdHMgYW4gZXZlbnQgd2hlbiBkYXRlIHBpY2tlciBjbG9zZXNcblx0ICovXG5cdEBPdXRwdXQoKSBvbkNsb3NlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXHRwcm90ZWN0ZWQgX3ZhbHVlID0gW107XG5cblx0cHJvdGVjdGVkIF9mbGF0cGlja3JPcHRpb25zID0ge1xuXHRcdGFsbG93SW5wdXQ6IHRydWVcblx0fTtcblxuXHRwcm90ZWN0ZWQgZmxhdHBpY2tyQmFzZU9wdGlvbnMgPSB7XG5cdFx0bW9kZTogXCJzaW5nbGVcIixcblx0XHRkYXRlRm9ybWF0OiBcIm0vZC9ZXCIsXG5cdFx0cGx1Z2luczogdGhpcy5wbHVnaW5zLFxuXHRcdG9uT3BlbjogKCkgPT4ge1xuXHRcdFx0dGhpcy51cGRhdGVDbGFzc05hbWVzKCk7XG5cdFx0XHR0aGlzLnVwZGF0ZUF0dHJpYnV0ZXMoKTtcblx0XHRcdHRoaXMudXBkYXRlQ2FsZW5kYXJMaXN0ZW5lcnMoKTtcblx0XHR9LFxuXHRcdG9uQ2xvc2U6IChkYXRlKSA9PiB7XG5cdFx0XHQvLyBUaGlzIG1ha2VzIHN1cmUgdGhhdCB0aGUgYGZsYXRwaWNrckluc3RhbmNlIHNlbGVjdGVkRGF0ZXNgIGFyZSBpbiBzeW5jIHdpdGggdGhlIHZhbHVlcyBvZlxuXHRcdFx0Ly8gdGhlIGlucHV0cyB3aGVuIHRoZSBjYWxlbmRhciBjbG9zZXMuXG5cdFx0XHRpZiAodGhpcy5yYW5nZSAmJiB0aGlzLmZsYXRwaWNrckluc3RhbmNlKSB7XG5cdFx0XHRcdGlmICh0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXMubGVuZ3RoICE9PSAyKSB7XG5cdFx0XHRcdFx0Ly8gd2UgY291bGQgYHRoaXMuZmxhdHBpY2tySW5zdGFuY2UuY2xlYXIoKWAgYnV0IGl0IGluc2lzdHMgb24gb3BlbmluZyB0aGUgc2Vjb25kIHBpY2tlclxuXHRcdFx0XHRcdC8vIGluIHNvbWUgY2FzZXMsIHNvIGluc3RlYWQgd2UgZG8gdGhpc1xuXHRcdFx0XHRcdHRoaXMuc2V0RGF0ZVZhbHVlcyhbXSk7XG5cdFx0XHRcdFx0dGhpcy5kb1NlbGVjdChbXSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IGlucHV0VmFsdWUgPSB0aGlzLmlucHV0LmlucHV0Lm5hdGl2ZUVsZW1lbnQudmFsdWU7XG5cdFx0XHRcdGNvbnN0IHJhbmdlSW5wdXRWYWx1ZSA9IHRoaXMucmFuZ2VJbnB1dC5pbnB1dC5uYXRpdmVFbGVtZW50LnZhbHVlO1xuXHRcdFx0XHRpZiAoaW5wdXRWYWx1ZSB8fCByYW5nZUlucHV0VmFsdWUpIHtcblx0XHRcdFx0XHRjb25zdCBwYXJzZURhdGUgPSAoZGF0ZTogc3RyaW5nKSA9PiB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnBhcnNlRGF0ZShkYXRlLCB0aGlzLmRhdGVGb3JtYXQpO1xuXHRcdFx0XHRcdHRoaXMuc2V0RGF0ZVZhbHVlcyhbcGFyc2VEYXRlKGlucHV0VmFsdWUpLCBwYXJzZURhdGUocmFuZ2VJbnB1dFZhbHVlKV0pO1xuXHRcdFx0XHRcdHRoaXMuZG9TZWxlY3QodGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5vbkNsb3NlLmVtaXQoZGF0ZSk7XG5cdFx0fSxcblx0XHRvbkRheUNyZWF0ZTogKF9kT2JqLCBfZFN0ciwgX2ZwLCBkYXlFbGVtKSA9PiB7XG5cdFx0XHRkYXlFbGVtLmNsYXNzTGlzdC5hZGQoXCJjZHMtLWRhdGUtcGlja2VyX19kYXlcIik7XG5cdFx0fSxcblx0XHRuZXh0QXJyb3c6IHRoaXMucmlnaHRBcnJvd0hUTUwoKSxcblx0XHRwcmV2QXJyb3c6IHRoaXMubGVmdEFycm93SFRNTCgpLFxuXHRcdHZhbHVlOiB0aGlzLnZhbHVlXG5cdH07XG5cblx0cHJvdGVjdGVkIGZsYXRwaWNrckluc3RhbmNlID0gbnVsbDtcblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRwcm90ZWN0ZWQgZWxlbWVudFJlZjogRWxlbWVudFJlZixcblx0XHRwcm90ZWN0ZWQgaTE4bjogSTE4blxuXHQpIHsgfVxuXG5cdG5nT25Jbml0KCkge1xuXHRcdC8vIGlmIGkxOG4gaXMgc2V0IHRvIGFueXRoaW5nIG90aGVyIHRoYW4gZW4gd2UnbGwgd2FudCB0byBjaGFuZ2UgdGhlIGxhbmd1YWdlXG5cdFx0Ly8gb3RoZXJ3aXNlIHdlJ2xsIGp1c3QgdXNlIHRoZSBsb2NhbCBzZXR0aW5nXG5cdFx0aWYgKHRoaXMuaTE4bi5nZXRMb2NhbGUoKSAhPT0gXCJlblwiKSB7XG5cdFx0XHR0aGlzLmkxOG4uZ2V0TG9jYWxlT2JzZXJ2YWJsZSgpLnN1YnNjcmliZShsb2NhbGUgPT4ge1xuXHRcdFx0XHR0aGlzLmxhbmd1YWdlID0gbG9jYWxlO1xuXHRcdFx0XHR0aGlzLnJlc2V0RmxhdHBpY2tySW5zdGFuY2UoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcblx0XHQvLyBSZXNldCB0aGUgZmxhdHBpY2tyIGluc3RhbmNlIG9uIGlucHV0IGNoYW5nZXMgdGhhdCBhZmZlY3QgZmxhdHBpY2tyLlxuXHRcdGNvbnN0IGZsYXRwaWNrckNoYW5nZUtleXMgPSBbXG5cdFx0XHRcInJhbmdlXCIsXG5cdFx0XHRcImRhdGVGb3JtYXRcIixcblx0XHRcdFwibGFuZ3VhZ2VcIixcblx0XHRcdFwiaWRcIixcblx0XHRcdFwidmFsdWVcIixcblx0XHRcdFwicGx1Z2luc1wiLFxuXHRcdFx0XCJmbGF0cGlja3JPcHRpb25zXCJcblx0XHRdO1xuXHRcdGNvbnN0IGNoYW5nZUtleXMgPSBPYmplY3Qua2V5cyhjaGFuZ2VzKTtcblx0XHRpZiAoY2hhbmdlS2V5cy5zb21lKGtleSA9PiBmbGF0cGlja3JDaGFuZ2VLZXlzLmluY2x1ZGVzKGtleSkpKSB7XG5cdFx0XHR0aGlzLnJlc2V0RmxhdHBpY2tySW5zdGFuY2UoY2hhbmdlcy52YWx1ZSk7XG5cdFx0fVxuXHR9XG5cblx0bmdBZnRlclZpZXdJbml0KCkge1xuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0dGhpcy5hZGRJbnB1dExpc3RlbmVycygpO1xuXHRcdH0sIDApO1xuXHR9XG5cblx0Ly8gYmVjYXVzZSB0aGUgYWN0dWFsIHZpZXcgbWF5IGJlIGRlbGF5ZWQgaW4gbG9hZGluZyAodGhpbmsgcHJvamVjdGlvbiBpbnRvIGEgdGFiIHBhbmUpXG5cdC8vIGFuZCBiZWNhdXNlIHdlIHJlbHkgb24gYSBsaWJyYXJ5IHRoYXQgb3BlcmF0ZXMgb3V0c2lkZSB0aGUgQW5ndWxhciB2aWV3IG9mIHRoZSB3b3JsZFxuXHQvLyB3ZSBuZWVkIHRvIGtlZXAgdHJ5aW5nIHRvIGxvYWQgdGhlIGxpYnJhcnksIHVudGlsIHRoZSByZWxldmFudCBET00gaXMgYWN0dWFsbHkgbGl2ZVxuXHRuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG5cdFx0aWYgKCF0aGlzLmlzRmxhdHBpY2tyTG9hZGVkKCkpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgdHMgaXMgdW5oYXBweSB3aXRoIHRoZSBiZWxvdyBjYWxsIHRvIGBmbGF0cGlja3JgXG5cdFx0XHR0aGlzLmZsYXRwaWNrckluc3RhbmNlID0gZmxhdHBpY2tyKGAjJHt0aGlzLmlkfS1pbnB1dGAsIHRoaXMuZmxhdHBpY2tyT3B0aW9ucyk7XG5cdFx0XHQvLyBpZiAoYW5kIG9ubHkgaWYpIHRoZSBpbml0aWFsaXphdGlvbiBzdWNjZWVkZWQsIHdlIGNhbiBzZXQgdGhlIGRhdGUgdmFsdWVzXG5cdFx0XHRpZiAodGhpcy5pc0ZsYXRwaWNrckxvYWRlZCgpKSB7XG5cdFx0XHRcdGlmICh0aGlzLnZhbHVlLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR0aGlzLnNldERhdGVWYWx1ZXModGhpcy52YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRASG9zdExpc3RlbmVyKFwiZm9jdXNpblwiKVxuXHRvbkZvY3VzKCkge1xuXHRcdC8vIFVwZGF0ZXMgdGhlIG1vbnRoIG1hbnVhbGx5IHdoZW4gY2FsZW5kYXIgbW9kZSBpcyByYW5nZSBiZWNhdXNlIG1vbnRoXG5cdFx0Ly8gd2lsbCBub3QgdXBkYXRlIHByb3Blcmx5IHdpdGhvdXQgbWFudWFsbHkgdXBkYXRpbmcgdGhlbSBvbiBmb2N1cy5cblx0XHRpZiAodGhpcy5yYW5nZSkge1xuXHRcdFx0aWYgKHRoaXMucmFuZ2VJbnB1dC5pbnB1dC5uYXRpdmVFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1sxXSkge1xuXHRcdFx0XHRjb25zdCBjdXJyZW50TW9udGggPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMV0uZ2V0TW9udGgoKTtcblx0XHRcdFx0dGhpcy5mbGF0cGlja3JJbnN0YW5jZS5jaGFuZ2VNb250aChjdXJyZW50TW9udGgsIGZhbHNlKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5pbnB1dC5pbnB1dC5uYXRpdmVFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1swXSkge1xuXHRcdFx0XHRjb25zdCBjdXJyZW50TW9udGggPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0TW9udGgoKTtcblx0XHRcdFx0dGhpcy5mbGF0cGlja3JJbnN0YW5jZS5jaGFuZ2VNb250aChjdXJyZW50TW9udGgsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRASG9zdExpc3RlbmVyKFwiZm9jdXNvdXRcIilcblx0b25Gb2N1c091dCgpIHtcblx0XHR0aGlzLm9uVG91Y2hlZCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdyaXRlcyBhIHZhbHVlIGZyb20gdGhlIG1vZGVsIHRvIHRoZSBjb21wb25lbnQuIEV4cGVjdHMgdGhlIHZhbHVlIHRvIGJlIGBudWxsYCBvciBgKERhdGUgfCBzdHJpbmcpW11gXG5cdCAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSByZWNlaXZlZCBmcm9tIHRoZSBtb2RlbFxuXHQgKi9cblx0d3JpdGVWYWx1ZSh2YWx1ZTogKERhdGUgfCBzdHJpbmcpW10pIHtcblx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRpZiAodGhpcy5pc0ZsYXRwaWNrckxvYWRlZCgpICYmIHRoaXMuZmxhdHBpY2tySW5zdGFuY2UuY29uZmlnKSB7XG5cdFx0XHRcdHRoaXMuc2V0RGF0ZVZhbHVlcyh0aGlzLnZhbHVlKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBgQ29udHJvbFZhbHVlQWNjZXNzb3JgIG1ldGhvZCB0byBwcm9ncmFtbWF0aWNhbGx5IGRpc2FibGUgdGhlIERhdGVQaWNrZXIuXG5cdCAqXG5cdCAqIGV4OiBgdGhpcy5mb3JtR3JvdXAuZ2V0KFwibXlEYXRlUGlja2VyXCIpLmRpc2FibGUoKTtgXG5cdCAqXG5cdCAqIEBwYXJhbSBpc0Rpc2FibGVkIGB0cnVlYCB0byBkaXNhYmxlIHRoZSBEYXRlUGlja2VyXG5cdCAqL1xuXHRzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pIHtcblx0XHR0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcblx0fVxuXG5cdHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSkge1xuXHRcdHRoaXMucHJvcGFnYXRlQ2hhbmdlID0gZm47XG5cdH1cblxuXHRyZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KSB7XG5cdFx0dGhpcy5vblRvdWNoZWQgPSBmbjtcblx0fVxuXG5cdG9uVG91Y2hlZDogKCkgPT4gYW55ID0gKCkgPT4geyB9O1xuXG5cdHByb3BhZ2F0ZUNoYW5nZSA9IChfOiBhbnkpID0+IHsgfTtcblxuXHQvKipcblx0ICogQ2xlYW5zIHVwIG91ciBmbGF0cGlja3IgaW5zdGFuY2Vcblx0ICovXG5cdG5nT25EZXN0cm95KCkge1xuXHRcdGlmICghdGhpcy5pc0ZsYXRwaWNrckxvYWRlZCgpKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuZmxhdHBpY2tySW5zdGFuY2UuZGVzdHJveSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgdGhlIGB2YWx1ZUNoYW5nZWAgZXZlbnQgZnJvbSB0aGUgcHJpbWFyeS9zaW5nbGUgaW5wdXRcblx0ICovXG5cdG9uVmFsdWVDaGFuZ2UoZXZlbnQ6IHN0cmluZykge1xuXHRcdGlmICh0aGlzLmlzRmxhdHBpY2tyTG9hZGVkKCkpIHtcblx0XHRcdGNvbnN0IGRhdGUgPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnBhcnNlRGF0ZShldmVudCwgdGhpcy5kYXRlRm9ybWF0KTtcblx0XHRcdGlmICh0aGlzLnJhbmdlKSB7XG5cdFx0XHRcdHRoaXMuc2V0RGF0ZVZhbHVlcyhbZGF0ZSwgdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzWzFdXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldERhdGVWYWx1ZXMoW2RhdGVdKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZG9TZWxlY3QodGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyB0aGUgYHZhbHVlQ2hhbmdlYCBldmVudCBmcm9tIHRoZSByYW5nZSBpbnB1dFxuXHQgKi9cblx0b25SYW5nZVZhbHVlQ2hhbmdlKGV2ZW50OiBzdHJpbmcpIHtcblx0XHRpZiAodGhpcy5pc0ZsYXRwaWNrckxvYWRlZCgpICYmIHRoaXMuZmxhdHBpY2tySW5zdGFuY2UuaXNPcGVuKSB7XG5cdFx0XHRjb25zdCBkYXRlID0gdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5wYXJzZURhdGUoZXZlbnQsIHRoaXMuZGF0ZUZvcm1hdCk7XG5cdFx0XHR0aGlzLnNldERhdGVWYWx1ZXMoW3RoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1swXSwgZGF0ZV0pO1xuXHRcdFx0dGhpcy5kb1NlbGVjdCh0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXMpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIG9wZW5pbmcgdGhlIGNhbGVuZGFyIFwicHJvcGVybHlcIiB3aGVuIHRoZSBjYWxlbmRhciBpY29uIGlzIGNsaWNrZWQuXG5cdCAqL1xuXHRvcGVuQ2FsZW5kYXIoZGF0ZXBpY2tlcklucHV0OiBEYXRlUGlja2VySW5wdXQpIHtcblx0XHRpZiAodGhpcy5yYW5nZSkge1xuXHRcdFx0ZGF0ZXBpY2tlcklucHV0LmlucHV0Lm5hdGl2ZUVsZW1lbnQuY2xpY2soKTtcblxuXHRcdFx0Ly8gSWYgdGhlIGZpcnN0IGlucHV0J3MgY2FsZW5kYXIgaWNvbiBpcyBjbGlja2VkIHdoZW4gY2FsZW5kYXIgaXMgaW4gcmFuZ2UgbW9kZSwgdGhlblxuXHRcdFx0Ly8gdGhlIG1vbnRoIGFuZCB5ZWFyIG5lZWRzIHRvIGJlIG1hbnVhbGx5IGNoYW5nZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0ZWQgbW9udGggYW5kXG5cdFx0XHQvLyB5ZWFyIG90aGVyd2lzZSB0aGUgY2FsZW5kYXIgdmlldyB3aWxsIG5vdCBiZSB1cGRhdGVkIHVwb24gb3BlbmluZy5cblx0XHRcdGlmIChkYXRlcGlja2VySW5wdXQgPT09IHRoaXMuaW5wdXQgJiYgdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzWzBdKSB7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRNb250aCA9IHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1swXS5nZXRNb250aCgpO1xuXG5cdFx0XHRcdHRoaXMuZmxhdHBpY2tySW5zdGFuY2UuY3VycmVudFllYXIgPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0dGhpcy5mbGF0cGlja3JJbnN0YW5jZS5jaGFuZ2VNb250aChjdXJyZW50TW9udGgsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gU2luZ2xlLW1vZGUgZmxhdHBpY2tyIGhhbmRsZXMgbW91c2Vkb3duIGJ1dCBub3QgY2xpY2ssIHNvIG5hdGl2ZUVsZW1lbnQuY2xpY2soKSB3b24ndFxuXHRcdFx0Ly8gd29yayB3aGVuIHRoZSBjYWxlbmRhciBpY29uIGlzIGNsaWNrZWQuIEluIHRoaXMgY2FzZSB3ZSBzaW1wbHkgdXNlIGZsYXRwaWNrci5vcGVuKCkuXG5cdFx0XHR0aGlzLmZsYXRwaWNrckluc3RhbmNlLm9wZW4oKTtcblx0XHR9XG5cdH1cblxuXHRwcm90ZWN0ZWQgdXBkYXRlQ2FsZW5kYXJMaXN0ZW5lcnMoKSB7XG5cdFx0Y29uc3QgY2FsZW5kYXJDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmZsYXRwaWNrci1jYWxlbmRhclwiKTtcblx0XHRBcnJheS5mcm9tKGNhbGVuZGFyQ29udGFpbmVyKS5mb3JFYWNoKGNhbGVuZGFyID0+IHtcblx0XHRcdGNhbGVuZGFyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLnByZXZlbnRDYWxlbmRhckNsb3NlKTtcblx0XHRcdGNhbGVuZGFyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLnByZXZlbnRDYWxlbmRhckNsb3NlKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIHRoZSBpbml0aWFsaXphdGlvbiBvZiBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBkYXRlcGlja2VyIGlucHV0IGFuZCByYW5nZSBpbnB1dCBmaWVsZHMuXG5cdCAqL1xuXHRwcm90ZWN0ZWQgYWRkSW5wdXRMaXN0ZW5lcnMoKSB7XG5cdFx0aWYgKCF0aGlzLmlzRmxhdHBpY2tyTG9hZGVkKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBBbGxvd3MgZm9jdXMgdHJhbnNpdGlvbiBmcm9tIHRoZSBkYXRlcGlja2VyIGlucHV0IG9yIHJhbmdlIGlucHV0IGZpZWxkIHRvXG5cdFx0Ly8gZmxhdHBpY2tyIGNhbGVuZGFyIHVzaW5nIGEga2V5Ym9hcmQuXG5cdFx0Y29uc3QgYWRkRm9jdXNDYWxlbmRhckxpc3RlbmVyID0gKGVsZW1lbnQ6IEhUTUxJbnB1dEVsZW1lbnQpID0+IHtcblx0XHRcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG5cdFx0XHRcdGlmIChldmVudC5rZXkgPT09IFwiQXJyb3dEb3duXCIpIHtcblx0XHRcdFx0XHRpZiAoIXRoaXMuZmxhdHBpY2tySW5zdGFuY2UuaXNPcGVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmZsYXRwaWNrckluc3RhbmNlLm9wZW4oKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCBjYWxlbmRhckNvbnRhaW5lciA9IHRoaXMuZmxhdHBpY2tySW5zdGFuY2UuY2FsZW5kYXJDb250YWluZXI7XG5cdFx0XHRcdFx0Y29uc3QgZGF5RWxlbWVudCA9IGNhbGVuZGFyQ29udGFpbmVyICYmIGNhbGVuZGFyQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuZmxhdHBpY2tyLWRheVt0YWJpbmRleF1cIik7XG5cblx0XHRcdFx0XHRpZiAoZGF5RWxlbWVudCkge1xuXHRcdFx0XHRcdFx0ZGF5RWxlbWVudC5mb2N1cygpO1xuXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgdXNlciBtYW51YWxseSBpbnB1dHMgYSB2YWx1ZSBpbnRvIHRoZSBkYXRlIGZpZWxkIGFuZCBwcmVzc2VzIGFycm93IGRvd24sXG5cdFx0XHRcdFx0XHQvLyBkYXRlcGlja2VyIGlucHV0IG9uY2hhbmdlIHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW4gZm9jdXMgaXMgcmVtb3ZlZCBmcm9tIGl0IGFuZFxuXHRcdFx0XHRcdFx0Ly8gYGZsYXRwaWNrckluc3RhbmNlLnNldERhdGVgIGFuZCBgZmxhdHBpY2tySW5zdGFuY2UuY2hhbmdlTW9udGhgIHdpbGwgYmUgaW52b2tlZFxuXHRcdFx0XHRcdFx0Ly8gd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGNoYW5nZSBmb2N1cyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkb2N1bWVudC5cblx0XHRcdFx0XHRcdGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBkYXlFbGVtZW50ICYmIHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlRWxlbSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZUVsZW0uZm9jdXMoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHRpZiAodGhpcy5pbnB1dCAmJiB0aGlzLmlucHV0LmlucHV0KSB7XG5cdFx0XHRhZGRGb2N1c0NhbGVuZGFyTGlzdGVuZXIodGhpcy5pbnB1dC5pbnB1dC5uYXRpdmVFbGVtZW50KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5yYW5nZUlucHV0ICYmIHRoaXMucmFuZ2VJbnB1dC5pbnB1dCkge1xuXHRcdFx0YWRkRm9jdXNDYWxlbmRhckxpc3RlbmVyKHRoaXMucmFuZ2VJbnB1dC5pbnB1dC5uYXRpdmVFbGVtZW50KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVzZXRzIHRoZSBmbGF0cGlja3IgaW5zdGFuY2Ugd2hpbGUga2VlcGluZyB0aGUgZGF0ZSB2YWx1ZXMgKG9yIHVwZGF0aW5nIHRoZW0gaWYgbmV3RGF0ZXMgaXMgcHJvdmlkZWQpXG5cdCAqXG5cdCAqIFVzZWQgdG8gcGljayB1cCBpbnB1dCBjaGFuZ2VzIG9yIGxvY2FsZSBjaGFuZ2VzLlxuXHQgKlxuXHQgKiBAcGFyYW0gbmV3RGF0ZXMgQW4gb3B0aW9uYWwgU2ltcGxlQ2hhbmdlIG9mIGRhdGUgdmFsdWVzXG5cdCAqL1xuXHRwcm90ZWN0ZWQgcmVzZXRGbGF0cGlja3JJbnN0YW5jZShuZXdEYXRlcz86IFNpbXBsZUNoYW5nZSkge1xuXHRcdGlmICh0aGlzLmlzRmxhdHBpY2tyTG9hZGVkKCkpIHtcblx0XHRcdGxldCBkYXRlcyA9IHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlcztcblx0XHRcdGlmIChuZXdEYXRlcyAmJiB0aGlzLmRpZERhdGVWYWx1ZUNoYW5nZShuZXdEYXRlcy5jdXJyZW50VmFsdWUsIG5ld0RhdGVzLnByZXZpb3VzVmFsdWUpKSB7XG5cdFx0XHRcdGRhdGVzID0gbmV3RGF0ZXMuY3VycmVudFZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gb25seSByZXNldCB0aGUgZmxhdHBpY2tyIGluc3RhbmNlIG9uIElucHV0IGNoYW5nZXNcblx0XHRcdC8vIEB0cy1pZ25vcmUgdHMgaXMgdW5oYXBweSB3aXRoIHRoZSBiZWxvdyBjYWxsIHRvIGBmbGF0cGlja3JgXG5cdFx0XHR0aGlzLmZsYXRwaWNrckluc3RhbmNlID0gZmxhdHBpY2tyKGAjJHt0aGlzLmlkfS1pbnB1dGAsIHRoaXMuZmxhdHBpY2tyT3B0aW9ucyk7XG5cdFx0XHR0aGlzLnNldERhdGVWYWx1ZXMoZGF0ZXMpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDYXJib24gdXNlcyBhIG51bWJlciBvZiBzcGVjaWZpYyBjbGFzc25hbWVzIGZvciBwYXJ0cyBvZiB0aGUgZmxhdHBpY2tyIC0gdGhpcyBpZGVtcG90ZW50IG1ldGhvZCBhcHBsaWVzIHRoZW0gaWYgbmVlZGVkLlxuXHQgKi9cblx0cHJvdGVjdGVkIHVwZGF0ZUNsYXNzTmFtZXMoKSB7XG5cdFx0aWYgKCF0aGlzLmVsZW1lbnRSZWYpIHsgcmV0dXJuOyB9XG5cdFx0Ly8gZ2V0IGFsbCB0aGUgcG9zc2libGUgZmxhdHBpY2tycyBpbiB0aGUgZG9jdW1lbnQgLSB3ZSBuZWVkIHRvIGFkZCBjbGFzc2VzIHRvIChwb3RlbnRpYWxseSkgYWxsIG9mIHRoZW1cblx0XHRjb25zdCBjYWxlbmRhckNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuZmxhdHBpY2tyLWNhbGVuZGFyXCIpO1xuXHRcdGNvbnN0IG1vbnRoQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5mbGF0cGlja3ItbW9udGhcIik7XG5cdFx0Y29uc3Qgd2Vla2RheXNDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmZsYXRwaWNrci13ZWVrZGF5c1wiKTtcblx0XHRjb25zdCB3ZWVrZGF5Q29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5mbGF0cGlja3Itd2Vla2RheVwiKTtcblx0XHRjb25zdCBkYXlzQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5mbGF0cGlja3ItZGF5c1wiKTtcblx0XHRjb25zdCBkYXlDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmZsYXRwaWNrci1kYXlcIik7XG5cblx0XHQvLyBhZGQgY2xhc3NlcyB0byBsaXN0cyBvZiBlbGVtZW50c1xuXHRcdGNvbnN0IGFkZENsYXNzSWZOb3RFeGlzdHMgPSAoY2xhc3NuYW1lOiBzdHJpbmcsIGVsZW1lbnRMaXN0OiBOb2RlTGlzdE9mPEVsZW1lbnQ+KSA9PiB7XG5cdFx0XHRBcnJheS5mcm9tKGVsZW1lbnRMaXN0KS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuXHRcdFx0XHRpZiAoIWVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzbmFtZSkpIHtcblx0XHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NuYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdC8vIGFkZCBjbGFzc2VzIChidXQgb25seSBpZiB0aGV5IGRvbid0IGV4aXN0LCBzbWFsbCBwZXJmIHdpbilcblx0XHRhZGRDbGFzc0lmTm90RXhpc3RzKFwiY2RzLS1kYXRlLXBpY2tlcl9fY2FsZW5kYXJcIiwgY2FsZW5kYXJDb250YWluZXIpO1xuXHRcdGFkZENsYXNzSWZOb3RFeGlzdHMoXCJjZHMtLWRhdGUtcGlja2VyX19tb250aFwiLCBtb250aENvbnRhaW5lcik7XG5cdFx0YWRkQ2xhc3NJZk5vdEV4aXN0cyhcImNkcy0tZGF0ZS1waWNrZXJfX3dlZWtkYXlzXCIsIHdlZWtkYXlzQ29udGFpbmVyKTtcblx0XHRhZGRDbGFzc0lmTm90RXhpc3RzKFwiY2RzLS1kYXRlLXBpY2tlcl9fZGF5c1wiLCBkYXlzQ29udGFpbmVyKTtcblxuXHRcdC8vIGFkZCB3ZWVrZGF5IGNsYXNzZXMgYW5kIGZvcm1hdCB0aGUgdGV4dFxuXHRcdEFycmF5LmZyb20od2Vla2RheUNvbnRhaW5lcikuZm9yRWFjaChlbGVtZW50ID0+IHtcblx0XHRcdGVsZW1lbnQuaW5uZXJIVE1MID0gZWxlbWVudC5pbm5lckhUTUwucmVwbGFjZSgvXFxzKy9nLCBcIlwiKTtcblx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImNkcy0tZGF0ZS1waWNrZXJfX3dlZWtkYXlcIik7XG5cdFx0fSk7XG5cblx0XHQvLyBhZGQgZGF5IGNsYXNzZXMgYW5kIHNwZWNpYWwgY2FzZSB0aGUgXCJ0b2RheVwiIGVsZW1lbnQgYmFzZWQgb24gYHRoaXMudmFsdWVgXG5cdFx0QXJyYXkuZnJvbShkYXlDb250YWluZXIpLmZvckVhY2goZWxlbWVudCA9PiB7XG5cdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjZHMtLWRhdGUtcGlja2VyX19kYXlcIik7XG5cdFx0XHRpZiAoIXRoaXMudmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwidG9kYXlcIikgJiYgdGhpcy52YWx1ZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm5vLWJvcmRlclwiKTtcblx0XHRcdH0gZWxzZSBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJ0b2RheVwiKSAmJiB0aGlzLnZhbHVlLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJuby1ib3JkZXJcIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgdXBkYXRlQXR0cmlidXRlcygpIHtcblx0XHRjb25zdCBjYWxlbmRhckNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuZmxhdHBpY2tyLWNhbGVuZGFyXCIpO1xuXHRcdEFycmF5LmZyb20oY2FsZW5kYXJDb250YWluZXIpLmZvckVhY2goY2FsZW5kYXIgPT4ge1xuXHRcdFx0Y2FsZW5kYXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInJlZ2lvblwiKTtcblx0XHRcdGNhbGVuZGFyLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy5hcmlhTGFiZWwpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGdpdmVuIGRhdGUgdmFsdWUgYXJyYXkgdG8gYm90aCB0aGUgZmxhdHBpY2tyIGluc3RhbmNlIGFuZCB0aGUgYGlucHV0YChzKVxuXHQgKiBAcGFyYW0gZGF0ZXMgdGhlIGRhdGUgdmFsdWVzIHRvIGFwcGx5XG5cdCAqL1xuXHRwcm90ZWN0ZWQgc2V0RGF0ZVZhbHVlcyhkYXRlczogKERhdGUgfCBzdHJpbmcpW10pIHtcblx0XHRpZiAodGhpcy5pc0ZsYXRwaWNrckxvYWRlZCgpKSB7XG5cdFx0XHRjb25zdCBzaW5nbGVJbnB1dCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke3RoaXMuaWR9LWlucHV0YCk7XG5cdFx0XHRjb25zdCByYW5nZUlucHV0ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihgIyR7dGhpcy5pZH0tcmFuZ2VJbnB1dGApO1xuXG5cdFx0XHQvLyBgZmxhdHBpY2tySW5zdGFuY2Uuc2V0RGF0ZWAgcmVtb3ZlcyB0aGUgZm9jdXMgb24gdGhlIHNlbGVjdGVkIGRhdGUgZWxlbWVudCBhbmQgd2lsbFxuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBjaGFuZ2UgZm9jdXMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZG9jdW1lbnQuIElmIGEgc2VsZWN0ZWQgZGF0ZSBpc1xuXHRcdFx0Ly8gZm9jdXNlZCBiZWZvcmUgYGZsYXRwaWNrckluc3RhbmNlLnNldERhdGVgIGlzIGludm9rZWQgdGhlbiBpdCBzaG91bGQgcmVtYWluIGZvY3VzZWQuXG5cdFx0XHRsZXQgc2hvdWxkUmVmb2N1c0RhdGVFbGVtZW50ID0gdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVFbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG5cdFx0XHQvLyBzZXQgdGhlIGRhdGUgb24gdGhlIGluc3RhbmNlXG5cdFx0XHR0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNldERhdGUoZGF0ZXMpO1xuXG5cdFx0XHRpZiAoc2hvdWxkUmVmb2N1c0RhdGVFbGVtZW50KSB7XG5cdFx0XHRcdHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlRWxlbS5mb2N1cygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB3ZSBjYW4gZWl0aGVyIHNldCBhIGRhdGUgdmFsdWUgb3IgYW4gZW1wdHkgc3RyaW5nLCBzbyB3ZSBzdGFydCB3aXRoIGFuIGVtcHR5IHN0cmluZ1xuXHRcdFx0bGV0IHNpbmdsZURhdGUgPSBcIlwiO1xuXHRcdFx0Ly8gaWYgZGF0ZSBpcyBhIHN0cmluZywgcGFyc2UgYW5kIGZvcm1hdFxuXHRcdFx0aWYgKHR5cGVvZiB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMF0gPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0c2luZ2xlRGF0ZSA9IHRoaXMuZmxhdHBpY2tySW5zdGFuY2UucGFyc2VEYXRlKHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1swXSwgdGhpcy5kYXRlRm9ybWF0KTtcblx0XHRcdFx0c2luZ2xlRGF0ZSA9IHRoaXMuZmxhdHBpY2tySW5zdGFuY2UuZm9ybWF0RGF0ZShzaW5nbGVEYXRlLCB0aGlzLmRhdGVGb3JtYXQpO1xuXHRcdFx0Ly8gaWYgZGF0ZSBpcyBub3QgYSBzdHJpbmcgd2UgY2FuIGFzc3VtZSBpdCdzIGEgRGF0ZSBhbmQgd2Ugc2hvdWxkIGZvcm1hdFxuXHRcdFx0fSBlbHNlIGlmICghIXRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1swXSkge1xuXHRcdFx0XHRzaW5nbGVEYXRlID0gdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5mb3JtYXREYXRlKHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1swXSwgdGhpcy5kYXRlRm9ybWF0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJhbmdlSW5wdXQpIHtcblx0XHRcdFx0Ly8gd2UgY2FuIGVpdGhlciBzZXQgYSBkYXRlIHZhbHVlIG9yIGFuIGVtcHR5IHN0cmluZywgc28gd2Ugc3RhcnQgd2l0aCBhbiBlbXB0eSBzdHJpbmdcblx0XHRcdFx0bGV0IHJhbmdlRGF0ZSA9IFwiXCI7XG5cdFx0XHRcdC8vIGlmIGRhdGUgaXMgYSBzdHJpbmcsIHBhcnNlIGFuZCBmb3JtYXRcblx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMV0gPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRyYW5nZURhdGUgPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnBhcnNlRGF0ZSh0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMV0udG9TdHJpbmcoKSwgdGhpcy5kYXRlRm9ybWF0KTtcblx0XHRcdFx0XHRyYW5nZURhdGUgPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLmZvcm1hdERhdGUocmFuZ2VEYXRlLCB0aGlzLmRhdGVGb3JtYXQpO1xuXHRcdFx0XHQvLyBpZiBkYXRlIGlzIG5vdCBhIHN0cmluZyB3ZSBjYW4gYXNzdW1lIGl0J3MgYSBEYXRlIGFuZCB3ZSBzaG91bGQgZm9ybWF0XG5cdFx0XHRcdH0gZWxzZSBpZiAoISF0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMV0pIHtcblx0XHRcdFx0XHRyYW5nZURhdGUgPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLmZvcm1hdERhdGUodGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzWzFdLCB0aGlzLmRhdGVGb3JtYXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdC8vIGFwcGx5IHRoZSB2YWx1ZXNcblx0XHRcdFx0XHRyYW5nZUlucHV0LnZhbHVlID0gcmFuZ2VEYXRlO1xuXHRcdFx0XHRcdHNpbmdsZUlucHV0LnZhbHVlID0gc2luZ2xlRGF0ZTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJvdGVjdGVkIHByZXZlbnRDYWxlbmRhckNsb3NlID0gZXZlbnQgPT4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0cHJvdGVjdGVkIGRvU2VsZWN0KHNlbGVjdGVkVmFsdWU6IChEYXRlIHwgc3RyaW5nKVtdKSB7XG5cdFx0Ly8gSW4gcmFuZ2UgbW9kZSwgaWYgYSBkYXRlIGlzIHNlbGVjdGVkIGZyb20gdGhlIGZpcnN0IGNhbGVuZGFyIHRoYXQgaXMgZnJvbSB0aGUgcHJldmlvdXMgbW9udGgsXG5cdFx0Ly8gdGhlIG1vbnRoIHdpbGwgbm90IGJlIHVwZGF0ZWQgb24gdGhlIGNhbGVuZGFyIHVudGlsIHRoZSBjYWxlbmRhciBpcyByZS1vcGVuZWQuXG5cdFx0Ly8gVGhpcyB3aWxsIG1ha2Ugc3VyZSB0aGUgY2FsZW5kYXIgaXMgdXBkYXRlZCB3aXRoIHRoZSBjb3JyZWN0IG1vbnRoLlxuXHRcdGlmICh0aGlzLnJhbmdlICYmIHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1swXSkge1xuXHRcdFx0Y29uc3QgY3VycmVudE1vbnRoID0gdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzWzBdLmdldE1vbnRoKCk7XG5cblx0XHRcdC8vIGBmbGF0cGlja3JJbnN0YW5jZS5jaGFuZ2VNb250aGAgcmVtb3ZlcyB0aGUgZm9jdXMgb24gdGhlIHNlbGVjdGVkIGRhdGUgZWxlbWVudCBhbmQgd2lsbFxuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBjaGFuZ2UgZm9jdXMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZG9jdW1lbnQuIElmIGEgc2VsZWN0ZWQgZGF0ZSBpc1xuXHRcdFx0Ly8gZm9jdXNlZCBiZWZvcmUgYGZsYXRwaWNrckluc3RhbmNlLmNoYW5nZU1vbnRoYCBpcyBpbnZva2VkIHRoZW4gaXQgc2hvdWxkIHJlbWFpbiBmb2N1c2VkLlxuXHRcdFx0bGV0IHNob3VsZFJlZm9jdXNEYXRlRWxlbWVudCA9IHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlRWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuXHRcdFx0dGhpcy5mbGF0cGlja3JJbnN0YW5jZS5jaGFuZ2VNb250aChjdXJyZW50TW9udGgsIGZhbHNlKTtcblxuXHRcdFx0aWYgKHNob3VsZFJlZm9jdXNEYXRlRWxlbWVudCkge1xuXHRcdFx0XHR0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZUVsZW0uZm9jdXMoKTtcblx0XHRcdH1cblxuXHRcdH1cblx0XHR0aGlzLnZhbHVlQ2hhbmdlLmVtaXQoc2VsZWN0ZWRWYWx1ZSk7XG5cdFx0dGhpcy5wcm9wYWdhdGVDaGFuZ2Uoc2VsZWN0ZWRWYWx1ZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgZGlkRGF0ZVZhbHVlQ2hhbmdlKGN1cnJlbnRWYWx1ZSwgcHJldmlvdXNWYWx1ZSkge1xuXHRcdHJldHVybiBjdXJyZW50VmFsdWVbMF0gIT09IHByZXZpb3VzVmFsdWVbMF0gfHwgY3VycmVudFZhbHVlWzFdICE9PSBwcmV2aW91c1ZhbHVlWzFdO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1vcmUgYWR2YW5jZWQgY2hlY2tpbmcgb2YgdGhlIGxvYWRlZCBzdGF0ZSBvZiBmbGF0cGlja3Jcblx0ICovXG5cdHByb3RlY3RlZCBpc0ZsYXRwaWNrckxvYWRlZCgpIHtcblx0XHQvLyBjYXN0IHRoZSBpbnN0YW5jZSB0byBhIGJvb2xlYW4sIGFuZCBzb21lIG1ldGhvZCB0aGF0IGhhcyB0byBleGlzdCBmb3IgdGhlIGxpYnJhcnkgdG8gYmUgbG9hZGVkIGluIHRoaXMgY2FzZSBgc2V0RGF0ZWBcblx0XHRyZXR1cm4gISF0aGlzLmZsYXRwaWNrckluc3RhbmNlICYmICEhdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZXREYXRlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJpZ2h0IGFycm93IEhUTUwgcGFzc2VkIHRvIGZsYXRwaWNrclxuXHQgKi9cblx0cHJvdGVjdGVkIHJpZ2h0QXJyb3dIVE1MKCkge1xuXHRcdHJldHVybiBgXG5cdFx0XHQ8c3ZnIHdpZHRoPVwiMTZweFwiIGhlaWdodD1cIjE2cHhcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCI+XG5cdFx0XHRcdDxwb2x5Z29uIHBvaW50cz1cIjExLDggNiwxMyA1LjMsMTIuMyA5LjYsOCA1LjMsMy43IDYsMyBcIi8+XG5cdFx0XHRcdDxyZWN0IHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHN0eWxlPVwiZmlsbDpub25lXCIgLz5cblx0XHRcdDwvc3ZnPmA7XG5cdH1cblxuXHQvKipcblx0ICogTGVmdCBhcnJvdyBIVE1MIHBhc3NlZCB0byBmbGF0cGlja3Jcblx0ICovXG5cdHByb3RlY3RlZCBsZWZ0QXJyb3dIVE1MKCkge1xuXHRcdHJldHVybiBgXG5cdFx0XHQ8c3ZnIHdpZHRoPVwiMTZweFwiIGhlaWdodD1cIjE2cHhcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCI+XG5cdFx0XHRcdDxwb2x5Z29uIHBvaW50cz1cIjUsOCAxMCwzIDEwLjcsMy43IDYuNCw4IDEwLjcsMTIuMyAxMCwxMyBcIi8+XG5cdFx0XHRcdDxyZWN0IHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHN0eWxlPVwiZmlsbDpub25lXCIgLz5cblx0XHRcdDwvc3ZnPmA7XG5cdH1cbn1cbiJdfQ==