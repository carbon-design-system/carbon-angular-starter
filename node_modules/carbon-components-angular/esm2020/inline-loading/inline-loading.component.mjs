import { Component, Input, Output, EventEmitter, HostBinding } from "@angular/core";
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "carbon-components-angular/icon";
export var InlineLoadingState;
(function (InlineLoadingState) {
    /** It hides the whole component. */
    InlineLoadingState["Hidden"] = "hidden";
    /** It shows the `loadingText` but no loading animation. */
    InlineLoadingState["Inactive"] = "inactive";
    /** It shows the `loadingText` with loading animation. */
    InlineLoadingState["Active"] = "active";
    /** It shows the `successText` with a success state. */
    InlineLoadingState["Finished"] = "finished";
    /** It shows the `errorText` with an error state. */
    InlineLoadingState["Error"] = "error";
})(InlineLoadingState || (InlineLoadingState = {}));
/**
 * [See demo](../../?path=/story/components-inline-loading--basic)
 */
export class InlineLoading {
    constructor() {
        this.InlineLoadingState = InlineLoadingState;
        /**
         * Specify the text description for the loading state.
         */
        this.state = InlineLoadingState.Active;
        /**
         * Provide a delay for the `setTimeout` for success.
         */
        this.successDelay = 1500;
        /**
         * Emits event after the success state is active
         */
        this.onSuccess = new EventEmitter();
        this.loadingClass = true;
    }
    /**
     * set to `false` to stop the loading animation
     */
    get isActive() {
        return this.state === InlineLoadingState.Active;
    }
    set isActive(active) {
        this.state = active ? InlineLoadingState.Active : InlineLoadingState.Inactive;
    }
    /**
     * Returns value `true` if the component is in the success state.
     */
    get success() {
        return this.state === InlineLoadingState.Finished;
    }
    /**
     * Set the component's state to match the parameter and emits onSuccess if it exits.
     */
    set success(success) {
        this.state = success ? InlineLoadingState.Finished : InlineLoadingState.Error;
        if (this.state === InlineLoadingState.Finished) {
            setTimeout(() => {
                this.onSuccess.emit();
            }, this.successDelay);
        }
    }
}
InlineLoading.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: InlineLoading, deps: [], target: i0.ɵɵFactoryTarget.Component });
InlineLoading.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: InlineLoading, selector: "cds-inline-loading, ibm-inline-loading", inputs: { state: "state", loadingText: "loadingText", successText: "successText", successDelay: "successDelay", errorText: "errorText", isActive: "isActive", success: "success" }, outputs: { onSuccess: "onSuccess" }, host: { properties: { "class.cds--inline-loading": "this.loadingClass" } }, ngImport: i0, template: `
		<div *ngIf="state !== InlineLoadingState.Hidden"
			class="cds--inline-loading__animation">
			<div
				*ngIf="state === InlineLoadingState.Inactive || state === InlineLoadingState.Active"
				class="cds--loading cds--loading--small"
				[ngClass]="{
					'cds--loading--stop': state === InlineLoadingState.Inactive
				}">
				<svg class="cds--loading__svg" viewBox="0 0 100 100">
					<circle class="cds--loading__background" cx="50%" cy="50%" r="44" />
					<circle class="cds--loading__stroke" cx="50%" cy="50%" r="44" />
				</svg>
			</div>
			<svg
				*ngIf="state === InlineLoadingState.Finished"
				cdsIcon="checkmark--filled"
				size="16"
				class="cds--inline-loading__checkmark-container">
			</svg>
			<svg
				*ngIf="state === InlineLoadingState.Error"
				cdsIcon="error--filled"
				size="16"
				class="cds--inline-loading--error">
			</svg>
		</div>
		<p
			*ngIf="state === InlineLoadingState.Inactive || state === InlineLoadingState.Active"
			class="cds--inline-loading__text">{{loadingText}}</p>
		<p *ngIf="state === InlineLoadingState.Finished" class="cds--inline-loading__text">{{successText}}</p>
		<p *ngIf="state === InlineLoadingState.Error" class="cds--inline-loading__text">{{errorText}}</p>
	`, isInline: true, dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.IconDirective, selector: "[cdsIcon], [ibmIcon]", inputs: ["ibmIcon", "cdsIcon", "size", "title", "ariaLabel", "ariaLabelledBy", "ariaHidden", "isFocusable"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: InlineLoading, decorators: [{
            type: Component,
            args: [{
                    selector: "cds-inline-loading, ibm-inline-loading",
                    template: `
		<div *ngIf="state !== InlineLoadingState.Hidden"
			class="cds--inline-loading__animation">
			<div
				*ngIf="state === InlineLoadingState.Inactive || state === InlineLoadingState.Active"
				class="cds--loading cds--loading--small"
				[ngClass]="{
					'cds--loading--stop': state === InlineLoadingState.Inactive
				}">
				<svg class="cds--loading__svg" viewBox="0 0 100 100">
					<circle class="cds--loading__background" cx="50%" cy="50%" r="44" />
					<circle class="cds--loading__stroke" cx="50%" cy="50%" r="44" />
				</svg>
			</div>
			<svg
				*ngIf="state === InlineLoadingState.Finished"
				cdsIcon="checkmark--filled"
				size="16"
				class="cds--inline-loading__checkmark-container">
			</svg>
			<svg
				*ngIf="state === InlineLoadingState.Error"
				cdsIcon="error--filled"
				size="16"
				class="cds--inline-loading--error">
			</svg>
		</div>
		<p
			*ngIf="state === InlineLoadingState.Inactive || state === InlineLoadingState.Active"
			class="cds--inline-loading__text">{{loadingText}}</p>
		<p *ngIf="state === InlineLoadingState.Finished" class="cds--inline-loading__text">{{successText}}</p>
		<p *ngIf="state === InlineLoadingState.Error" class="cds--inline-loading__text">{{errorText}}</p>
	`
                }]
        }], propDecorators: { state: [{
                type: Input
            }], loadingText: [{
                type: Input
            }], successText: [{
                type: Input
            }], successDelay: [{
                type: Input
            }], errorText: [{
                type: Input
            }], isActive: [{
                type: Input
            }], success: [{
                type: Input
            }], onSuccess: [{
                type: Output
            }], loadingClass: [{
                type: HostBinding,
                args: ["class.cds--inline-loading"]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5saW5lLWxvYWRpbmcuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2lubGluZS1sb2FkaW5nL2lubGluZS1sb2FkaW5nLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLFdBQVcsRUFDWCxNQUFNLGVBQWUsQ0FBQzs7OztBQUV2QixNQUFNLENBQU4sSUFBWSxrQkFXWDtBQVhELFdBQVksa0JBQWtCO0lBQzdCLG9DQUFvQztJQUNwQyx1Q0FBaUIsQ0FBQTtJQUNqQiwyREFBMkQ7SUFDM0QsMkNBQXFCLENBQUE7SUFDckIseURBQXlEO0lBQ3pELHVDQUFpQixDQUFBO0lBQ2pCLHVEQUF1RDtJQUN2RCwyQ0FBcUIsQ0FBQTtJQUNyQixvREFBb0Q7SUFDcEQscUNBQWUsQ0FBQTtBQUNoQixDQUFDLEVBWFcsa0JBQWtCLEtBQWxCLGtCQUFrQixRQVc3QjtBQUVEOztHQUVHO0FBcUNILE1BQU0sT0FBTyxhQUFhO0lBcEMxQjtRQXFDQyx1QkFBa0IsR0FBRyxrQkFBa0IsQ0FBQztRQUV4Qzs7V0FFRztRQUNNLFVBQUssR0FBZ0Msa0JBQWtCLENBQUMsTUFBTSxDQUFDO1FBU3hFOztXQUVHO1FBQ00saUJBQVksR0FBRyxJQUFJLENBQUM7UUFpQzdCOztXQUVHO1FBQ08sY0FBUyxHQUFzQixJQUFJLFlBQVksRUFBRSxDQUFDO1FBRWxCLGlCQUFZLEdBQUcsSUFBSSxDQUFDO0tBQzlEO0lBbENBOztPQUVHO0lBQ0gsSUFBYSxRQUFRO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLEtBQUssS0FBSyxrQkFBa0IsQ0FBQyxNQUFNLENBQUM7SUFDakQsQ0FBQztJQUNELElBQUksUUFBUSxDQUFDLE1BQWU7UUFDM0IsSUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDO0lBQy9FLENBQUM7SUFFRDs7T0FFRztJQUNILElBQWEsT0FBTztRQUNuQixPQUFPLElBQUksQ0FBQyxLQUFLLEtBQUssa0JBQWtCLENBQUMsUUFBUSxDQUFDO0lBQ25ELENBQUM7SUFDRDs7T0FFRztJQUNILElBQUksT0FBTyxDQUFDLE9BQWdCO1FBQzNCLElBQUksQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQztRQUM5RSxJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssa0JBQWtCLENBQUMsUUFBUSxFQUFFO1lBQy9DLFVBQVUsQ0FBQyxHQUFHLEVBQUU7Z0JBQ2YsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUN2QixDQUFDLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQ3RCO0lBQ0YsQ0FBQzs7MEdBakRXLGFBQWE7OEZBQWIsYUFBYSxtWEFsQ2Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBZ0NUOzJGQUVXLGFBQWE7a0JBcEN6QixTQUFTO21CQUFDO29CQUNWLFFBQVEsRUFBRSx3Q0FBd0M7b0JBQ2xELFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFnQ1Q7aUJBQ0Q7OEJBT1MsS0FBSztzQkFBYixLQUFLO2dCQUlHLFdBQVc7c0JBQW5CLEtBQUs7Z0JBSUcsV0FBVztzQkFBbkIsS0FBSztnQkFJRyxZQUFZO3NCQUFwQixLQUFLO2dCQUlHLFNBQVM7c0JBQWpCLEtBQUs7Z0JBSU8sUUFBUTtzQkFBcEIsS0FBSztnQkFVTyxPQUFPO3NCQUFuQixLQUFLO2dCQWtCSSxTQUFTO3NCQUFsQixNQUFNO2dCQUVtQyxZQUFZO3NCQUFyRCxXQUFXO3VCQUFDLDJCQUEyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0SW5wdXQsXG5cdE91dHB1dCxcblx0RXZlbnRFbWl0dGVyLFxuXHRIb3N0QmluZGluZ1xufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuXG5leHBvcnQgZW51bSBJbmxpbmVMb2FkaW5nU3RhdGUge1xuXHQvKiogSXQgaGlkZXMgdGhlIHdob2xlIGNvbXBvbmVudC4gKi9cblx0SGlkZGVuID0gXCJoaWRkZW5cIixcblx0LyoqIEl0IHNob3dzIHRoZSBgbG9hZGluZ1RleHRgIGJ1dCBubyBsb2FkaW5nIGFuaW1hdGlvbi4gKi9cblx0SW5hY3RpdmUgPSBcImluYWN0aXZlXCIsXG5cdC8qKiBJdCBzaG93cyB0aGUgYGxvYWRpbmdUZXh0YCB3aXRoIGxvYWRpbmcgYW5pbWF0aW9uLiAqL1xuXHRBY3RpdmUgPSBcImFjdGl2ZVwiLFxuXHQvKiogSXQgc2hvd3MgdGhlIGBzdWNjZXNzVGV4dGAgd2l0aCBhIHN1Y2Nlc3Mgc3RhdGUuICovXG5cdEZpbmlzaGVkID0gXCJmaW5pc2hlZFwiLFxuXHQvKiogSXQgc2hvd3MgdGhlIGBlcnJvclRleHRgIHdpdGggYW4gZXJyb3Igc3RhdGUuICovXG5cdEVycm9yID0gXCJlcnJvclwiXG59XG5cbi8qKlxuICogW1NlZSBkZW1vXSguLi8uLi8/cGF0aD0vc3RvcnkvY29tcG9uZW50cy1pbmxpbmUtbG9hZGluZy0tYmFzaWMpXG4gKi9cbkBDb21wb25lbnQoe1xuXHRzZWxlY3RvcjogXCJjZHMtaW5saW5lLWxvYWRpbmcsIGlibS1pbmxpbmUtbG9hZGluZ1wiLFxuXHR0ZW1wbGF0ZTogYFxuXHRcdDxkaXYgKm5nSWY9XCJzdGF0ZSAhPT0gSW5saW5lTG9hZGluZ1N0YXRlLkhpZGRlblwiXG5cdFx0XHRjbGFzcz1cImNkcy0taW5saW5lLWxvYWRpbmdfX2FuaW1hdGlvblwiPlxuXHRcdFx0PGRpdlxuXHRcdFx0XHQqbmdJZj1cInN0YXRlID09PSBJbmxpbmVMb2FkaW5nU3RhdGUuSW5hY3RpdmUgfHwgc3RhdGUgPT09IElubGluZUxvYWRpbmdTdGF0ZS5BY3RpdmVcIlxuXHRcdFx0XHRjbGFzcz1cImNkcy0tbG9hZGluZyBjZHMtLWxvYWRpbmctLXNtYWxsXCJcblx0XHRcdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0XHRcdCdjZHMtLWxvYWRpbmctLXN0b3AnOiBzdGF0ZSA9PT0gSW5saW5lTG9hZGluZ1N0YXRlLkluYWN0aXZlXG5cdFx0XHRcdH1cIj5cblx0XHRcdFx0PHN2ZyBjbGFzcz1cImNkcy0tbG9hZGluZ19fc3ZnXCIgdmlld0JveD1cIjAgMCAxMDAgMTAwXCI+XG5cdFx0XHRcdFx0PGNpcmNsZSBjbGFzcz1cImNkcy0tbG9hZGluZ19fYmFja2dyb3VuZFwiIGN4PVwiNTAlXCIgY3k9XCI1MCVcIiByPVwiNDRcIiAvPlxuXHRcdFx0XHRcdDxjaXJjbGUgY2xhc3M9XCJjZHMtLWxvYWRpbmdfX3N0cm9rZVwiIGN4PVwiNTAlXCIgY3k9XCI1MCVcIiByPVwiNDRcIiAvPlxuXHRcdFx0XHQ8L3N2Zz5cblx0XHRcdDwvZGl2PlxuXHRcdFx0PHN2Z1xuXHRcdFx0XHQqbmdJZj1cInN0YXRlID09PSBJbmxpbmVMb2FkaW5nU3RhdGUuRmluaXNoZWRcIlxuXHRcdFx0XHRjZHNJY29uPVwiY2hlY2ttYXJrLS1maWxsZWRcIlxuXHRcdFx0XHRzaXplPVwiMTZcIlxuXHRcdFx0XHRjbGFzcz1cImNkcy0taW5saW5lLWxvYWRpbmdfX2NoZWNrbWFyay1jb250YWluZXJcIj5cblx0XHRcdDwvc3ZnPlxuXHRcdFx0PHN2Z1xuXHRcdFx0XHQqbmdJZj1cInN0YXRlID09PSBJbmxpbmVMb2FkaW5nU3RhdGUuRXJyb3JcIlxuXHRcdFx0XHRjZHNJY29uPVwiZXJyb3ItLWZpbGxlZFwiXG5cdFx0XHRcdHNpemU9XCIxNlwiXG5cdFx0XHRcdGNsYXNzPVwiY2RzLS1pbmxpbmUtbG9hZGluZy0tZXJyb3JcIj5cblx0XHRcdDwvc3ZnPlxuXHRcdDwvZGl2PlxuXHRcdDxwXG5cdFx0XHQqbmdJZj1cInN0YXRlID09PSBJbmxpbmVMb2FkaW5nU3RhdGUuSW5hY3RpdmUgfHwgc3RhdGUgPT09IElubGluZUxvYWRpbmdTdGF0ZS5BY3RpdmVcIlxuXHRcdFx0Y2xhc3M9XCJjZHMtLWlubGluZS1sb2FkaW5nX190ZXh0XCI+e3tsb2FkaW5nVGV4dH19PC9wPlxuXHRcdDxwICpuZ0lmPVwic3RhdGUgPT09IElubGluZUxvYWRpbmdTdGF0ZS5GaW5pc2hlZFwiIGNsYXNzPVwiY2RzLS1pbmxpbmUtbG9hZGluZ19fdGV4dFwiPnt7c3VjY2Vzc1RleHR9fTwvcD5cblx0XHQ8cCAqbmdJZj1cInN0YXRlID09PSBJbmxpbmVMb2FkaW5nU3RhdGUuRXJyb3JcIiBjbGFzcz1cImNkcy0taW5saW5lLWxvYWRpbmdfX3RleHRcIj57e2Vycm9yVGV4dH19PC9wPlxuXHRgXG59KVxuZXhwb3J0IGNsYXNzIElubGluZUxvYWRpbmcge1xuXHRJbmxpbmVMb2FkaW5nU3RhdGUgPSBJbmxpbmVMb2FkaW5nU3RhdGU7XG5cblx0LyoqXG5cdCAqIFNwZWNpZnkgdGhlIHRleHQgZGVzY3JpcHRpb24gZm9yIHRoZSBsb2FkaW5nIHN0YXRlLlxuXHQgKi9cblx0QElucHV0KCkgc3RhdGU6IElubGluZUxvYWRpbmdTdGF0ZSB8IHN0cmluZyA9IElubGluZUxvYWRpbmdTdGF0ZS5BY3RpdmU7XG5cdC8qKlxuXHQgKiBTcGVjaWZ5IHRoZSB0ZXh0IGRlc2NyaXB0aW9uIGZvciB0aGUgbG9hZGluZyBzdGF0ZS5cblx0ICovXG5cdEBJbnB1dCgpIGxvYWRpbmdUZXh0OiBzdHJpbmc7XG5cdC8qKlxuXHQgKiBTcGVjaWZ5IHRoZSB0ZXh0IGRlc2NyaXB0aW9uIGZvciB0aGUgc3VjY2VzcyBzdGF0ZS5cblx0ICovXG5cdEBJbnB1dCgpIHN1Y2Nlc3NUZXh0OiBzdHJpbmc7XG5cdC8qKlxuXHQgKiBQcm92aWRlIGEgZGVsYXkgZm9yIHRoZSBgc2V0VGltZW91dGAgZm9yIHN1Y2Nlc3MuXG5cdCAqL1xuXHRASW5wdXQoKSBzdWNjZXNzRGVsYXkgPSAxNTAwO1xuXHQvKipcblx0ICogU3BlY2lmeSB0aGUgdGV4dCBkZXNjcmlwdGlvbiBmb3IgdGhlIGVycm9yIHN0YXRlLlxuXHQgKi9cblx0QElucHV0KCkgZXJyb3JUZXh0OiBzdHJpbmc7XG5cdC8qKlxuXHQgKiBzZXQgdG8gYGZhbHNlYCB0byBzdG9wIHRoZSBsb2FkaW5nIGFuaW1hdGlvblxuXHQgKi9cblx0QElucHV0KCkgZ2V0IGlzQWN0aXZlKCkge1xuXHRcdHJldHVybiB0aGlzLnN0YXRlID09PSBJbmxpbmVMb2FkaW5nU3RhdGUuQWN0aXZlO1xuXHR9XG5cdHNldCBpc0FjdGl2ZShhY3RpdmU6IGJvb2xlYW4pIHtcblx0XHR0aGlzLnN0YXRlID0gYWN0aXZlID8gSW5saW5lTG9hZGluZ1N0YXRlLkFjdGl2ZSA6IElubGluZUxvYWRpbmdTdGF0ZS5JbmFjdGl2ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHZhbHVlIGB0cnVlYCBpZiB0aGUgY29tcG9uZW50IGlzIGluIHRoZSBzdWNjZXNzIHN0YXRlLlxuXHQgKi9cblx0QElucHV0KCkgZ2V0IHN1Y2Nlc3MoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RhdGUgPT09IElubGluZUxvYWRpbmdTdGF0ZS5GaW5pc2hlZDtcblx0fVxuXHQvKipcblx0ICogU2V0IHRoZSBjb21wb25lbnQncyBzdGF0ZSB0byBtYXRjaCB0aGUgcGFyYW1ldGVyIGFuZCBlbWl0cyBvblN1Y2Nlc3MgaWYgaXQgZXhpdHMuXG5cdCAqL1xuXHRzZXQgc3VjY2VzcyhzdWNjZXNzOiBib29sZWFuKSB7XG5cdFx0dGhpcy5zdGF0ZSA9IHN1Y2Nlc3MgPyBJbmxpbmVMb2FkaW5nU3RhdGUuRmluaXNoZWQgOiBJbmxpbmVMb2FkaW5nU3RhdGUuRXJyb3I7XG5cdFx0aWYgKHRoaXMuc3RhdGUgPT09IElubGluZUxvYWRpbmdTdGF0ZS5GaW5pc2hlZCkge1xuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdHRoaXMub25TdWNjZXNzLmVtaXQoKTtcblx0XHRcdH0sIHRoaXMuc3VjY2Vzc0RlbGF5KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRW1pdHMgZXZlbnQgYWZ0ZXIgdGhlIHN1Y2Nlc3Mgc3RhdGUgaXMgYWN0aXZlXG5cdCAqL1xuXHRAT3V0cHV0KCkgb25TdWNjZXNzOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy5jZHMtLWlubGluZS1sb2FkaW5nXCIpIGxvYWRpbmdDbGFzcyA9IHRydWU7XG59XG4iXX0=