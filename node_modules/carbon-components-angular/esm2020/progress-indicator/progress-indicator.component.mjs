import { Component, Input, Output, EventEmitter } from "@angular/core";
import * as i0 from "@angular/core";
import * as i1 from "carbon-components-angular/i18n";
import * as i2 from "@angular/common";
import * as i3 from "carbon-components-angular/icon";
/**
 * [See demo](../../?path=/story/components-progress-indicator--basic)
 */
export class ProgressIndicator {
    constructor(i18n) {
        this.i18n = i18n;
        this.stepSelected = new EventEmitter();
        this.translations = this.i18n.get().PROGRESS_INDICATOR;
        this.orientation = "horizontal";
        this.skeleton = false;
        this.spacing = "default";
        // Get icon names based for each status
        this.statusIcons = {
            current: "incomplete",
            complete: "checkmark--outline",
            invalid: "warning",
            incomplete: "circle-dash"
        };
    }
    get current() {
        return this._current;
    }
    set current(current) {
        this._current = current;
        this.setProgressIndicatorStates();
    }
    static skeletonSteps(stepCount) {
        const steps = [];
        for (let i = 0; i < stepCount; i++) {
            steps.push({ complete: false });
        }
        return steps;
    }
    /**
     * Executes click function if `onClick` exists for step
     * `Current` step functions will not be executed
     * @param index number
     */
    onClick(index) {
        if (index !== this.current && typeof this.steps[index].onClick === "function") {
            this.steps[index].onClick();
        }
        this.stepSelected.emit({ step: this.steps[index], index });
    }
    /**
     * Gets current state based on weight of the state
     * Weight of state goes from error, incomplete, current, and complete
     *
     * This function is used to determine which icon & translation string to display
     * @param index number
     * @returns string
     */
    getCurrentState(index) {
        if (index === this.current) {
            return "current";
        }
        else if (this.steps[index].invalid) {
            return "invalid";
        }
        else if (this.steps[index].complete) {
            return "complete";
        }
        return "incomplete";
    }
    setProgressIndicatorStates() {
        if (this.steps === undefined) {
            return;
        }
        // Set all preceding steps to `complete` & following to `incomplete`
        this.steps.forEach((step, index) => {
            if (index < this.current) {
                step.complete = true;
            }
            else {
                step.complete = false;
            }
        });
    }
}
ProgressIndicator.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ProgressIndicator, deps: [{ token: i1.I18n }], target: i0.ɵɵFactoryTarget.Component });
ProgressIndicator.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: ProgressIndicator, selector: "cds-progress-indicator, ibm-progress-indicator", inputs: { current: "current", steps: "steps", translations: "translations", orientation: "orientation", skeleton: "skeleton", spacing: "spacing" }, outputs: { stepSelected: "stepSelected" }, ngImport: i0, template: `
	<ul
		data-progress
		data-progress-current
		class="cds--progress"
		[ngClass]="{
			'cds--skeleton': skeleton,
			'cds--progress--vertical': (orientation === 'vertical'),
			'cds--progress--space-equal': spacing === 'equal' && orientation !== 'vertical'
		}">
		<li
			class="cds--progress-step"
			*ngFor="let step of steps; let i = index"
			[ngClass]="{
				'cds--progress-step--disabled' : step.disabled,
				'cds--progress-step--complete' : step.complete,
				'cds--progress-step--incomplete' : !step.complete && i !== current,
				'cds--progress-step--current': i === current
			}">
			<button
				type="button"
				class="cds--progress-step-button"
				[ngClass]="{
					'cds--progress-step-button--unclickable': !step.onClick || current === i
				}"
				[disabled]="step.disabled"
				[attr.aria-disabled]="step.disabled"
				[tabindex]="(current !== i && step.onClick && !step.disabled) ? 0 : -1"
				[title]="step.label"
				(click)="onClick(i)">
				<span class="cds--assistive-text">
					{{this.translations[getCurrentState(i)?.toUpperCase()]}}
				</span>
				<svg
					[cdsIcon]="statusIcons[getCurrentState(i)]"
					size="16"
					[ngClass]="{
						'cds--progress__warning': step.invalid && i !== current
					}">
					<title *ngIf="step.description">{{step.description}}</title>
				</svg>
				<div class="cds--progress-text">
					<p class="cds--progress-label">{{step.label}}</p>
					<p *ngIf="step.secondaryLabel" class="cds--progress-optional">{{step.secondaryLabel}}</p>
				</div>
				<span class="cds--progress-line"></span>
			</button>
		</li>
	</ul>
	`, isInline: true, dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.IconDirective, selector: "[cdsIcon], [ibmIcon]", inputs: ["ibmIcon", "cdsIcon", "size", "title", "ariaLabel", "ariaLabelledBy", "ariaHidden", "isFocusable"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ProgressIndicator, decorators: [{
            type: Component,
            args: [{
                    selector: "cds-progress-indicator, ibm-progress-indicator",
                    template: `
	<ul
		data-progress
		data-progress-current
		class="cds--progress"
		[ngClass]="{
			'cds--skeleton': skeleton,
			'cds--progress--vertical': (orientation === 'vertical'),
			'cds--progress--space-equal': spacing === 'equal' && orientation !== 'vertical'
		}">
		<li
			class="cds--progress-step"
			*ngFor="let step of steps; let i = index"
			[ngClass]="{
				'cds--progress-step--disabled' : step.disabled,
				'cds--progress-step--complete' : step.complete,
				'cds--progress-step--incomplete' : !step.complete && i !== current,
				'cds--progress-step--current': i === current
			}">
			<button
				type="button"
				class="cds--progress-step-button"
				[ngClass]="{
					'cds--progress-step-button--unclickable': !step.onClick || current === i
				}"
				[disabled]="step.disabled"
				[attr.aria-disabled]="step.disabled"
				[tabindex]="(current !== i && step.onClick && !step.disabled) ? 0 : -1"
				[title]="step.label"
				(click)="onClick(i)">
				<span class="cds--assistive-text">
					{{this.translations[getCurrentState(i)?.toUpperCase()]}}
				</span>
				<svg
					[cdsIcon]="statusIcons[getCurrentState(i)]"
					size="16"
					[ngClass]="{
						'cds--progress__warning': step.invalid && i !== current
					}">
					<title *ngIf="step.description">{{step.description}}</title>
				</svg>
				<div class="cds--progress-text">
					<p class="cds--progress-label">{{step.label}}</p>
					<p *ngIf="step.secondaryLabel" class="cds--progress-optional">{{step.secondaryLabel}}</p>
				</div>
				<span class="cds--progress-line"></span>
			</button>
		</li>
	</ul>
	`
                }]
        }], ctorParameters: function () { return [{ type: i1.I18n }]; }, propDecorators: { current: [{
                type: Input
            }], steps: [{
                type: Input
            }], stepSelected: [{
                type: Output
            }], translations: [{
                type: Input
            }], orientation: [{
                type: Input
            }], skeleton: [{
                type: Input
            }], spacing: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3MtaW5kaWNhdG9yLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wcm9ncmVzcy1pbmRpY2F0b3IvcHJvZ3Jlc3MtaW5kaWNhdG9yLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLE1BQU0sZUFBZSxDQUFDOzs7OztBQUl2Qjs7R0FFRztBQXNESCxNQUFNLE9BQU8saUJBQWlCO0lBbUM3QixZQUFzQixJQUFVO1FBQVYsU0FBSSxHQUFKLElBQUksQ0FBTTtRQWpCdEIsaUJBQVksR0FBRyxJQUFJLFlBQVksRUFBaUMsQ0FBQztRQUVsRSxpQkFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUM7UUFDbEQsZ0JBQVcsR0FBOEIsWUFBWSxDQUFDO1FBQ3RELGFBQVEsR0FBRyxLQUFLLENBQUM7UUFDakIsWUFBTyxHQUF3QixTQUFTLENBQUM7UUFFbEQsdUNBQXVDO1FBQzlCLGdCQUFXLEdBQUc7WUFDdEIsT0FBTyxFQUFFLFlBQVk7WUFDckIsUUFBUSxFQUFFLG9CQUFvQjtZQUM5QixPQUFPLEVBQUUsU0FBUztZQUNsQixVQUFVLEVBQUUsYUFBYTtTQUN6QixDQUFDO0lBSWtDLENBQUM7SUFsQ3JDLElBQWEsT0FBTztRQUNuQixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDdEIsQ0FBQztJQUNELElBQUksT0FBTyxDQUFDLE9BQWU7UUFDMUIsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7UUFDeEIsSUFBSSxDQUFDLDBCQUEwQixFQUFFLENBQUM7SUFDbkMsQ0FBQztJQUNELE1BQU0sQ0FBQyxhQUFhLENBQUMsU0FBaUI7UUFDckMsTUFBTSxLQUFLLEdBQUcsRUFBRSxDQUFDO1FBQ2pCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDbkMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQ2hDO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZCxDQUFDO0lBc0JEOzs7O09BSUc7SUFDSCxPQUFPLENBQUMsS0FBYTtRQUNwQixJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsT0FBTyxJQUFJLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLEtBQUssVUFBVSxFQUFFO1lBQzlFLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7U0FDNUI7UUFDRCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxlQUFlLENBQUMsS0FBYTtRQUM1QixJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQzNCLE9BQU8sU0FBUyxDQUFDO1NBQ2pCO2FBQU0sSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sRUFBRTtZQUNyQyxPQUFPLFNBQVMsQ0FBQztTQUNqQjthQUFNLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUU7WUFDdEMsT0FBTyxVQUFVLENBQUM7U0FDbEI7UUFFRCxPQUFPLFlBQVksQ0FBQztJQUNyQixDQUFDO0lBRU8sMEJBQTBCO1FBQ2pDLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxTQUFTLEVBQUU7WUFDN0IsT0FBTztTQUNQO1FBRUQsb0VBQW9FO1FBQ3BFLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBVSxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQ3hDLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO2FBQ3JCO2lCQUFNO2dCQUNOLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO2FBQ3RCO1FBQ0YsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDOzs4R0FsRlcsaUJBQWlCO2tHQUFqQixpQkFBaUIscVJBbkRuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQWlEVDsyRkFFVyxpQkFBaUI7a0JBckQ3QixTQUFTO21CQUFDO29CQUNWLFFBQVEsRUFBRSxnREFBZ0Q7b0JBQzFELFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQWlEVDtpQkFDRDsyRkFFYSxPQUFPO3NCQUFuQixLQUFLO2dCQWdCRyxLQUFLO3NCQUFiLEtBQUs7Z0JBQ0ksWUFBWTtzQkFBckIsTUFBTTtnQkFFRSxZQUFZO3NCQUFwQixLQUFLO2dCQUNHLFdBQVc7c0JBQW5CLEtBQUs7Z0JBQ0csUUFBUTtzQkFBaEIsS0FBSztnQkFDRyxPQUFPO3NCQUFmLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRDb21wb25lbnQsXG5cdElucHV0LFxuXHRPdXRwdXQsXG5cdEV2ZW50RW1pdHRlclxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgSTE4biB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2kxOG5cIjtcbmltcG9ydCB7IFN0ZXAgfSBmcm9tIFwiLi9wcm9ncmVzcy1pbmRpY2F0b3Itc3RlcC5pbnRlcmZhY2VcIjtcblxuLyoqXG4gKiBbU2VlIGRlbW9dKC4uLy4uLz9wYXRoPS9zdG9yeS9jb21wb25lbnRzLXByb2dyZXNzLWluZGljYXRvci0tYmFzaWMpXG4gKi9cbkBDb21wb25lbnQoe1xuXHRzZWxlY3RvcjogXCJjZHMtcHJvZ3Jlc3MtaW5kaWNhdG9yLCBpYm0tcHJvZ3Jlc3MtaW5kaWNhdG9yXCIsXG5cdHRlbXBsYXRlOiBgXG5cdDx1bFxuXHRcdGRhdGEtcHJvZ3Jlc3Ncblx0XHRkYXRhLXByb2dyZXNzLWN1cnJlbnRcblx0XHRjbGFzcz1cImNkcy0tcHJvZ3Jlc3NcIlxuXHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdCdjZHMtLXNrZWxldG9uJzogc2tlbGV0b24sXG5cdFx0XHQnY2RzLS1wcm9ncmVzcy0tdmVydGljYWwnOiAob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpLFxuXHRcdFx0J2Nkcy0tcHJvZ3Jlc3MtLXNwYWNlLWVxdWFsJzogc3BhY2luZyA9PT0gJ2VxdWFsJyAmJiBvcmllbnRhdGlvbiAhPT0gJ3ZlcnRpY2FsJ1xuXHRcdH1cIj5cblx0XHQ8bGlcblx0XHRcdGNsYXNzPVwiY2RzLS1wcm9ncmVzcy1zdGVwXCJcblx0XHRcdCpuZ0Zvcj1cImxldCBzdGVwIG9mIHN0ZXBzOyBsZXQgaSA9IGluZGV4XCJcblx0XHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdFx0J2Nkcy0tcHJvZ3Jlc3Mtc3RlcC0tZGlzYWJsZWQnIDogc3RlcC5kaXNhYmxlZCxcblx0XHRcdFx0J2Nkcy0tcHJvZ3Jlc3Mtc3RlcC0tY29tcGxldGUnIDogc3RlcC5jb21wbGV0ZSxcblx0XHRcdFx0J2Nkcy0tcHJvZ3Jlc3Mtc3RlcC0taW5jb21wbGV0ZScgOiAhc3RlcC5jb21wbGV0ZSAmJiBpICE9PSBjdXJyZW50LFxuXHRcdFx0XHQnY2RzLS1wcm9ncmVzcy1zdGVwLS1jdXJyZW50JzogaSA9PT0gY3VycmVudFxuXHRcdFx0fVwiPlxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHR0eXBlPVwiYnV0dG9uXCJcblx0XHRcdFx0Y2xhc3M9XCJjZHMtLXByb2dyZXNzLXN0ZXAtYnV0dG9uXCJcblx0XHRcdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0XHRcdCdjZHMtLXByb2dyZXNzLXN0ZXAtYnV0dG9uLS11bmNsaWNrYWJsZSc6ICFzdGVwLm9uQ2xpY2sgfHwgY3VycmVudCA9PT0gaVxuXHRcdFx0XHR9XCJcblx0XHRcdFx0W2Rpc2FibGVkXT1cInN0ZXAuZGlzYWJsZWRcIlxuXHRcdFx0XHRbYXR0ci5hcmlhLWRpc2FibGVkXT1cInN0ZXAuZGlzYWJsZWRcIlxuXHRcdFx0XHRbdGFiaW5kZXhdPVwiKGN1cnJlbnQgIT09IGkgJiYgc3RlcC5vbkNsaWNrICYmICFzdGVwLmRpc2FibGVkKSA/IDAgOiAtMVwiXG5cdFx0XHRcdFt0aXRsZV09XCJzdGVwLmxhYmVsXCJcblx0XHRcdFx0KGNsaWNrKT1cIm9uQ2xpY2soaSlcIj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJjZHMtLWFzc2lzdGl2ZS10ZXh0XCI+XG5cdFx0XHRcdFx0e3t0aGlzLnRyYW5zbGF0aW9uc1tnZXRDdXJyZW50U3RhdGUoaSk/LnRvVXBwZXJDYXNlKCldfX1cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8c3ZnXG5cdFx0XHRcdFx0W2Nkc0ljb25dPVwic3RhdHVzSWNvbnNbZ2V0Q3VycmVudFN0YXRlKGkpXVwiXG5cdFx0XHRcdFx0c2l6ZT1cIjE2XCJcblx0XHRcdFx0XHRbbmdDbGFzc109XCJ7XG5cdFx0XHRcdFx0XHQnY2RzLS1wcm9ncmVzc19fd2FybmluZyc6IHN0ZXAuaW52YWxpZCAmJiBpICE9PSBjdXJyZW50XG5cdFx0XHRcdFx0fVwiPlxuXHRcdFx0XHRcdDx0aXRsZSAqbmdJZj1cInN0ZXAuZGVzY3JpcHRpb25cIj57e3N0ZXAuZGVzY3JpcHRpb259fTwvdGl0bGU+XG5cdFx0XHRcdDwvc3ZnPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY2RzLS1wcm9ncmVzcy10ZXh0XCI+XG5cdFx0XHRcdFx0PHAgY2xhc3M9XCJjZHMtLXByb2dyZXNzLWxhYmVsXCI+e3tzdGVwLmxhYmVsfX08L3A+XG5cdFx0XHRcdFx0PHAgKm5nSWY9XCJzdGVwLnNlY29uZGFyeUxhYmVsXCIgY2xhc3M9XCJjZHMtLXByb2dyZXNzLW9wdGlvbmFsXCI+e3tzdGVwLnNlY29uZGFyeUxhYmVsfX08L3A+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImNkcy0tcHJvZ3Jlc3MtbGluZVwiPjwvc3Bhbj5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdDwvbGk+XG5cdDwvdWw+XG5cdGBcbn0pXG5leHBvcnQgY2xhc3MgUHJvZ3Jlc3NJbmRpY2F0b3Ige1xuXHRASW5wdXQoKSBnZXQgY3VycmVudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY3VycmVudDtcblx0fVxuXHRzZXQgY3VycmVudChjdXJyZW50OiBudW1iZXIpIHtcblx0XHR0aGlzLl9jdXJyZW50ID0gY3VycmVudDtcblx0XHR0aGlzLnNldFByb2dyZXNzSW5kaWNhdG9yU3RhdGVzKCk7XG5cdH1cblx0c3RhdGljIHNrZWxldG9uU3RlcHMoc3RlcENvdW50OiBudW1iZXIpIHtcblx0XHRjb25zdCBzdGVwcyA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc3RlcENvdW50OyBpKyspIHtcblx0XHRcdHN0ZXBzLnB1c2goeyBjb21wbGV0ZTogZmFsc2UgfSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0ZXBzO1xuXHR9XG5cblx0QElucHV0KCkgc3RlcHM6IEFycmF5PFN0ZXA+O1xuXHRAT3V0cHV0KCkgc3RlcFNlbGVjdGVkID0gbmV3IEV2ZW50RW1pdHRlcjx7IHN0ZXA6IFN0ZXAsIGluZGV4OiBudW1iZXIgfT4oKTtcblxuXHRASW5wdXQoKSB0cmFuc2xhdGlvbnMgPSB0aGlzLmkxOG4uZ2V0KCkuUFJPR1JFU1NfSU5ESUNBVE9SO1xuXHRASW5wdXQoKSBvcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCIgPSBcImhvcml6b250YWxcIjtcblx0QElucHV0KCkgc2tlbGV0b24gPSBmYWxzZTtcblx0QElucHV0KCkgc3BhY2luZzogXCJkZWZhdWx0XCIgfCBcImVxdWFsXCIgPSBcImRlZmF1bHRcIjtcblxuXHQvLyBHZXQgaWNvbiBuYW1lcyBiYXNlZCBmb3IgZWFjaCBzdGF0dXNcblx0cmVhZG9ubHkgc3RhdHVzSWNvbnMgPSB7XG5cdFx0Y3VycmVudDogXCJpbmNvbXBsZXRlXCIsXG5cdFx0Y29tcGxldGU6IFwiY2hlY2ttYXJrLS1vdXRsaW5lXCIsXG5cdFx0aW52YWxpZDogXCJ3YXJuaW5nXCIsXG5cdFx0aW5jb21wbGV0ZTogXCJjaXJjbGUtZGFzaFwiXG5cdH07XG5cblx0cHJpdmF0ZSBfY3VycmVudDogbnVtYmVyO1xuXG5cdGNvbnN0cnVjdG9yKHByb3RlY3RlZCBpMThuOiBJMThuKSB7IH1cblxuXHQvKipcblx0ICogRXhlY3V0ZXMgY2xpY2sgZnVuY3Rpb24gaWYgYG9uQ2xpY2tgIGV4aXN0cyBmb3Igc3RlcFxuXHQgKiBgQ3VycmVudGAgc3RlcCBmdW5jdGlvbnMgd2lsbCBub3QgYmUgZXhlY3V0ZWRcblx0ICogQHBhcmFtIGluZGV4IG51bWJlclxuXHQgKi9cblx0b25DbGljayhpbmRleDogbnVtYmVyKSB7XG5cdFx0aWYgKGluZGV4ICE9PSB0aGlzLmN1cnJlbnQgJiYgdHlwZW9mIHRoaXMuc3RlcHNbaW5kZXhdLm9uQ2xpY2sgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dGhpcy5zdGVwc1tpbmRleF0ub25DbGljaygpO1xuXHRcdH1cblx0XHR0aGlzLnN0ZXBTZWxlY3RlZC5lbWl0KHsgc3RlcDogdGhpcy5zdGVwc1tpbmRleF0sIGluZGV4IH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgY3VycmVudCBzdGF0ZSBiYXNlZCBvbiB3ZWlnaHQgb2YgdGhlIHN0YXRlXG5cdCAqIFdlaWdodCBvZiBzdGF0ZSBnb2VzIGZyb20gZXJyb3IsIGluY29tcGxldGUsIGN1cnJlbnQsIGFuZCBjb21wbGV0ZVxuXHQgKlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGljb24gJiB0cmFuc2xhdGlvbiBzdHJpbmcgdG8gZGlzcGxheVxuXHQgKiBAcGFyYW0gaW5kZXggbnVtYmVyXG5cdCAqIEByZXR1cm5zIHN0cmluZ1xuXHQgKi9cblx0Z2V0Q3VycmVudFN0YXRlKGluZGV4OiBudW1iZXIpIHtcblx0XHRpZiAoaW5kZXggPT09IHRoaXMuY3VycmVudCkge1xuXHRcdFx0cmV0dXJuIFwiY3VycmVudFwiO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5zdGVwc1tpbmRleF0uaW52YWxpZCkge1xuXHRcdFx0cmV0dXJuIFwiaW52YWxpZFwiO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5zdGVwc1tpbmRleF0uY29tcGxldGUpIHtcblx0XHRcdHJldHVybiBcImNvbXBsZXRlXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFwiaW5jb21wbGV0ZVwiO1xuXHR9XG5cblx0cHJpdmF0ZSBzZXRQcm9ncmVzc0luZGljYXRvclN0YXRlcygpIHtcblx0XHRpZiAodGhpcy5zdGVwcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IGFsbCBwcmVjZWRpbmcgc3RlcHMgdG8gYGNvbXBsZXRlYCAmIGZvbGxvd2luZyB0byBgaW5jb21wbGV0ZWBcblx0XHR0aGlzLnN0ZXBzLmZvckVhY2goKHN0ZXA6IFN0ZXAsIGluZGV4KSA9PiB7XG5cdFx0XHRpZiAoaW5kZXggPCB0aGlzLmN1cnJlbnQpIHtcblx0XHRcdFx0c3RlcC5jb21wbGV0ZSA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdGVwLmNvbXBsZXRlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cbiJdfQ==