import { Injectable } from "@angular/core";
import { BehaviorSubject, isObservable, iif } from "rxjs";
import { map } from "rxjs/operators";
import { merge } from "carbon-components-angular/utils";
import EN from "./en";
import * as i0 from "@angular/core";
/**
 * Takes the `Observable` returned from `i18n.get` and an object of variables to replace.
 *
 * The keys specify the variable name in the string.
 *
 * Example:
 * ```typescript
 * service.set({ "TEST": "{{foo}} {{bar}}" });
 *
 * service.replace(service.get("TEST"), { foo: "test", bar: "asdf" })
 * ```
 *
 * Produces: `"test asdf"`
 *
 * @param subject the translation to replace variables on
 * @param variables object of variables to replace
 */
export const replace = (subject, variables) => subject.pipe(map(str => {
    const keys = Object.keys(variables);
    for (const key of keys) {
        const value = variables[key];
        str = str.replace(new RegExp(`{{\\s*${key}\\s*}}`, "g"), value);
    }
    return str;
}));
/**
 * Represents an "overridable" translation value.
 *
 * Largely an internal usecase. There are situations where we want an `Observable` that
 * can emit events from a centralized source **OR** an `Observable` that will emit events
 * from a component local source. The key example being on/off text in a `Toggle` - In some cases
 * we want the `Toggle` to use `I18n`s global translations, but in others we'd prefer to use a local
 * override. We don't ever need to return to a non-overridden state, but we do need the ability to
 * switch _to_ an overridden sate.
 */
export class Overridable {
    constructor(path, i18n) {
        this.path = path;
        this.i18n = i18n;
        /**
         * Our base non-overridden translation.
         */
        this.baseTranslation = this.i18n.get(this.path);
        /**
         * A boolean to flip between overridden and non-overridden states.
         */
        this.isOverridden = false;
        /**
         * ensure `$override` is initialized with the correct default value
         * in some cases `_value` can get changed for an `Observable` before `$override` is created
         */
        const value = this.i18n.getValueFromPath(this.path);
        this.$override = new BehaviorSubject(value);
        this._value = value;
    }
    /**
     * The raw value of the translation. Defaults to the string value, but will return the value passed to `override`
     *
     * @readonly
     */
    get value() {
        return this._value;
    }
    set value(v) {
        this.override(v);
    }
    /**
     * The translation subject. Returns either a stream of overridden values, or our base translation values.
     *
     * @readonly
     */
    get subject() {
        /**
         * since inputs are bound on template instantiation (and thusly will always have _some_ value)
         * We can use a simple boolean and the `iif` function to determine which subject to return on subscription
         */
        return iif(() => this.isOverridden, this.$override, this.baseTranslation);
    }
    /**
     * Takes a string or an `Observable` that emits strings.
     * Overrides the value provided by the `I18n` service.
     */
    override(value) {
        this.isOverridden = true;
        // To ensure that there are not multiple subscriptions created for the same observable, we
        // unsubscribe if a subscription already exists for an observable before creating a new one.
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
        this._value = value;
        if (isObservable(value)) {
            this.subscription = value.subscribe(v => {
                this.$override.next(v);
            });
        }
        else {
            this.$override.next(value);
        }
    }
}
/**
 * The I18n service is a minimal internal singleton service used to supply our components with translated strings.
 *
 * All the components that support I18n also support directly passed strings.
 * Usage of I18n is optional, and it is not recommended for application use (libraries like ngx-translate
 * are a better choice)
 *
 */
export class I18n {
    constructor() {
        this.translationStrings = EN;
        this.translations = new Map();
        this.locale = new BehaviorSubject("en");
    }
    /**
     * Sets the locale and optionally the translation strings. Locale is used by components that
     * are already locale aware (datepicker for example) while the translation strings are used
     * for components that are not.
     *
     * Locales set here will override locales/languages set in components
     * @param language an ISO 639-1 language code - https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
     * @param strings an object of strings, optional
     */
    setLocale(language, strings) {
        this.locale.next(language);
        if (strings) {
            this.set(strings);
        }
    }
    /**
     * Returns the current locale
     */
    getLocale() {
        return this.locale.value;
    }
    /**
     * Returns an observable that resolves to the current locale, and will update when changed
     */
    getLocaleObservable() {
        return this.locale.asObservable();
    }
    /**
     * Set/update the translations from an object. Also notifies all participating components of the update.
     *
     * @param strings an object of strings, should follow the same format as src/i18n/en.json
     */
    set(strings) {
        this.translationStrings = merge({}, EN, strings);
        // iterate over all our tracked translations and update each observable
        const translations = Array.from(this.translations);
        for (const [path, subject] of translations) {
            subject.next(this.getValueFromPath(path));
        }
    }
    /**
     * When a path is specified returns an observable that will resolve to the translation string value.
     *
     * Returns the full translations object if path is not specified.
     *
     * @param path optional, looks like `"NOTIFICATION.CLOSE_BUTTON"`
     */
    get(path) {
        if (!path) {
            return this.translationStrings;
        }
        return this.getSubject(path);
    }
    /**
     * Returns all descendents of some path fragment as an object.
     *
     * @param partialPath a path fragment, for example `"NOTIFICATION"`
     */
    getMultiple(partialPath) {
        const values = this.getValueFromPath(partialPath);
        const subjects = {};
        for (const key of Object.keys(values)) {
            if (values[key] === Object(values[key])) {
                subjects[key] = this.getMultiple(`${partialPath}.${key}`);
            }
            else {
                subjects[key] = this.getSubject(`${partialPath}.${key}`);
            }
        }
        return subjects;
    }
    /**
     * Returns an instance of `Overridable` that can be used to optionally override the value provided by `I18n`
     * @param path looks like `"NOTIFICATION.CLOSE_BUTTON"`
     */
    getOverridable(path) {
        return new Overridable(path, this);
    }
    /**
     * Takes the `Observable` returned from `i18n.get` and an object of variables to replace.
     *
     * The keys specify the variable name in the string.
     *
     * Example:
     * ```
     * service.set({ "TEST": "{{foo}} {{bar}}" });
     *
     * service.replace(service.get("TEST"), { foo: "test", bar: "asdf" })
     * ```
     *
     * Produces: `"test asdf"`
     *
     * @param subject the translation to replace variables on
     * @param variables object of variables to replace
     */
    replace(subject, variables) {
        return replace(subject, variables);
    }
    /**
     * Trys to resolve a value from the provided path.
     *
     * @param path looks like `"NOTIFICATION.CLOSE_BUTTON"`
     */
    getValueFromPath(path) {
        let value = this.translationStrings;
        for (const segment of path.split(".")) {
            if (value[segment] !== undefined && value[segment] !== null) {
                value = value[segment];
            }
            else {
                throw new Error(`no key ${segment} at ${path}`);
            }
        }
        return value;
    }
    /**
     * Helper method that returns an observable from the internal cache based on the path
     *
     * @param path looks like `"NOTIFICATION.CLOSE_BUTTON"`
     */
    getSubject(path) {
        try {
            // we run this here to validate the path exists before adding it to the translation map
            const value = this.getValueFromPath(path);
            if (this.translations.has(path)) {
                return this.translations.get(path);
            }
            const translation = new BehaviorSubject(value);
            this.translations.set(path, translation);
            return translation;
        }
        catch (error) {
            console.error(error);
        }
    }
}
I18n.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: I18n, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
I18n.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: I18n });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: I18n, decorators: [{
            type: Injectable
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaTE4bi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2kxOG4vaTE4bi5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUNOLGVBQWUsRUFFZixZQUFZLEVBQ1osR0FBRyxFQUVILE1BQU0sTUFBTSxDQUFDO0FBQ2QsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUV4RCxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7O0FBRXRCOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sT0FBTyxHQUFHLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FDMUQsR0FBRyxDQUFlLEdBQUcsQ0FBQyxFQUFFO0lBQ3ZCLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDcEMsS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLEVBQUU7UUFDdkIsTUFBTSxLQUFLLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzdCLEdBQUcsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksTUFBTSxDQUFDLFNBQVMsR0FBRyxRQUFRLEVBQUUsR0FBRyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7S0FDaEU7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNaLENBQUMsQ0FBQyxDQUNGLENBQUM7QUFFRjs7Ozs7Ozs7O0dBU0c7QUFDSCxNQUFNLE9BQU8sV0FBVztJQWlEdkIsWUFBc0IsSUFBWSxFQUFZLElBQVU7UUFBbEMsU0FBSSxHQUFKLElBQUksQ0FBUTtRQUFZLFNBQUksR0FBSixJQUFJLENBQU07UUFkeEQ7O1dBRUc7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STtxR0FBSixJQUFJOzJGQUFKLElBQUk7a0JBRGhCLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7XG5cdEJlaGF2aW9yU3ViamVjdCxcblx0T2JzZXJ2YWJsZSxcblx0aXNPYnNlcnZhYmxlLFxuXHRpaWYsXG5cdFN1YnNjcmlwdGlvblxufSBmcm9tIFwicnhqc1wiO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSBcInJ4anMvb3BlcmF0b3JzXCI7XG5pbXBvcnQgeyBtZXJnZSB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3V0aWxzXCI7XG5cbmltcG9ydCBFTiBmcm9tIFwiLi9lblwiO1xuXG4vKipcbiAqIFRha2VzIHRoZSBgT2JzZXJ2YWJsZWAgcmV0dXJuZWQgZnJvbSBgaTE4bi5nZXRgIGFuZCBhbiBvYmplY3Qgb2YgdmFyaWFibGVzIHRvIHJlcGxhY2UuXG4gKlxuICogVGhlIGtleXMgc3BlY2lmeSB0aGUgdmFyaWFibGUgbmFtZSBpbiB0aGUgc3RyaW5nLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBzZXJ2aWNlLnNldCh7IFwiVEVTVFwiOiBcInt7Zm9vfX0ge3tiYXJ9fVwiIH0pO1xuICpcbiAqIHNlcnZpY2UucmVwbGFjZShzZXJ2aWNlLmdldChcIlRFU1RcIiksIHsgZm9vOiBcInRlc3RcIiwgYmFyOiBcImFzZGZcIiB9KVxuICogYGBgXG4gKlxuICogUHJvZHVjZXM6IGBcInRlc3QgYXNkZlwiYFxuICpcbiAqIEBwYXJhbSBzdWJqZWN0IHRoZSB0cmFuc2xhdGlvbiB0byByZXBsYWNlIHZhcmlhYmxlcyBvblxuICogQHBhcmFtIHZhcmlhYmxlcyBvYmplY3Qgb2YgdmFyaWFibGVzIHRvIHJlcGxhY2VcbiAqL1xuZXhwb3J0IGNvbnN0IHJlcGxhY2UgPSAoc3ViamVjdCwgdmFyaWFibGVzKSA9PiBzdWJqZWN0LnBpcGUoXG5cdG1hcDxzdHJpbmcsIHZvaWQ+KHN0ciA9PiB7XG5cdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhcmlhYmxlcyk7XG5cdFx0Zm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuXHRcdFx0Y29uc3QgdmFsdWUgPSB2YXJpYWJsZXNba2V5XTtcblx0XHRcdHN0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoYHt7XFxcXHMqJHtrZXl9XFxcXHMqfX1gLCBcImdcIiksIHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN0cjtcblx0fSlcbik7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBcIm92ZXJyaWRhYmxlXCIgdHJhbnNsYXRpb24gdmFsdWUuXG4gKlxuICogTGFyZ2VseSBhbiBpbnRlcm5hbCB1c2VjYXNlLiBUaGVyZSBhcmUgc2l0dWF0aW9ucyB3aGVyZSB3ZSB3YW50IGFuIGBPYnNlcnZhYmxlYCB0aGF0XG4gKiBjYW4gZW1pdCBldmVudHMgZnJvbSBhIGNlbnRyYWxpemVkIHNvdXJjZSAqKk9SKiogYW4gYE9ic2VydmFibGVgIHRoYXQgd2lsbCBlbWl0IGV2ZW50c1xuICogZnJvbSBhIGNvbXBvbmVudCBsb2NhbCBzb3VyY2UuIFRoZSBrZXkgZXhhbXBsZSBiZWluZyBvbi9vZmYgdGV4dCBpbiBhIGBUb2dnbGVgIC0gSW4gc29tZSBjYXNlc1xuICogd2Ugd2FudCB0aGUgYFRvZ2dsZWAgdG8gdXNlIGBJMThuYHMgZ2xvYmFsIHRyYW5zbGF0aW9ucywgYnV0IGluIG90aGVycyB3ZSdkIHByZWZlciB0byB1c2UgYSBsb2NhbFxuICogb3ZlcnJpZGUuIFdlIGRvbid0IGV2ZXIgbmVlZCB0byByZXR1cm4gdG8gYSBub24tb3ZlcnJpZGRlbiBzdGF0ZSwgYnV0IHdlIGRvIG5lZWQgdGhlIGFiaWxpdHkgdG9cbiAqIHN3aXRjaCBfdG9fIGFuIG92ZXJyaWRkZW4gc2F0ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIE92ZXJyaWRhYmxlIHtcblx0LyoqXG5cdCAqIFRoZSByYXcgdmFsdWUgb2YgdGhlIHRyYW5zbGF0aW9uLiBEZWZhdWx0cyB0byB0aGUgc3RyaW5nIHZhbHVlLCBidXQgd2lsbCByZXR1cm4gdGhlIHZhbHVlIHBhc3NlZCB0byBgb3ZlcnJpZGVgXG5cdCAqXG5cdCAqIEByZWFkb25seVxuXHQgKi9cblx0cHVibGljIGdldCB2YWx1ZSgpOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4ge1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZTtcblx0fVxuXG5cdHB1YmxpYyBzZXQgdmFsdWUodjogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5vdmVycmlkZSh2KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgdHJhbnNsYXRpb24gc3ViamVjdC4gUmV0dXJucyBlaXRoZXIgYSBzdHJlYW0gb2Ygb3ZlcnJpZGRlbiB2YWx1ZXMsIG9yIG91ciBiYXNlIHRyYW5zbGF0aW9uIHZhbHVlcy5cblx0ICpcblx0ICogQHJlYWRvbmx5XG5cdCAqL1xuXHRwdWJsaWMgZ2V0IHN1YmplY3QoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblx0XHQvKipcblx0XHQgKiBzaW5jZSBpbnB1dHMgYXJlIGJvdW5kIG9uIHRlbXBsYXRlIGluc3RhbnRpYXRpb24gKGFuZCB0aHVzbHkgd2lsbCBhbHdheXMgaGF2ZSBfc29tZV8gdmFsdWUpXG5cdFx0ICogV2UgY2FuIHVzZSBhIHNpbXBsZSBib29sZWFuIGFuZCB0aGUgYGlpZmAgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIHN1YmplY3QgdG8gcmV0dXJuIG9uIHN1YnNjcmlwdGlvblxuXHRcdCAqL1xuXHRcdHJldHVybiBpaWYoKCkgPT4gdGhpcy5pc092ZXJyaWRkZW4sIHRoaXMuJG92ZXJyaWRlLCB0aGlzLmJhc2VUcmFuc2xhdGlvbik7XG5cdH1cblxuXHQvKipcblx0ICogT3ZlcnJpZGRlbiB2YWx1ZS4gQWNjZXNzZWQgYnkgdGhlIHJlYWRvbmx5IGdldHRlciBgdmFsdWVgIGFuZCBzZXQgdGhyb3VnaCBgb3ZlcnJpZGVgXG5cdCAqL1xuXHRwcm90ZWN0ZWQgX3ZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz47XG5cdC8qKlxuXHQgKiBTdWJqZWN0IG9mIG92ZXJyaWRkZW4gdmFsdWVzLiBJbml0aWFsaXplZCB3aXRoIG91ciBkZWZhdWx0IHZhbHVlLlxuXHQgKi9cblx0cHJvdGVjdGVkICRvdmVycmlkZTogQmVoYXZpb3JTdWJqZWN0PHN0cmluZz47XG5cdC8qKlxuXHQgKiBPdXIgYmFzZSBub24tb3ZlcnJpZGRlbiB0cmFuc2xhdGlvbi5cblx0ICovXG5cdHByb3RlY3RlZCBiYXNlVHJhbnNsYXRpb246IE9ic2VydmFibGU8c3RyaW5nPiA9IHRoaXMuaTE4bi5nZXQodGhpcy5wYXRoKTtcblxuXHQvKipcblx0ICogU3Vic2NyaXB0aW9uIHRvIHRoZSBvYnNlcnZhYmxlIHByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlIChpZiBhbnkpXG5cdCAqL1xuXHRwcm90ZWN0ZWQgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cdC8qKlxuXHQgKiBBIGJvb2xlYW4gdG8gZmxpcCBiZXR3ZWVuIG92ZXJyaWRkZW4gYW5kIG5vbi1vdmVycmlkZGVuIHN0YXRlcy5cblx0ICovXG5cdHByb3RlY3RlZCBpc092ZXJyaWRkZW4gPSBmYWxzZTtcblxuXHRjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcGF0aDogc3RyaW5nLCBwcm90ZWN0ZWQgaTE4bjogSTE4bikge1xuXHRcdC8qKlxuXHRcdCAqIGVuc3VyZSBgJG92ZXJyaWRlYCBpcyBpbml0aWFsaXplZCB3aXRoIHRoZSBjb3JyZWN0IGRlZmF1bHQgdmFsdWVcblx0XHQgKiBpbiBzb21lIGNhc2VzIGBfdmFsdWVgIGNhbiBnZXQgY2hhbmdlZCBmb3IgYW4gYE9ic2VydmFibGVgIGJlZm9yZSBgJG92ZXJyaWRlYCBpcyBjcmVhdGVkXG5cdFx0ICovXG5cdFx0Y29uc3QgdmFsdWUgPSB0aGlzLmkxOG4uZ2V0VmFsdWVGcm9tUGF0aCh0aGlzLnBhdGgpIGFzIHN0cmluZztcblx0XHR0aGlzLiRvdmVycmlkZSA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPih2YWx1ZSk7XG5cdFx0dGhpcy5fdmFsdWUgPSB2YWx1ZTtcblx0fVxuXHQvKipcblx0ICogVGFrZXMgYSBzdHJpbmcgb3IgYW4gYE9ic2VydmFibGVgIHRoYXQgZW1pdHMgc3RyaW5ncy5cblx0ICogT3ZlcnJpZGVzIHRoZSB2YWx1ZSBwcm92aWRlZCBieSB0aGUgYEkxOG5gIHNlcnZpY2UuXG5cdCAqL1xuXHRvdmVycmlkZSh2YWx1ZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5pc092ZXJyaWRkZW4gPSB0cnVlO1xuXHRcdC8vIFRvIGVuc3VyZSB0aGF0IHRoZXJlIGFyZSBub3QgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucyBjcmVhdGVkIGZvciB0aGUgc2FtZSBvYnNlcnZhYmxlLCB3ZVxuXHRcdC8vIHVuc3Vic2NyaWJlIGlmIGEgc3Vic2NyaXB0aW9uIGFscmVhZHkgZXhpc3RzIGZvciBhbiBvYnNlcnZhYmxlIGJlZm9yZSBjcmVhdGluZyBhIG5ldyBvbmUuXG5cdFx0aWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG5cdFx0XHR0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuXHRcdFx0dGhpcy5zdWJzY3JpcHRpb24gPSBudWxsO1xuXHRcdH1cblxuXHRcdHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cblx0XHRpZiAoaXNPYnNlcnZhYmxlKHZhbHVlKSkge1xuXHRcdFx0dGhpcy5zdWJzY3JpcHRpb24gPSB2YWx1ZS5zdWJzY3JpYmUodiA9PiB7XG5cdFx0XHRcdHRoaXMuJG92ZXJyaWRlLm5leHQodik7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy4kb3ZlcnJpZGUubmV4dCh2YWx1ZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQW4gb2JqZWN0IG9mIHN0cmluZ3MsIHNob3VsZCBmb2xsb3cgdGhlIHNhbWUgZm9ybWF0IGFzIHNyYy9pMThuL2VuLmpzb25cbiAqL1xuZXhwb3J0IHR5cGUgVHJhbnNsYXRpb25TdHJpbmdzID0geyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcblxuXG4vKipcbiAqIFRoZSBJMThuIHNlcnZpY2UgaXMgYSBtaW5pbWFsIGludGVybmFsIHNpbmdsZXRvbiBzZXJ2aWNlIHVzZWQgdG8gc3VwcGx5IG91ciBjb21wb25lbnRzIHdpdGggdHJhbnNsYXRlZCBzdHJpbmdzLlxuICpcbiAqIEFsbCB0aGUgY29tcG9uZW50cyB0aGF0IHN1cHBvcnQgSTE4biBhbHNvIHN1cHBvcnQgZGlyZWN0bHkgcGFzc2VkIHN0cmluZ3MuXG4gKiBVc2FnZSBvZiBJMThuIGlzIG9wdGlvbmFsLCBhbmQgaXQgaXMgbm90IHJlY29tbWVuZGVkIGZvciBhcHBsaWNhdGlvbiB1c2UgKGxpYnJhcmllcyBsaWtlIG5neC10cmFuc2xhdGVcbiAqIGFyZSBhIGJldHRlciBjaG9pY2UpXG4gKlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSTE4biB7XG5cdHByb3RlY3RlZCB0cmFuc2xhdGlvblN0cmluZ3MgPSBFTjtcblxuXHRwcm90ZWN0ZWQgdHJhbnNsYXRpb25zID0gbmV3IE1hcCgpO1xuXG5cdHByb3RlY3RlZCBsb2NhbGUgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KFwiZW5cIik7XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGxvY2FsZSBhbmQgb3B0aW9uYWxseSB0aGUgdHJhbnNsYXRpb24gc3RyaW5ncy4gTG9jYWxlIGlzIHVzZWQgYnkgY29tcG9uZW50cyB0aGF0XG5cdCAqIGFyZSBhbHJlYWR5IGxvY2FsZSBhd2FyZSAoZGF0ZXBpY2tlciBmb3IgZXhhbXBsZSkgd2hpbGUgdGhlIHRyYW5zbGF0aW9uIHN0cmluZ3MgYXJlIHVzZWRcblx0ICogZm9yIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90LlxuXHQgKlxuXHQgKiBMb2NhbGVzIHNldCBoZXJlIHdpbGwgb3ZlcnJpZGUgbG9jYWxlcy9sYW5ndWFnZXMgc2V0IGluIGNvbXBvbmVudHNcblx0ICogQHBhcmFtIGxhbmd1YWdlIGFuIElTTyA2MzktMSBsYW5ndWFnZSBjb2RlIC0gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9JU09fNjM5LTFfY29kZXNcblx0ICogQHBhcmFtIHN0cmluZ3MgYW4gb2JqZWN0IG9mIHN0cmluZ3MsIG9wdGlvbmFsXG5cdCAqL1xuXHRwdWJsaWMgc2V0TG9jYWxlKGxhbmd1YWdlOiBzdHJpbmcsIHN0cmluZ3M/OiBUcmFuc2xhdGlvblN0cmluZ3MpIHtcblx0XHR0aGlzLmxvY2FsZS5uZXh0KGxhbmd1YWdlKTtcblx0XHRpZiAoc3RyaW5ncykge1xuXHRcdFx0dGhpcy5zZXQoc3RyaW5ncyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGN1cnJlbnQgbG9jYWxlXG5cdCAqL1xuXHRwdWJsaWMgZ2V0TG9jYWxlKCkge1xuXHRcdHJldHVybiB0aGlzLmxvY2FsZS52YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgdGhhdCByZXNvbHZlcyB0byB0aGUgY3VycmVudCBsb2NhbGUsIGFuZCB3aWxsIHVwZGF0ZSB3aGVuIGNoYW5nZWRcblx0ICovXG5cdHB1YmxpYyBnZXRMb2NhbGVPYnNlcnZhYmxlKCkge1xuXHRcdHJldHVybiB0aGlzLmxvY2FsZS5hc09ic2VydmFibGUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQvdXBkYXRlIHRoZSB0cmFuc2xhdGlvbnMgZnJvbSBhbiBvYmplY3QuIEFsc28gbm90aWZpZXMgYWxsIHBhcnRpY2lwYXRpbmcgY29tcG9uZW50cyBvZiB0aGUgdXBkYXRlLlxuXHQgKlxuXHQgKiBAcGFyYW0gc3RyaW5ncyBhbiBvYmplY3Qgb2Ygc3RyaW5ncywgc2hvdWxkIGZvbGxvdyB0aGUgc2FtZSBmb3JtYXQgYXMgc3JjL2kxOG4vZW4uanNvblxuXHQgKi9cblx0cHVibGljIHNldChzdHJpbmdzOiBUcmFuc2xhdGlvblN0cmluZ3MpIHtcblx0XHR0aGlzLnRyYW5zbGF0aW9uU3RyaW5ncyA9IG1lcmdlKHt9LCBFTiwgc3RyaW5ncyk7XG5cdFx0Ly8gaXRlcmF0ZSBvdmVyIGFsbCBvdXIgdHJhY2tlZCB0cmFuc2xhdGlvbnMgYW5kIHVwZGF0ZSBlYWNoIG9ic2VydmFibGVcblx0XHRjb25zdCB0cmFuc2xhdGlvbnMgPSBBcnJheS5mcm9tKHRoaXMudHJhbnNsYXRpb25zKTtcblx0XHRmb3IgKGNvbnN0IFtwYXRoLCBzdWJqZWN0XSBvZiB0cmFuc2xhdGlvbnMpIHtcblx0XHRcdHN1YmplY3QubmV4dCh0aGlzLmdldFZhbHVlRnJvbVBhdGgocGF0aCkpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBXaGVuIGEgcGF0aCBpcyBzcGVjaWZpZWQgcmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgd2lsbCByZXNvbHZlIHRvIHRoZSB0cmFuc2xhdGlvbiBzdHJpbmcgdmFsdWUuXG5cdCAqXG5cdCAqIFJldHVybnMgdGhlIGZ1bGwgdHJhbnNsYXRpb25zIG9iamVjdCBpZiBwYXRoIGlzIG5vdCBzcGVjaWZpZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSBwYXRoIG9wdGlvbmFsLCBsb29rcyBsaWtlIGBcIk5PVElGSUNBVElPTi5DTE9TRV9CVVRUT05cImBcblx0ICovXG5cdHB1YmxpYyBnZXQocGF0aD86IHN0cmluZyk6IGFueSB7XG5cdFx0aWYgKCFwYXRoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGlvblN0cmluZ3M7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmdldFN1YmplY3QocGF0aCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbGwgZGVzY2VuZGVudHMgb2Ygc29tZSBwYXRoIGZyYWdtZW50IGFzIGFuIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHBhcnRpYWxQYXRoIGEgcGF0aCBmcmFnbWVudCwgZm9yIGV4YW1wbGUgYFwiTk9USUZJQ0FUSU9OXCJgXG5cdCAqL1xuXHRwdWJsaWMgZ2V0TXVsdGlwbGUocGFydGlhbFBhdGg6IHN0cmluZyk6IHsgW2tleTogc3RyaW5nXTogT2JzZXJ2YWJsZTxzdHJpbmc+IH0ge1xuXHRcdGNvbnN0IHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVGcm9tUGF0aChwYXJ0aWFsUGF0aCk7XG5cdFx0Y29uc3Qgc3ViamVjdHMgPSB7fTtcblx0XHRmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWx1ZXMpKSB7XG5cdFx0XHRpZiAodmFsdWVzW2tleV0gPT09IE9iamVjdCh2YWx1ZXNba2V5XSkpIHtcblx0XHRcdFx0c3ViamVjdHNba2V5XSA9IHRoaXMuZ2V0TXVsdGlwbGUoYCR7cGFydGlhbFBhdGh9LiR7a2V5fWApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3ViamVjdHNba2V5XSA9IHRoaXMuZ2V0U3ViamVjdChgJHtwYXJ0aWFsUGF0aH0uJHtrZXl9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBzdWJqZWN0cztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIGBPdmVycmlkYWJsZWAgdGhhdCBjYW4gYmUgdXNlZCB0byBvcHRpb25hbGx5IG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm92aWRlZCBieSBgSTE4bmBcblx0ICogQHBhcmFtIHBhdGggbG9va3MgbGlrZSBgXCJOT1RJRklDQVRJT04uQ0xPU0VfQlVUVE9OXCJgXG5cdCAqL1xuXHRwdWJsaWMgZ2V0T3ZlcnJpZGFibGUocGF0aDogc3RyaW5nKSB7XG5cdFx0cmV0dXJuIG5ldyBPdmVycmlkYWJsZShwYXRoLCB0aGlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUYWtlcyB0aGUgYE9ic2VydmFibGVgIHJldHVybmVkIGZyb20gYGkxOG4uZ2V0YCBhbmQgYW4gb2JqZWN0IG9mIHZhcmlhYmxlcyB0byByZXBsYWNlLlxuXHQgKlxuXHQgKiBUaGUga2V5cyBzcGVjaWZ5IHRoZSB2YXJpYWJsZSBuYW1lIGluIHRoZSBzdHJpbmcuXG5cdCAqXG5cdCAqIEV4YW1wbGU6XG5cdCAqIGBgYFxuXHQgKiBzZXJ2aWNlLnNldCh7IFwiVEVTVFwiOiBcInt7Zm9vfX0ge3tiYXJ9fVwiIH0pO1xuXHQgKlxuXHQgKiBzZXJ2aWNlLnJlcGxhY2Uoc2VydmljZS5nZXQoXCJURVNUXCIpLCB7IGZvbzogXCJ0ZXN0XCIsIGJhcjogXCJhc2RmXCIgfSlcblx0ICogYGBgXG5cdCAqXG5cdCAqIFByb2R1Y2VzOiBgXCJ0ZXN0IGFzZGZcImBcblx0ICpcblx0ICogQHBhcmFtIHN1YmplY3QgdGhlIHRyYW5zbGF0aW9uIHRvIHJlcGxhY2UgdmFyaWFibGVzIG9uXG5cdCAqIEBwYXJhbSB2YXJpYWJsZXMgb2JqZWN0IG9mIHZhcmlhYmxlcyB0byByZXBsYWNlXG5cdCAqL1xuXHRwdWJsaWMgcmVwbGFjZShzdWJqZWN0OiBPYnNlcnZhYmxlPHN0cmluZz4sIHZhcmlhYmxlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkge1xuXHRcdHJldHVybiByZXBsYWNlKHN1YmplY3QsIHZhcmlhYmxlcyk7XG5cdH1cblxuXHQvKipcblx0ICogVHJ5cyB0byByZXNvbHZlIGEgdmFsdWUgZnJvbSB0aGUgcHJvdmlkZWQgcGF0aC5cblx0ICpcblx0ICogQHBhcmFtIHBhdGggbG9va3MgbGlrZSBgXCJOT1RJRklDQVRJT04uQ0xPU0VfQlVUVE9OXCJgXG5cdCAqL1xuXHRwdWJsaWMgZ2V0VmFsdWVGcm9tUGF0aChwYXRoKTogc3RyaW5nIHwgeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSB7XG5cdFx0bGV0IHZhbHVlID0gdGhpcy50cmFuc2xhdGlvblN0cmluZ3M7XG5cdFx0Zm9yIChjb25zdCBzZWdtZW50IG9mIHBhdGguc3BsaXQoXCIuXCIpKSB7XG5cdFx0XHRpZiAodmFsdWVbc2VnbWVudF0gIT09IHVuZGVmaW5lZCAmJiB2YWx1ZVtzZWdtZW50XSAhPT0gbnVsbCkge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3NlZ21lbnRdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBubyBrZXkgJHtzZWdtZW50fSBhdCAke3BhdGh9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZSBhcyBhbnk7XG5cdH1cblxuXHQvKipcblx0ICogSGVscGVyIG1ldGhvZCB0aGF0IHJldHVybnMgYW4gb2JzZXJ2YWJsZSBmcm9tIHRoZSBpbnRlcm5hbCBjYWNoZSBiYXNlZCBvbiB0aGUgcGF0aFxuXHQgKlxuXHQgKiBAcGFyYW0gcGF0aCBsb29rcyBsaWtlIGBcIk5PVElGSUNBVElPTi5DTE9TRV9CVVRUT05cImBcblx0ICovXG5cdHByb3RlY3RlZCBnZXRTdWJqZWN0KHBhdGg6IHN0cmluZyk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIHdlIHJ1biB0aGlzIGhlcmUgdG8gdmFsaWRhdGUgdGhlIHBhdGggZXhpc3RzIGJlZm9yZSBhZGRpbmcgaXQgdG8gdGhlIHRyYW5zbGF0aW9uIG1hcFxuXHRcdFx0Y29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlRnJvbVBhdGgocGF0aCkgYXMgc3RyaW5nO1xuXHRcdFx0aWYgKHRoaXMudHJhbnNsYXRpb25zLmhhcyhwYXRoKSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGlvbnMuZ2V0KHBhdGgpO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgdHJhbnNsYXRpb24gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHZhbHVlKTtcblx0XHRcdHRoaXMudHJhbnNsYXRpb25zLnNldChwYXRoLCB0cmFuc2xhdGlvbik7XG5cdFx0XHRyZXR1cm4gdHJhbnNsYXRpb247XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuXHRcdH1cblx0fVxufVxuIl19