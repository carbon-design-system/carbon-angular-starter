import { Component, Input, Output, EventEmitter } from "@angular/core";
import { getScrollbarWidth } from "carbon-components-angular/utils";
import * as i0 from "@angular/core";
import * as i1 from "carbon-components-angular/i18n";
import * as i2 from "@angular/common";
import * as i3 from "./table-head-cell.component";
import * as i4 from "./table-head-checkbox.component";
import * as i5 from "./table-head-expand.component";
/**
 * A subcomponent that creates the thead of the table
 *
 * ## Basic usage
 *
 * ```html
 * 	<thead cdsTableHead [model]="model"></thead>
 * ```
 */
export class TableHead {
    constructor(i18n) {
        this.i18n = i18n;
        this.showSelectionColumn = true;
        this.enableSingleSelect = false;
        this.selectAllCheckboxSomeSelected = false;
        this.selectAllCheckbox = false;
        this.skeleton = false;
        this.stickyHeader = false;
        /**
         * Setting sortable to false will disable all headers including headers which are sortable. Is is
         * possible to set the sortable state on the header item to disable/enable sorting for only some headers.
         */
        this.sortable = true;
        /**
         * Emits an index of the column that wants to be sorted.
         */
        this.sort = new EventEmitter();
        /**
         * Emits if all rows are selected.
         *
         * @param model
         */
        this.selectAll = new EventEmitter();
        /**
         * Emits if all rows are deselected.
         *
         * @param model
         */
        this.deselectAll = new EventEmitter();
        this.scrollbarWidth = 0;
        this._checkboxHeaderLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
        this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
        this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
        this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
    }
    set checkboxHeaderLabel(value) {
        this._checkboxHeaderLabel.override(value);
    }
    get checkboxHeaderLabel() {
        return this._checkboxHeaderLabel.value;
    }
    set sortDescendingLabel(value) {
        this._sortDescendingLabel.override(value);
    }
    get sortDescendingLabel() {
        return this._sortDescendingLabel.value;
    }
    set sortAscendingLabel(value) {
        this._sortAscendingLabel.override(value);
    }
    get sortAscendingLabel() {
        return this._sortAscendingLabel.value;
    }
    set filterTitle(value) {
        this._filterTitle.override(value);
    }
    get filterTitle() {
        return this._filterTitle.value;
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.scrollbarWidth = getScrollbarWidth();
        });
    }
    onSelectAllCheckboxChange() {
        if (!this.selectAllCheckbox && !this.selectAllCheckboxSomeSelected) {
            this.selectAll.emit(this.model);
        }
        else {
            this.deselectAll.emit(this.model);
        }
    }
    getCheckboxHeaderLabel() {
        return this._checkboxHeaderLabel.subject;
    }
    getSortDescendingLabel() {
        return this._sortDescendingLabel.subject;
    }
    getSortAscendingLabel() {
        return this._sortAscendingLabel.subject;
    }
    getFilterTitle() {
        return this._filterTitle.subject;
    }
}
TableHead.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TableHead, deps: [{ token: i1.I18n }], target: i0.ɵɵFactoryTarget.Component });
TableHead.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: TableHead, selector: "[cdsTableHead], [ibmTableHead]", inputs: { model: "model", showSelectionColumn: "showSelectionColumn", enableSingleSelect: "enableSingleSelect", selectAllCheckboxSomeSelected: "selectAllCheckboxSomeSelected", selectAllCheckbox: "selectAllCheckbox", skeleton: "skeleton", stickyHeader: "stickyHeader", sortable: "sortable", checkboxHeaderLabel: "checkboxHeaderLabel", sortDescendingLabel: "sortDescendingLabel", sortAscendingLabel: "sortAscendingLabel", filterTitle: "filterTitle" }, outputs: { sort: "sort", selectAll: "selectAll", deselectAll: "deselectAll" }, ngImport: i0, template: `
	<ng-container *ngIf="model">
		<tr>
			<th
				cdsTableHeadExpand
				*ngIf="model.hasExpandableRows()"
				scope="col"
				[ngClass]="{'cds--table-expand-v2': stickyHeader}"
				[id]="model.getId('expand')">
			</th>
			<th
				*ngIf="!skeleton && showSelectionColumn && enableSingleSelect"
				scope="col"
				style="width: 0;"
				[id]="model.getId('select')">
				<!-- add width 0; since the carbon styles don't seem to constrain this headers width -->
			</th>
			<th
				cdsTableHeadCheckbox
				*ngIf="!skeleton && showSelectionColumn && !enableSingleSelect"
				scope="col"
				[checked]="selectAllCheckbox"
				[indeterminate]="selectAllCheckboxSomeSelected"
				[ariaLabel]="getCheckboxHeaderLabel()"
				[skeleton]="skeleton"
				[name]="model.getHeaderId('select')"
				(change)="onSelectAllCheckboxChange()"
				[id]="model.getId('select')">
			</th>
			<ng-container *ngFor="let column of model.header; let i = index">
				<th
					*ngIf="column && column.visible"
					[ngStyle]="column.style"
					cdsTableHeadCell
					scope="col"
					[class]="column.className"
					[sortable]="sortable"
					[skeleton]="skeleton"
					[id]="model.getId(i)"
					[column]="column"
					[filterTitle]="getFilterTitle()"
					[attr.colspan]="column.colSpan"
					[attr.rowspan]="column.rowSpan"
					(sort)="sort.emit(i)">
				</th>
			</ng-container>
			<th *ngIf="!skeleton && stickyHeader && scrollbarWidth"
				scope="col"
				[ngStyle]="{'width': scrollbarWidth + 'px', 'padding': 0, 'border': 0}">
				<!--
					Scrollbar pushes body to the left so this header column is added to push
					the title bar the same amount and keep the header and body columns aligned.
				-->
			</th>
		</tr>
	</ng-container>
	<ng-content></ng-content>
	`, isInline: true, styles: [".cds--table-expand-v2{padding-left:2.5rem}\n"], dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: i3.TableHeadCell, selector: "[cdsTableHeadCell], [ibmTableHeadCell]", inputs: ["column", "skeleton", "sortable", "sortDescendingLabel", "sortAscendingLabel", "filterTitle"], outputs: ["sort"] }, { kind: "component", type: i4.TableHeadCheckbox, selector: "[cdsTableHeadCheckbox], [ibmTableHeadCheckbox]", inputs: ["checked", "indeterminate", "skeleton", "name", "ariaLabel"], outputs: ["change"] }, { kind: "component", type: i5.TableHeadExpand, selector: "[cdsTableHeadExpand], [ibmTableHeadExpand]" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TableHead, decorators: [{
            type: Component,
            args: [{ selector: "[cdsTableHead], [ibmTableHead]", template: `
	<ng-container *ngIf="model">
		<tr>
			<th
				cdsTableHeadExpand
				*ngIf="model.hasExpandableRows()"
				scope="col"
				[ngClass]="{'cds--table-expand-v2': stickyHeader}"
				[id]="model.getId('expand')">
			</th>
			<th
				*ngIf="!skeleton && showSelectionColumn && enableSingleSelect"
				scope="col"
				style="width: 0;"
				[id]="model.getId('select')">
				<!-- add width 0; since the carbon styles don't seem to constrain this headers width -->
			</th>
			<th
				cdsTableHeadCheckbox
				*ngIf="!skeleton && showSelectionColumn && !enableSingleSelect"
				scope="col"
				[checked]="selectAllCheckbox"
				[indeterminate]="selectAllCheckboxSomeSelected"
				[ariaLabel]="getCheckboxHeaderLabel()"
				[skeleton]="skeleton"
				[name]="model.getHeaderId('select')"
				(change)="onSelectAllCheckboxChange()"
				[id]="model.getId('select')">
			</th>
			<ng-container *ngFor="let column of model.header; let i = index">
				<th
					*ngIf="column && column.visible"
					[ngStyle]="column.style"
					cdsTableHeadCell
					scope="col"
					[class]="column.className"
					[sortable]="sortable"
					[skeleton]="skeleton"
					[id]="model.getId(i)"
					[column]="column"
					[filterTitle]="getFilterTitle()"
					[attr.colspan]="column.colSpan"
					[attr.rowspan]="column.rowSpan"
					(sort)="sort.emit(i)">
				</th>
			</ng-container>
			<th *ngIf="!skeleton && stickyHeader && scrollbarWidth"
				scope="col"
				[ngStyle]="{'width': scrollbarWidth + 'px', 'padding': 0, 'border': 0}">
				<!--
					Scrollbar pushes body to the left so this header column is added to push
					the title bar the same amount and keep the header and body columns aligned.
				-->
			</th>
		</tr>
	</ng-container>
	<ng-content></ng-content>
	`, styles: [".cds--table-expand-v2{padding-left:2.5rem}\n"] }]
        }], ctorParameters: function () { return [{ type: i1.I18n }]; }, propDecorators: { model: [{
                type: Input
            }], showSelectionColumn: [{
                type: Input
            }], enableSingleSelect: [{
                type: Input
            }], selectAllCheckboxSomeSelected: [{
                type: Input
            }], selectAllCheckbox: [{
                type: Input
            }], skeleton: [{
                type: Input
            }], stickyHeader: [{
                type: Input
            }], sortable: [{
                type: Input
            }], checkboxHeaderLabel: [{
                type: Input
            }], sortDescendingLabel: [{
                type: Input
            }], sortAscendingLabel: [{
                type: Input
            }], filterTitle: [{
                type: Input
            }], sort: [{
                type: Output
            }], selectAll: [{
                type: Output
            }], deselectAll: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtaGVhZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdGFibGUvaGVhZC90YWJsZS1oZWFkLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUVaLE1BQU0sZUFBZSxDQUFDO0FBR3ZCLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlDQUFpQyxDQUFDOzs7Ozs7O0FBS3BFOzs7Ozs7OztHQVFHO0FBb0VILE1BQU0sT0FBTyxTQUFTO0lBaUZyQixZQUFzQixJQUFVO1FBQVYsU0FBSSxHQUFKLElBQUksQ0FBTTtRQTlFdkIsd0JBQW1CLEdBQUcsSUFBSSxDQUFDO1FBRTNCLHVCQUFrQixHQUFHLEtBQUssQ0FBQztRQUUzQixrQ0FBNkIsR0FBRyxLQUFLLENBQUM7UUFFdEMsc0JBQWlCLEdBQUcsS0FBSyxDQUFDO1FBRTFCLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFFakIsaUJBQVksR0FBRyxLQUFLLENBQUM7UUFFOUI7OztXQUdHO1FBQ00sYUFBUSxHQUFHLElBQUksQ0FBQztRQXNDekI7O1dBRUc7UUFDTyxTQUFJLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQUM1Qzs7OztXQUlHO1FBQ08sY0FBUyxHQUFHLElBQUksWUFBWSxFQUFjLENBQUM7UUFDckQ7Ozs7V0FJRztRQUNPLGdCQUFXLEdBQUcsSUFBSSxZQUFZLEVBQWMsQ0FBQztRQUVoRCxtQkFBYyxHQUFHLENBQUMsQ0FBQztRQUVoQix5QkFBb0IsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1FBQ3pFLHlCQUFvQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLHVCQUF1QixDQUFDLENBQUM7UUFDekUsd0JBQW1CLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxj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SztnQkFVRixXQUFXO3NCQURkLEtBQUs7Z0JBWUksSUFBSTtzQkFBYixNQUFNO2dCQU1HLFNBQVM7c0JBQWxCLE1BQU07Z0JBTUcsV0FBVztzQkFBcEIsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0SW5wdXQsXG5cdE91dHB1dCxcblx0RXZlbnRFbWl0dGVyLFxuXHRBZnRlclZpZXdJbml0XG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5cbmltcG9ydCB7IFRhYmxlTW9kZWwgfSBmcm9tIFwiLi4vdGFibGUtbW9kZWwuY2xhc3NcIjtcbmltcG9ydCB7IGdldFNjcm9sbGJhcldpZHRoIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvdXRpbHNcIjtcbmltcG9ydCB7IEkxOG4sIE92ZXJyaWRhYmxlIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvaTE4blwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gXCJyeGpzXCI7XG5pbXBvcnQgeyBUYWJsZVJvd1NpemUgfSBmcm9tIFwiLi4vdGFibGUudHlwZXNcIjtcblxuLyoqXG4gKiBBIHN1YmNvbXBvbmVudCB0aGF0IGNyZWF0ZXMgdGhlIHRoZWFkIG9mIHRoZSB0YWJsZVxuICpcbiAqICMjIEJhc2ljIHVzYWdlXG4gKlxuICogYGBgaHRtbFxuICogXHQ8dGhlYWQgY2RzVGFibGVIZWFkIFttb2RlbF09XCJtb2RlbFwiPjwvdGhlYWQ+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG5cdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjb21wb25lbnQtc2VsZWN0b3Jcblx0c2VsZWN0b3I6IFwiW2Nkc1RhYmxlSGVhZF0sIFtpYm1UYWJsZUhlYWRdXCIsXG5cdHRlbXBsYXRlOiBgXG5cdDxuZy1jb250YWluZXIgKm5nSWY9XCJtb2RlbFwiPlxuXHRcdDx0cj5cblx0XHRcdDx0aFxuXHRcdFx0XHRjZHNUYWJsZUhlYWRFeHBhbmRcblx0XHRcdFx0Km5nSWY9XCJtb2RlbC5oYXNFeHBhbmRhYmxlUm93cygpXCJcblx0XHRcdFx0c2NvcGU9XCJjb2xcIlxuXHRcdFx0XHRbbmdDbGFzc109XCJ7J2Nkcy0tdGFibGUtZXhwYW5kLXYyJzogc3RpY2t5SGVhZGVyfVwiXG5cdFx0XHRcdFtpZF09XCJtb2RlbC5nZXRJZCgnZXhwYW5kJylcIj5cblx0XHRcdDwvdGg+XG5cdFx0XHQ8dGhcblx0XHRcdFx0Km5nSWY9XCIhc2tlbGV0b24gJiYgc2hvd1NlbGVjdGlvbkNvbHVtbiAmJiBlbmFibGVTaW5nbGVTZWxlY3RcIlxuXHRcdFx0XHRzY29wZT1cImNvbFwiXG5cdFx0XHRcdHN0eWxlPVwid2lkdGg6IDA7XCJcblx0XHRcdFx0W2lkXT1cIm1vZGVsLmdldElkKCdzZWxlY3QnKVwiPlxuXHRcdFx0XHQ8IS0tIGFkZCB3aWR0aCAwOyBzaW5jZSB0aGUgY2FyYm9uIHN0eWxlcyBkb24ndCBzZWVtIHRvIGNvbnN0cmFpbiB0aGlzIGhlYWRlcnMgd2lkdGggLS0+XG5cdFx0XHQ8L3RoPlxuXHRcdFx0PHRoXG5cdFx0XHRcdGNkc1RhYmxlSGVhZENoZWNrYm94XG5cdFx0XHRcdCpuZ0lmPVwiIXNrZWxldG9uICYmIHNob3dTZWxlY3Rpb25Db2x1bW4gJiYgIWVuYWJsZVNpbmdsZVNlbGVjdFwiXG5cdFx0XHRcdHNjb3BlPVwiY29sXCJcblx0XHRcdFx0W2NoZWNrZWRdPVwic2VsZWN0QWxsQ2hlY2tib3hcIlxuXHRcdFx0XHRbaW5kZXRlcm1pbmF0ZV09XCJzZWxlY3RBbGxDaGVja2JveFNvbWVTZWxlY3RlZFwiXG5cdFx0XHRcdFthcmlhTGFiZWxdPVwiZ2V0Q2hlY2tib3hIZWFkZXJMYWJlbCgpXCJcblx0XHRcdFx0W3NrZWxldG9uXT1cInNrZWxldG9uXCJcblx0XHRcdFx0W25hbWVdPVwibW9kZWwuZ2V0SGVhZGVySWQoJ3NlbGVjdCcpXCJcblx0XHRcdFx0KGNoYW5nZSk9XCJvblNlbGVjdEFsbENoZWNrYm94Q2hhbmdlKClcIlxuXHRcdFx0XHRbaWRdPVwibW9kZWwuZ2V0SWQoJ3NlbGVjdCcpXCI+XG5cdFx0XHQ8L3RoPlxuXHRcdFx0PG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIG1vZGVsLmhlYWRlcjsgbGV0IGkgPSBpbmRleFwiPlxuXHRcdFx0XHQ8dGhcblx0XHRcdFx0XHQqbmdJZj1cImNvbHVtbiAmJiBjb2x1bW4udmlzaWJsZVwiXG5cdFx0XHRcdFx0W25nU3R5bGVdPVwiY29sdW1uLnN0eWxlXCJcblx0XHRcdFx0XHRjZHNUYWJsZUhlYWRDZWxsXG5cdFx0XHRcdFx0c2NvcGU9XCJjb2xcIlxuXHRcdFx0XHRcdFtjbGFzc109XCJjb2x1bW4uY2xhc3NOYW1lXCJcblx0XHRcdFx0XHRbc29ydGFibGVdPVwic29ydGFibGVcIlxuXHRcdFx0XHRcdFtza2VsZXRvbl09XCJza2VsZXRvblwiXG5cdFx0XHRcdFx0W2lkXT1cIm1vZGVsLmdldElkKGkpXCJcblx0XHRcdFx0XHRbY29sdW1uXT1cImNvbHVtblwiXG5cdFx0XHRcdFx0W2ZpbHRlclRpdGxlXT1cImdldEZpbHRlclRpdGxlKClcIlxuXHRcdFx0XHRcdFthdHRyLmNvbHNwYW5dPVwiY29sdW1uLmNvbFNwYW5cIlxuXHRcdFx0XHRcdFthdHRyLnJvd3NwYW5dPVwiY29sdW1uLnJvd1NwYW5cIlxuXHRcdFx0XHRcdChzb3J0KT1cInNvcnQuZW1pdChpKVwiPlxuXHRcdFx0XHQ8L3RoPlxuXHRcdFx0PC9uZy1jb250YWluZXI+XG5cdFx0XHQ8dGggKm5nSWY9XCIhc2tlbGV0b24gJiYgc3RpY2t5SGVhZGVyICYmIHNjcm9sbGJhcldpZHRoXCJcblx0XHRcdFx0c2NvcGU9XCJjb2xcIlxuXHRcdFx0XHRbbmdTdHlsZV09XCJ7J3dpZHRoJzogc2Nyb2xsYmFyV2lkdGggKyAncHgnLCAncGFkZGluZyc6IDAsICdib3JkZXInOiAwfVwiPlxuXHRcdFx0XHQ8IS0tXG5cdFx0XHRcdFx0U2Nyb2xsYmFyIHB1c2hlcyBib2R5IHRvIHRoZSBsZWZ0IHNvIHRoaXMgaGVhZGVyIGNvbHVtbiBpcyBhZGRlZCB0byBwdXNoXG5cdFx0XHRcdFx0dGhlIHRpdGxlIGJhciB0aGUgc2FtZSBhbW91bnQgYW5kIGtlZXAgdGhlIGhlYWRlciBhbmQgYm9keSBjb2x1bW5zIGFsaWduZWQuXG5cdFx0XHRcdC0tPlxuXHRcdFx0PC90aD5cblx0XHQ8L3RyPlxuXHQ8L25nLWNvbnRhaW5lcj5cblx0PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuXHRgLFxuXHRzdHlsZXM6IFtgXG5cdFx0LmNkcy0tdGFibGUtZXhwYW5kLXYyIHtcblx0XHRcdHBhZGRpbmctbGVmdDogMi41cmVtO1xuXHRcdH1cblx0YF1cbn0pXG5leHBvcnQgY2xhc3MgVGFibGVIZWFkIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cdEBJbnB1dCgpIG1vZGVsOiBUYWJsZU1vZGVsO1xuXG5cdEBJbnB1dCgpIHNob3dTZWxlY3Rpb25Db2x1bW4gPSB0cnVlO1xuXG5cdEBJbnB1dCgpIGVuYWJsZVNpbmdsZVNlbGVjdCA9IGZhbHNlO1xuXG5cdEBJbnB1dCgpIHNlbGVjdEFsbENoZWNrYm94U29tZVNlbGVjdGVkID0gZmFsc2U7XG5cblx0QElucHV0KCkgc2VsZWN0QWxsQ2hlY2tib3ggPSBmYWxzZTtcblxuXHRASW5wdXQoKSBza2VsZXRvbiA9IGZhbHNlO1xuXG5cdEBJbnB1dCgpIHN0aWNreUhlYWRlciA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBTZXR0aW5nIHNvcnRhYmxlIHRvIGZhbHNlIHdpbGwgZGlzYWJsZSBhbGwgaGVhZGVycyBpbmNsdWRpbmcgaGVhZGVycyB3aGljaCBhcmUgc29ydGFibGUuIElzIGlzXG5cdCAqIHBvc3NpYmxlIHRvIHNldCB0aGUgc29ydGFibGUgc3RhdGUgb24gdGhlIGhlYWRlciBpdGVtIHRvIGRpc2FibGUvZW5hYmxlIHNvcnRpbmcgZm9yIG9ubHkgc29tZSBoZWFkZXJzLlxuXHQgKi9cblx0QElucHV0KCkgc29ydGFibGUgPSB0cnVlO1xuXG5cdEBJbnB1dCgpXG5cdHNldCBjaGVja2JveEhlYWRlckxhYmVsKHZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLl9jaGVja2JveEhlYWRlckxhYmVsLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXG5cdGdldCBjaGVja2JveEhlYWRlckxhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGVja2JveEhlYWRlckxhYmVsLnZhbHVlO1xuXHR9XG5cblx0QElucHV0KClcblx0c2V0IHNvcnREZXNjZW5kaW5nTGFiZWwodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX3NvcnREZXNjZW5kaW5nTGFiZWwub3ZlcnJpZGUodmFsdWUpO1xuXHR9XG5cblx0Z2V0IHNvcnREZXNjZW5kaW5nTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvcnREZXNjZW5kaW5nTGFiZWwudmFsdWU7XG5cdH1cblxuXHRASW5wdXQoKVxuXHRzZXQgc29ydEFzY2VuZGluZ0xhYmVsKHZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLl9zb3J0QXNjZW5kaW5nTGFiZWwub3ZlcnJpZGUodmFsdWUpO1xuXHR9XG5cblx0Z2V0IHNvcnRBc2NlbmRpbmdMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc29ydEFzY2VuZGluZ0xhYmVsLnZhbHVlO1xuXHR9XG5cblx0QElucHV0KClcblx0c2V0IGZpbHRlclRpdGxlKHZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLl9maWx0ZXJUaXRsZS5vdmVycmlkZSh2YWx1ZSk7XG5cdH1cblxuXHRnZXQgZmlsdGVyVGl0bGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ZpbHRlclRpdGxlLnZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVtaXRzIGFuIGluZGV4IG9mIHRoZSBjb2x1bW4gdGhhdCB3YW50cyB0byBiZSBzb3J0ZWQuXG5cdCAqL1xuXHRAT3V0cHV0KCkgc29ydCA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXHQvKipcblx0ICogRW1pdHMgaWYgYWxsIHJvd3MgYXJlIHNlbGVjdGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0gbW9kZWxcblx0ICovXG5cdEBPdXRwdXQoKSBzZWxlY3RBbGwgPSBuZXcgRXZlbnRFbWl0dGVyPFRhYmxlTW9kZWw+KCk7XG5cdC8qKlxuXHQgKiBFbWl0cyBpZiBhbGwgcm93cyBhcmUgZGVzZWxlY3RlZC5cblx0ICpcblx0ICogQHBhcmFtIG1vZGVsXG5cdCAqL1xuXHRAT3V0cHV0KCkgZGVzZWxlY3RBbGwgPSBuZXcgRXZlbnRFbWl0dGVyPFRhYmxlTW9kZWw+KCk7XG5cblx0cHVibGljIHNjcm9sbGJhcldpZHRoID0gMDtcblxuXHRwcm90ZWN0ZWQgX2NoZWNrYm94SGVhZGVyTGFiZWwgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5DSEVDS0JPWF9IRUFERVJcIik7XG5cdHByb3RlY3RlZCBfc29ydERlc2NlbmRpbmdMYWJlbCA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLlNPUlRfREVTQ0VORElOR1wiKTtcblx0cHJvdGVjdGVkIF9zb3J0QXNjZW5kaW5nTGFiZWwgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5TT1JUX0FTQ0VORElOR1wiKTtcblx0cHJvdGVjdGVkIF9maWx0ZXJUaXRsZSA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLkZJTFRFUlwiKTtcblxuXHRjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgaTE4bjogSTE4bikge31cblxuXHRuZ0FmdGVyVmlld0luaXQoKSB7XG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHR0aGlzLnNjcm9sbGJhcldpZHRoID0gZ2V0U2Nyb2xsYmFyV2lkdGgoKTtcblx0XHR9KTtcblx0fVxuXG5cdG9uU2VsZWN0QWxsQ2hlY2tib3hDaGFuZ2UoKSB7XG5cdFx0aWYgKCF0aGlzLnNlbGVjdEFsbENoZWNrYm94ICYmICF0aGlzLnNlbGVjdEFsbENoZWNrYm94U29tZVNlbGVjdGVkKSB7XG5cdFx0XHR0aGlzLnNlbGVjdEFsbC5lbWl0KHRoaXMubW9kZWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmRlc2VsZWN0QWxsLmVtaXQodGhpcy5tb2RlbCk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0Q2hlY2tib3hIZWFkZXJMYWJlbCgpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuXHRcdHJldHVybiB0aGlzLl9jaGVja2JveEhlYWRlckxhYmVsLnN1YmplY3Q7XG5cdH1cblxuXHRnZXRTb3J0RGVzY2VuZGluZ0xhYmVsKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvcnREZXNjZW5kaW5nTGFiZWwuc3ViamVjdDtcblx0fVxuXG5cdGdldFNvcnRBc2NlbmRpbmdMYWJlbCgpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuXHRcdHJldHVybiB0aGlzLl9zb3J0QXNjZW5kaW5nTGFiZWwuc3ViamVjdDtcblx0fVxuXG5cdGdldEZpbHRlclRpdGxlKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cdFx0cmV0dXJuIHRoaXMuX2ZpbHRlclRpdGxlLnN1YmplY3Q7XG5cdH1cbn1cbiJdfQ==