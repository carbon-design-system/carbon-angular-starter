import { Component, Input, Output, EventEmitter, HostBinding } from "@angular/core";
import { map } from "rxjs/operators";
import * as i0 from "@angular/core";
import * as i1 from "carbon-components-angular/i18n";
import * as i2 from "@angular/common";
import * as i3 from "./table-head-cell-label.directive";
export class TableHeadCell {
    constructor(i18n) {
        this.i18n = i18n;
        this.skeleton = false;
        this.sortable = true;
        /**
         * Notifies that the column should be sorted
         */
        this.sort = new EventEmitter();
        this.theadAction = false;
        this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
        this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
        this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
    }
    set sortDescendingLabel(value) {
        this._sortDescendingLabel.override(value);
    }
    get sortDescendingLabel() {
        return this._sortDescendingLabel.value;
    }
    set sortAscendingLabel(value) {
        this._sortAscendingLabel.override(value);
    }
    get sortAscendingLabel() {
        return this._sortAscendingLabel.value;
    }
    set filterTitle(value) {
        this._filterTitle.override(value);
    }
    get filterTitle() {
        return this._filterTitle.value;
    }
    ngOnChanges() {
        // Since it's not an input, and it touches the view, we're using `ngOnChanges`
        // `get`ters have caused issues in the past with the view updating outside of change detection
        this.theadAction = !!this.column.filterTemplate || this.sort.observers.length > 0;
    }
    getSortDescendingLabel() {
        return this._sortDescendingLabel.subject.pipe(this.sortLabelMap());
    }
    getSortAscendingLabel() {
        return this._sortAscendingLabel.subject.pipe(this.sortLabelMap());
    }
    onClick() {
        if (!this.skeleton) {
            this.sort.emit();
        }
    }
    sortLabelMap() {
        return map((str) => {
            if (this.column.ariaSortLabel) {
                return this.column.ariaSortLabel;
            }
            if (this.column.formatSortLabel) {
                return this.column.formatSortLabel(str, this.column.ariaSortLabel);
            }
            return `${this.column.data} - ${str}`;
        });
    }
}
TableHeadCell.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TableHeadCell, deps: [{ token: i1.I18n }], target: i0.ɵɵFactoryTarget.Component });
TableHeadCell.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: TableHeadCell, selector: "[cdsTableHeadCell], [ibmTableHeadCell]", inputs: { column: "column", skeleton: "skeleton", sortable: "sortable", sortDescendingLabel: "sortDescendingLabel", sortAscendingLabel: "sortAscendingLabel", filterTitle: "filterTitle" }, outputs: { sort: "sort" }, host: { properties: { "class.thead_action": "this.theadAction" } }, usesOnChanges: true, ngImport: i0, template: `
		<button
			class="cds--table-sort"
			*ngIf="sortable && this.sort.observers.length > 0 && column.sortable"
			[attr.aria-label]="(column.sorted && column.ascending ? getSortDescendingLabel() : getSortAscendingLabel()) | async"
			aria-live="polite"
			[ngClass]="{
				'cds--table-sort--active': column.sorted,
				'cds--table-sort--descending': column.ascending
			}"
			(click)="onClick()">
			<span
				class="cds--table-sort__flex"
				[title]="column.title"
				tabindex="-1">
				<div *ngIf="!skeleton && !column.template" cdsTableHeadCellLabel>
					{{column.data}}
				</div>
				<ng-template
					*ngIf="!skeleton && column.template"
					[ngTemplateOutlet]="column.template"
					[ngTemplateOutletContext]="{data: column.data}">
				</ng-template>
				<svg
					*ngIf="!skeleton"
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					xmlns="http://www.w3.org/2000/svg"
					class="cds--table-sort__icon"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M12.3 9.3l-3.8 3.8V1h-1v12.1L3.7 9.3 3 10l5 5 5-5z"></path>
				</svg>
				<svg
					*ngIf="!skeleton"
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					xmlns="http://www.w3.org/2000/svg"
					class="cds--table-sort__icon-unsorted"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M13.8 10.3L12 12.1V2h-1v10.1l-1.8-1.8-.7.7 3 3 3-3zM4.5 2l-3 3 .7.7L4 3.9V14h1V3.9l1.8 1.8.7-.7z"></path>
				</svg>
			</span>
		</button>
		<div
			class="cds--table-header-label"
			*ngIf="!skeleton && this.sort.observers.length === 0 || (this.sort.observers.length > 0 && !column.sortable) || !sortable">
			<span *ngIf="!column.template" [title]="column.data">
				<ng-container *ngIf="!skeleton">
					{{column.data}}
				</ng-container>
			</span>
			<ng-template
				[ngTemplateOutlet]="column.template" [ngTemplateOutletContext]="{data: column.data}">
			</ng-template>
		</div>
	`, isInline: true, dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i3.TableHeadCellLabel, selector: "[cdsTableHeadCellLabel], [ibmTableHeadCellLabel]" }, { kind: "pipe", type: i2.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TableHeadCell, decorators: [{
            type: Component,
            args: [{
                    // tslint:disable-next-line: component-selector
                    selector: "[cdsTableHeadCell], [ibmTableHeadCell]",
                    template: `
		<button
			class="cds--table-sort"
			*ngIf="sortable && this.sort.observers.length > 0 && column.sortable"
			[attr.aria-label]="(column.sorted && column.ascending ? getSortDescendingLabel() : getSortAscendingLabel()) | async"
			aria-live="polite"
			[ngClass]="{
				'cds--table-sort--active': column.sorted,
				'cds--table-sort--descending': column.ascending
			}"
			(click)="onClick()">
			<span
				class="cds--table-sort__flex"
				[title]="column.title"
				tabindex="-1">
				<div *ngIf="!skeleton && !column.template" cdsTableHeadCellLabel>
					{{column.data}}
				</div>
				<ng-template
					*ngIf="!skeleton && column.template"
					[ngTemplateOutlet]="column.template"
					[ngTemplateOutletContext]="{data: column.data}">
				</ng-template>
				<svg
					*ngIf="!skeleton"
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					xmlns="http://www.w3.org/2000/svg"
					class="cds--table-sort__icon"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M12.3 9.3l-3.8 3.8V1h-1v12.1L3.7 9.3 3 10l5 5 5-5z"></path>
				</svg>
				<svg
					*ngIf="!skeleton"
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					xmlns="http://www.w3.org/2000/svg"
					class="cds--table-sort__icon-unsorted"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M13.8 10.3L12 12.1V2h-1v10.1l-1.8-1.8-.7.7 3 3 3-3zM4.5 2l-3 3 .7.7L4 3.9V14h1V3.9l1.8 1.8.7-.7z"></path>
				</svg>
			</span>
		</button>
		<div
			class="cds--table-header-label"
			*ngIf="!skeleton && this.sort.observers.length === 0 || (this.sort.observers.length > 0 && !column.sortable) || !sortable">
			<span *ngIf="!column.template" [title]="column.data">
				<ng-container *ngIf="!skeleton">
					{{column.data}}
				</ng-container>
			</span>
			<ng-template
				[ngTemplateOutlet]="column.template" [ngTemplateOutletContext]="{data: column.data}">
			</ng-template>
		</div>
	`
                }]
        }], ctorParameters: function () { return [{ type: i1.I18n }]; }, propDecorators: { column: [{
                type: Input
            }], skeleton: [{
                type: Input
            }], sortable: [{
                type: Input
            }], sortDescendingLabel: [{
                type: Input
            }], sortAscendingLabel: [{
                type: Input
            }], filterTitle: [{
                type: Input
            }], sort: [{
                type: Output
            }], theadAction: [{
                type: HostBinding,
                args: ["class.thead_action"]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtaGVhZC1jZWxsLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy90YWJsZS9oZWFkL3RhYmxlLWhlYWQtY2VsbC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNOLFNBQVMsRUFDVCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFDWixXQUFXLEVBRVgsTUFBTSxlQUFlLENBQUM7QUFHdkIsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7OztBQXVFckMsTUFBTSxPQUFPLGFBQWE7SUE2Q3pCLFlBQXNCLElBQVU7UUFBVixTQUFJLEdBQUosSUFBSSxDQUFNO1FBMUN2QixhQUFRLEdBQUcsS0FBSyxDQUFDO1FBRWpCLGFBQVEsR0FBRyxJQUFJLENBQUM7UUE2QnpCOztXQUVHO1FBQ08sU0FBSSxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFFRCxnQkFBVyxHQUFHLEtBQUssQ0FBQztRQUU3Qyx5QkFBb0IsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1FBQ3pFLHdCQUFtQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLHNCQUFzQixDQUFDLENBQUM7UUFDdkUsaUJBQVksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUU5QixDQUFDO0lBdENyQyxJQUNJLG1CQUFtQixDQUFDLEtBQWtDO1FBQ3pELElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVELElBQUksbUJBQW1CO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLEtBQUssQ0FBQztJQUN4QyxDQUFDO0lBRUQsSUFDSSxrQkFBa0IsQ0FBQyxLQUFrQztRQUN4RCxJQUFJLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFRCxJQUFJLGtCQUFrQjtRQUNyQixPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUM7SUFDdkMsQ0FBQztJQUVELElBQ0ksV0FBVyxDQUFDLEtBQWtDO1FBQ2pELElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRCxJQUFJLFdBQVc7UUFDZCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDO0lBQ2hDLENBQUM7SUFlRCxXQUFXO1FBQ1YsOEVBQThFO1FBQzlFLDhGQUE4RjtRQUM5RixJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ25GLENBQUM7SUFFRCxzQkFBc0I7UUFDckIsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQztJQUNwRSxDQUFDO0lBRUQscUJBQXFCO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUM7SUFDbkUsQ0FBQztJQUVELE9BQU87UUFDTixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1NBQ2pCO0lBQ0YsQ0FBQztJQUVTLFlBQVk7UUFDckIsT0FBTyxHQUFHLENBQUMsQ0FBQyxHQUFXLEVBQUUsRUFBRTtZQUMxQixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFO2dCQUM5QixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDO2FBQ2pDO1lBQ0QsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsRUFBRTtnQkFDaEMsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQzthQUNuRTtZQUNELE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztRQUN2QyxDQUFDLENBQUMsQ0FBQztJQUNKLENBQUM7OzBHQTdFVyxhQUFhOzhGQUFiLGFBQWEsOFhBakVmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUErRFQ7MkZBRVcsYUFBYTtrQkFwRXpCLFNBQVM7bUJBQUM7b0JBQ1YsK0NBQStDO29CQUMvQyxRQUFRLEVBQUUsd0NBQXdDO29CQUNsRCxRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQStEVDtpQkFDRDsyRkFFUyxNQUFNO3NCQUFkLEtBQUs7Z0JBRUcsUUFBUTtzQkFBaEIsS0FBSztnQkFFRyxRQUFRO3NCQUFoQixLQUFLO2dCQUdGLG1CQUFtQjtzQkFEdEIsS0FBSztnQkFVRixrQkFBa0I7c0JBRHJCLEtBQUs7Z0JBVUYsV0FBVztzQkFEZCxLQUFLO2dCQVlJLElBQUk7c0JBQWIsTUFBTTtnQkFFNEIsV0FBVztzQkFBN0MsV0FBVzt1QkFBQyxvQkFBb0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRDb21wb25lbnQsXG5cdElucHV0LFxuXHRPdXRwdXQsXG5cdEV2ZW50RW1pdHRlcixcblx0SG9zdEJpbmRpbmcsXG5cdE9uQ2hhbmdlc1xufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT3BlcmF0b3JGdW5jdGlvbiB9IGZyb20gXCJyeGpzXCI7XG5pbXBvcnQgeyBJMThuLCBPdmVycmlkYWJsZSB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2kxOG5cIjtcbmltcG9ydCB7IG1hcCB9IGZyb20gXCJyeGpzL29wZXJhdG9yc1wiO1xuaW1wb3J0IHsgVGFibGVIZWFkZXJJdGVtIH0gZnJvbSBcIi4uL3RhYmxlLWhlYWRlci1pdGVtLmNsYXNzXCI7XG5cbkBDb21wb25lbnQoe1xuXHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGNvbXBvbmVudC1zZWxlY3RvclxuXHRzZWxlY3RvcjogXCJbY2RzVGFibGVIZWFkQ2VsbF0sIFtpYm1UYWJsZUhlYWRDZWxsXVwiLFxuXHR0ZW1wbGF0ZTogYFxuXHRcdDxidXR0b25cblx0XHRcdGNsYXNzPVwiY2RzLS10YWJsZS1zb3J0XCJcblx0XHRcdCpuZ0lmPVwic29ydGFibGUgJiYgdGhpcy5zb3J0Lm9ic2VydmVycy5sZW5ndGggPiAwICYmIGNvbHVtbi5zb3J0YWJsZVwiXG5cdFx0XHRbYXR0ci5hcmlhLWxhYmVsXT1cIihjb2x1bW4uc29ydGVkICYmIGNvbHVtbi5hc2NlbmRpbmcgPyBnZXRTb3J0RGVzY2VuZGluZ0xhYmVsKCkgOiBnZXRTb3J0QXNjZW5kaW5nTGFiZWwoKSkgfCBhc3luY1wiXG5cdFx0XHRhcmlhLWxpdmU9XCJwb2xpdGVcIlxuXHRcdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0XHQnY2RzLS10YWJsZS1zb3J0LS1hY3RpdmUnOiBjb2x1bW4uc29ydGVkLFxuXHRcdFx0XHQnY2RzLS10YWJsZS1zb3J0LS1kZXNjZW5kaW5nJzogY29sdW1uLmFzY2VuZGluZ1xuXHRcdFx0fVwiXG5cdFx0XHQoY2xpY2spPVwib25DbGljaygpXCI+XG5cdFx0XHQ8c3BhblxuXHRcdFx0XHRjbGFzcz1cImNkcy0tdGFibGUtc29ydF9fZmxleFwiXG5cdFx0XHRcdFt0aXRsZV09XCJjb2x1bW4udGl0bGVcIlxuXHRcdFx0XHR0YWJpbmRleD1cIi0xXCI+XG5cdFx0XHRcdDxkaXYgKm5nSWY9XCIhc2tlbGV0b24gJiYgIWNvbHVtbi50ZW1wbGF0ZVwiIGNkc1RhYmxlSGVhZENlbGxMYWJlbD5cblx0XHRcdFx0XHR7e2NvbHVtbi5kYXRhfX1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxuZy10ZW1wbGF0ZVxuXHRcdFx0XHRcdCpuZ0lmPVwiIXNrZWxldG9uICYmIGNvbHVtbi50ZW1wbGF0ZVwiXG5cdFx0XHRcdFx0W25nVGVtcGxhdGVPdXRsZXRdPVwiY29sdW1uLnRlbXBsYXRlXCJcblx0XHRcdFx0XHRbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwie2RhdGE6IGNvbHVtbi5kYXRhfVwiPlxuXHRcdFx0XHQ8L25nLXRlbXBsYXRlPlxuXHRcdFx0XHQ8c3ZnXG5cdFx0XHRcdFx0Km5nSWY9XCIhc2tlbGV0b25cIlxuXHRcdFx0XHRcdGZvY3VzYWJsZT1cImZhbHNlXCJcblx0XHRcdFx0XHRwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwieE1pZFlNaWQgbWVldFwiXG5cdFx0XHRcdFx0c3R5bGU9XCJ3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1wiXG5cdFx0XHRcdFx0eG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG5cdFx0XHRcdFx0Y2xhc3M9XCJjZHMtLXRhYmxlLXNvcnRfX2ljb25cIlxuXHRcdFx0XHRcdHdpZHRoPVwiMTZcIlxuXHRcdFx0XHRcdGhlaWdodD1cIjE2XCJcblx0XHRcdFx0XHR2aWV3Qm94PVwiMCAwIDE2IDE2XCJcblx0XHRcdFx0XHRhcmlhLWhpZGRlbj1cInRydWVcIj5cblx0XHRcdFx0XHQ8cGF0aCBkPVwiTTEyLjMgOS4zbC0zLjggMy44VjFoLTF2MTIuMUwzLjcgOS4zIDMgMTBsNSA1IDUtNXpcIj48L3BhdGg+XG5cdFx0XHRcdDwvc3ZnPlxuXHRcdFx0XHQ8c3ZnXG5cdFx0XHRcdFx0Km5nSWY9XCIhc2tlbGV0b25cIlxuXHRcdFx0XHRcdGZvY3VzYWJsZT1cImZhbHNlXCJcblx0XHRcdFx0XHRwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwieE1pZFlNaWQgbWVldFwiXG5cdFx0XHRcdFx0c3R5bGU9XCJ3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1wiXG5cdFx0XHRcdFx0eG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG5cdFx0XHRcdFx0Y2xhc3M9XCJjZHMtLXRhYmxlLXNvcnRfX2ljb24tdW5zb3J0ZWRcIlxuXHRcdFx0XHRcdHdpZHRoPVwiMTZcIlxuXHRcdFx0XHRcdGhlaWdodD1cIjE2XCJcblx0XHRcdFx0XHR2aWV3Qm94PVwiMCAwIDE2IDE2XCJcblx0XHRcdFx0XHRhcmlhLWhpZGRlbj1cInRydWVcIj5cblx0XHRcdFx0XHQ8cGF0aCBkPVwiTTEzLjggMTAuM0wxMiAxMi4xVjJoLTF2MTAuMWwtMS44LTEuOC0uNy43IDMgMyAzLTN6TTQuNSAybC0zIDMgLjcuN0w0IDMuOVYxNGgxVjMuOWwxLjggMS44LjctLjd6XCI+PC9wYXRoPlxuXHRcdFx0XHQ8L3N2Zz5cblx0XHRcdDwvc3Bhbj5cblx0XHQ8L2J1dHRvbj5cblx0XHQ8ZGl2XG5cdFx0XHRjbGFzcz1cImNkcy0tdGFibGUtaGVhZGVyLWxhYmVsXCJcblx0XHRcdCpuZ0lmPVwiIXNrZWxldG9uICYmIHRoaXMuc29ydC5vYnNlcnZlcnMubGVuZ3RoID09PSAwIHx8ICh0aGlzLnNvcnQub2JzZXJ2ZXJzLmxlbmd0aCA+IDAgJiYgIWNvbHVtbi5zb3J0YWJsZSkgfHwgIXNvcnRhYmxlXCI+XG5cdFx0XHQ8c3BhbiAqbmdJZj1cIiFjb2x1bW4udGVtcGxhdGVcIiBbdGl0bGVdPVwiY29sdW1uLmRhdGFcIj5cblx0XHRcdFx0PG5nLWNvbnRhaW5lciAqbmdJZj1cIiFza2VsZXRvblwiPlxuXHRcdFx0XHRcdHt7Y29sdW1uLmRhdGF9fVxuXHRcdFx0XHQ8L25nLWNvbnRhaW5lcj5cblx0XHRcdDwvc3Bhbj5cblx0XHRcdDxuZy10ZW1wbGF0ZVxuXHRcdFx0XHRbbmdUZW1wbGF0ZU91dGxldF09XCJjb2x1bW4udGVtcGxhdGVcIiBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwie2RhdGE6IGNvbHVtbi5kYXRhfVwiPlxuXHRcdFx0PC9uZy10ZW1wbGF0ZT5cblx0XHQ8L2Rpdj5cblx0YFxufSlcbmV4cG9ydCBjbGFzcyBUYWJsZUhlYWRDZWxsIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcblx0QElucHV0KCkgY29sdW1uOiBUYWJsZUhlYWRlckl0ZW07XG5cblx0QElucHV0KCkgc2tlbGV0b24gPSBmYWxzZTtcblxuXHRASW5wdXQoKSBzb3J0YWJsZSA9IHRydWU7XG5cblx0QElucHV0KClcblx0c2V0IHNvcnREZXNjZW5kaW5nTGFiZWwodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX3NvcnREZXNjZW5kaW5nTGFiZWwub3ZlcnJpZGUodmFsdWUpO1xuXHR9XG5cblx0Z2V0IHNvcnREZXNjZW5kaW5nTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvcnREZXNjZW5kaW5nTGFiZWwudmFsdWU7XG5cdH1cblxuXHRASW5wdXQoKVxuXHRzZXQgc29ydEFzY2VuZGluZ0xhYmVsKHZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLl9zb3J0QXNjZW5kaW5nTGFiZWwub3ZlcnJpZGUodmFsdWUpO1xuXHR9XG5cblx0Z2V0IHNvcnRBc2NlbmRpbmdMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc29ydEFzY2VuZGluZ0xhYmVsLnZhbHVlO1xuXHR9XG5cblx0QElucHV0KClcblx0c2V0IGZpbHRlclRpdGxlKHZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLl9maWx0ZXJUaXRsZS5vdmVycmlkZSh2YWx1ZSk7XG5cdH1cblxuXHRnZXQgZmlsdGVyVGl0bGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ZpbHRlclRpdGxlLnZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIE5vdGlmaWVzIHRoYXQgdGhlIGNvbHVtbiBzaG91bGQgYmUgc29ydGVkXG5cdCAqL1xuXHRAT3V0cHV0KCkgc29ydCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy50aGVhZF9hY3Rpb25cIikgdGhlYWRBY3Rpb24gPSBmYWxzZTtcblxuXHRwcm90ZWN0ZWQgX3NvcnREZXNjZW5kaW5nTGFiZWwgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5TT1JUX0RFU0NFTkRJTkdcIik7XG5cdHByb3RlY3RlZCBfc29ydEFzY2VuZGluZ0xhYmVsID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuU09SVF9BU0NFTkRJTkdcIik7XG5cdHByb3RlY3RlZCBfZmlsdGVyVGl0bGUgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5GSUxURVJcIik7XG5cblx0Y29uc3RydWN0b3IocHJvdGVjdGVkIGkxOG46IEkxOG4pIHsgfVxuXG5cdG5nT25DaGFuZ2VzKCkge1xuXHRcdC8vIFNpbmNlIGl0J3Mgbm90IGFuIGlucHV0LCBhbmQgaXQgdG91Y2hlcyB0aGUgdmlldywgd2UncmUgdXNpbmcgYG5nT25DaGFuZ2VzYFxuXHRcdC8vIGBnZXRgdGVycyBoYXZlIGNhdXNlZCBpc3N1ZXMgaW4gdGhlIHBhc3Qgd2l0aCB0aGUgdmlldyB1cGRhdGluZyBvdXRzaWRlIG9mIGNoYW5nZSBkZXRlY3Rpb25cblx0XHR0aGlzLnRoZWFkQWN0aW9uID0gISF0aGlzLmNvbHVtbi5maWx0ZXJUZW1wbGF0ZSB8fCB0aGlzLnNvcnQub2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XG5cdH1cblxuXHRnZXRTb3J0RGVzY2VuZGluZ0xhYmVsKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvcnREZXNjZW5kaW5nTGFiZWwuc3ViamVjdC5waXBlKHRoaXMuc29ydExhYmVsTWFwKCkpO1xuXHR9XG5cblx0Z2V0U29ydEFzY2VuZGluZ0xhYmVsKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvcnRBc2NlbmRpbmdMYWJlbC5zdWJqZWN0LnBpcGUodGhpcy5zb3J0TGFiZWxNYXAoKSk7XG5cdH1cblxuXHRvbkNsaWNrKCkge1xuXHRcdGlmICghdGhpcy5za2VsZXRvbikge1xuXHRcdFx0dGhpcy5zb3J0LmVtaXQoKTtcblx0XHR9XG5cdH1cblxuXHRwcm90ZWN0ZWQgc29ydExhYmVsTWFwKCk6IE9wZXJhdG9yRnVuY3Rpb248c3RyaW5nLCBzdHJpbmc+IHtcblx0XHRyZXR1cm4gbWFwKChzdHI6IHN0cmluZykgPT4ge1xuXHRcdFx0aWYgKHRoaXMuY29sdW1uLmFyaWFTb3J0TGFiZWwpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29sdW1uLmFyaWFTb3J0TGFiZWw7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5jb2x1bW4uZm9ybWF0U29ydExhYmVsKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbHVtbi5mb3JtYXRTb3J0TGFiZWwoc3RyLCB0aGlzLmNvbHVtbi5hcmlhU29ydExhYmVsKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBgJHt0aGlzLmNvbHVtbi5kYXRhfSAtICR7c3RyfWA7XG5cdFx0fSk7XG5cdH1cbn1cbiJdfQ==