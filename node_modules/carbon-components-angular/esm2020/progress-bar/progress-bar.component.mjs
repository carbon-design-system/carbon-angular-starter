import { Component, HostBinding, Input, TemplateRef } from "@angular/core";
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "carbon-components-angular/icon";
export class ProgressBar {
    constructor() {
        this.id = `progress-bar-${ProgressBar.progressBarCounter++}`;
        this.helperId = `progress-bar-helper-${ProgressBar.progressBarCounter}`;
        /**
         * Maximum value
         */
        this.max = 100;
        /**
         * Alignment variant of the progress bar, default is `default`
         */
        this.type = "default";
        /**
         * Current status of the progress bar, default is `active`
         */
        this.status = "active";
        /**
         * Size of the progress bar, default is `big`
         */
        this.size = "big";
        this.defaultClass = true;
        this._value = undefined;
    }
    /**
     * Current value
     */
    set value(num) {
        this._value = num;
        // Validate number
        if (num > this.max) {
            this._value = this.max;
        }
        if (num < 0) {
            this._value = 0;
        }
        // Set values based on current state
        if (this.isError) {
            this._value = 0;
        }
        else if (this.isFinished) {
            this._value = this.max;
        }
    }
    get value() {
        return this._value;
    }
    get percentage() {
        return `scaleX(${this.value / this.max})`;
    }
    // Size
    get bigBar() {
        return this.size === "big";
    }
    get smallBar() {
        return this.size === "small";
    }
    // Type
    get defaultType() {
        return this.type === "default";
    }
    get indentedType() {
        return this.type === "indented";
    }
    get inlineType() {
        return this.type === "inline";
    }
    // Status
    get isFinished() {
        return this.status === "finished";
    }
    get isError() {
        return this.status === "error";
    }
    get indeterminate() {
        return this.value === undefined && !this.isFinished && !this.isError;
    }
    isTemplate(value) {
        return value instanceof TemplateRef;
    }
}
ProgressBar.progressBarCounter = 0;
ProgressBar.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ProgressBar, deps: [], target: i0.ɵɵFactoryTarget.Component });
ProgressBar.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: ProgressBar, selector: "cds-progress-bar, ibm-progress-bar", inputs: { value: "value", id: "id", label: "label", helperText: "helperText", max: "max", type: "type", status: "status", size: "size" }, host: { properties: { "class.cds--progress-bar--big": "this.bigBar", "class.cds--progress-bar--small": "this.smallBar", "class.cds--progress-bar--default": "this.defaultType", "class.cds--progress-bar--indented": "this.indentedType", "class.cds--progress-bar--inline": "this.inlineType", "class.cds--progress-bar--finished": "this.isFinished", "class.cds--progress-bar--error": "this.isError", "class.cds--progress-bar--indeterminate": "this.indeterminate", "class.cds--progress-bar": "this.defaultClass" } }, ngImport: i0, template: `
		<div
			*ngIf="label"
			class="cds--progress-bar__label"
			[id]="id">
			<span class="cds--progress-bar__label-text">
				<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
				<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
			</span>
			<svg
				*ngIf="isFinished"
				fill="currentColor"
				cdsIcon="checkmark--filled"
				class="cds--progress-bar__status-icon">
			</svg>
			<svg
				*ngIf="isError"
				fill="currentColor"
				cdsIcon="error--filled"
				class="cds--progress-bar__status-icon">
			</svg>
		</div>
		<div
			class="cds--progress-bar__track"
			role="progressbar"
			[attr.aria-invalid]="isError"
			[attr.labelledby]="id"
			[attr.describedby]="helperText ? helperId: null"
			[attr.aria-valuemin]="!indeterminate ? 0 : null"
			[attr.aria-valuemax]="!indeterminate ? max : null"
			[attr.aria-valuenow]="!indeterminate ? value : null">
			<div
				class="cds--progress-bar__bar"
				[ngStyle]="{
					'transform': !isFinished && !isError ? percentage : null
				}">
			</div>
		</div>
		<div
			[id]="helperId"
			*ngIf="helperText"
			class="cds--progress-bar__helper-text">
			<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
			<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
		</div>
	`, isInline: true, dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i2.IconDirective, selector: "[cdsIcon], [ibmIcon]", inputs: ["ibmIcon", "cdsIcon", "size", "title", "ariaLabel", "ariaLabelledBy", "ariaHidden", "isFocusable"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ProgressBar, decorators: [{
            type: Component,
            args: [{
                    selector: "cds-progress-bar, ibm-progress-bar",
                    template: `
		<div
			*ngIf="label"
			class="cds--progress-bar__label"
			[id]="id">
			<span class="cds--progress-bar__label-text">
				<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
				<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
			</span>
			<svg
				*ngIf="isFinished"
				fill="currentColor"
				cdsIcon="checkmark--filled"
				class="cds--progress-bar__status-icon">
			</svg>
			<svg
				*ngIf="isError"
				fill="currentColor"
				cdsIcon="error--filled"
				class="cds--progress-bar__status-icon">
			</svg>
		</div>
		<div
			class="cds--progress-bar__track"
			role="progressbar"
			[attr.aria-invalid]="isError"
			[attr.labelledby]="id"
			[attr.describedby]="helperText ? helperId: null"
			[attr.aria-valuemin]="!indeterminate ? 0 : null"
			[attr.aria-valuemax]="!indeterminate ? max : null"
			[attr.aria-valuenow]="!indeterminate ? value : null">
			<div
				class="cds--progress-bar__bar"
				[ngStyle]="{
					'transform': !isFinished && !isError ? percentage : null
				}">
			</div>
		</div>
		<div
			[id]="helperId"
			*ngIf="helperText"
			class="cds--progress-bar__helper-text">
			<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
			<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
		</div>
	`
                }]
        }], propDecorators: { value: [{
                type: Input
            }], bigBar: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--big"]
            }], smallBar: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--small"]
            }], defaultType: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--default"]
            }], indentedType: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--indented"]
            }], inlineType: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--inline"]
            }], isFinished: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--finished"]
            }], isError: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--error"]
            }], indeterminate: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--indeterminate"]
            }], id: [{
                type: Input
            }], label: [{
                type: Input
            }], helperText: [{
                type: Input
            }], max: [{
                type: Input
            }], type: [{
                type: Input
            }], status: [{
                type: Input
            }], size: [{
                type: Input
            }], defaultClass: [{
                type: HostBinding,
                args: ["class.cds--progress-bar"]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3MtYmFyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wcm9ncmVzcy1iYXIvcHJvZ3Jlc3MtYmFyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULFdBQVcsRUFDWCxLQUFLLEVBQ0wsV0FBVyxFQUNYLE1BQU0sZUFBZSxDQUFDOzs7O0FBbUR2QixNQUFNLE9BQU8sV0FBVztJQWpEeEI7UUEwR1UsT0FBRSxHQUFHLGdCQUFnQixXQUFXLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxDQUFDO1FBQ2pFLGFBQVEsR0FBRyx1QkFBdUIsV0FBVyxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFTbkU7O1dBRUc7UUFDTSxRQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ25COztXQUVHO1FBQ00sU0FBSSxHQUFzQyxTQUFTLENBQUM7UUFDN0Q7O1dBRUc7UUFDTSxXQUFNLEdBQW9DLFFBQVEsQ0FBQztRQUM1RDs7V0FFRztRQUNNLFNBQUksR0FBb0IsS0FBSyxDQUFDO1FBRUMsaUJBQVksR0FBRyxJQUFJLENBQUM7UUFDcEQsV0FBTSxHQUFHLFNBQVMsQ0FBQztLQUszQjtJQXpGQTs7T0FFRztJQUNILElBQWEsS0FBSyxDQUFDLEdBQXVCO1FBQ3pDLElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDO1FBQ2xCLGtCQUFrQjtRQUNsQixJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ25CLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztTQUN2QjtRQUNELElBQUksR0FBRyxHQUFHLENBQUMsRUFBRTtZQUNaLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1NBQ2hCO1FBQ0Qsb0NBQW9DO1FBQ3BDLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNqQixJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztTQUNoQjthQUFNLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUMzQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7U0FDdkI7SUFDRixDQUFDO0lBRUQsSUFBSSxLQUFLO1FBQ1IsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3BCLENBQUM7SUFFRCxJQUFJLFVBQVU7UUFDYixPQUFPLFVBQVUsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDM0MsQ0FBQztJQUNELE9BQU87SUFDUCxJQUFpRCxNQUFNO1FBQ3RELE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxLQUFLLENBQUM7SUFDNUIsQ0FBQztJQUNELElBQW1ELFFBQVE7UUFDMUQsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQztJQUM5QixDQUFDO0lBQ0QsT0FBTztJQUNQLElBQXFELFdBQVc7UUFDL0QsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLFNBQVMsQ0FBQztJQUNoQyxDQUFDO0lBQ0QsSUFBc0QsWUFBWTtRQUNqRSxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssVUFBVSxDQUFDO0lBQ2pDLENBQUM7SUFDRCxJQUFvRCxVQUFVO1FBQzdELE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLENBQUM7SUFDL0IsQ0FBQztJQUNELFNBQVM7SUFDVCxJQUFzRCxVQUFVO1FBQy9ELE9BQU8sSUFBSSxDQUFDLE1BQU0sS0FBSyxVQUFVLENBQUM7SUFDbkMsQ0FBQztJQUNELElBQW1ELE9BQU87UUFDekQsT0FBTyxJQUFJLENBQUMsTUFBTSxLQUFLLE9BQU8sQ0FBQztJQUNoQyxDQUFDO0lBQ0QsSUFBMkQsYUFBYTtRQUN2RSxPQUFPLElBQUksQ0FBQyxLQUFLLEtBQUssU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7SUFDdEUsQ0FBQztJQWlDRCxVQUFVLENBQUMsS0FBSztRQUNmLE9BQU8sS0FBSyxZQUFZLFdBQVcsQ0FBQztJQUNyQyxDQUFDOztBQWxDTSw4QkFBa0IsR0FBRyxDQUFDLENBQUM7d0dBdkRsQixXQUFXOzRGQUFYLFdBQVcsa3RCQS9DYjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBNkNUOzJGQUVXLFdBQVc7a0JBakR2QixTQUFTO21CQUFDO29CQUNWLFFBQVEsRUFBRSxvQ0FBb0M7b0JBQzlDLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBNkNUO2lCQUNEOzhCQUthLEtBQUs7c0JBQWpCLEtBQUs7Z0JBeUIyQyxNQUFNO3NCQUF0RCxXQUFXO3VCQUFDLDhCQUE4QjtnQkFHUSxRQUFRO3NCQUExRCxXQUFXO3VCQUFDLGdDQUFnQztnQkFJUSxXQUFXO3NCQUEvRCxXQUFXO3VCQUFDLGtDQUFrQztnQkFHTyxZQUFZO3NCQUFqRSxXQUFXO3VCQUFDLG1DQUFtQztnQkFHSSxVQUFVO3NCQUE3RCxXQUFXO3VCQUFDLGlDQUFpQztnQkFJUSxVQUFVO3NCQUEvRCxXQUFXO3VCQUFDLG1DQUFtQztnQkFHRyxPQUFPO3NCQUF6RCxXQUFXO3VCQUFDLGdDQUFnQztnQkFHYyxhQUFhO3NCQUF2RSxXQUFXO3VCQUFDLHdDQUF3QztnQkFLNUMsRUFBRTtzQkFBVixLQUFLO2dCQUtHLEtBQUs7c0JBQWIsS0FBSztnQkFJRyxVQUFVO3NCQUFsQixLQUFLO2dCQUlHLEdBQUc7c0JBQVgsS0FBSztnQkFJRyxJQUFJO3NCQUFaLEtBQUs7Z0JBSUcsTUFBTTtzQkFBZCxLQUFLO2dCQUlHLElBQUk7c0JBQVosS0FBSztnQkFFa0MsWUFBWTtzQkFBbkQsV0FBVzt1QkFBQyx5QkFBeUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRDb21wb25lbnQsXG5cdEhvc3RCaW5kaW5nLFxuXHRJbnB1dCxcblx0VGVtcGxhdGVSZWZcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcblxuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImNkcy1wcm9ncmVzcy1iYXIsIGlibS1wcm9ncmVzcy1iYXJcIixcblx0dGVtcGxhdGU6IGBcblx0XHQ8ZGl2XG5cdFx0XHQqbmdJZj1cImxhYmVsXCJcblx0XHRcdGNsYXNzPVwiY2RzLS1wcm9ncmVzcy1iYXJfX2xhYmVsXCJcblx0XHRcdFtpZF09XCJpZFwiPlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJjZHMtLXByb2dyZXNzLWJhcl9fbGFiZWwtdGV4dFwiPlxuXHRcdFx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzVGVtcGxhdGUobGFiZWwpXCI+e3tsYWJlbH19PC9uZy1jb250YWluZXI+XG5cdFx0XHRcdDxuZy10ZW1wbGF0ZSAqbmdJZj1cImlzVGVtcGxhdGUobGFiZWwpXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwibGFiZWxcIj48L25nLXRlbXBsYXRlPlxuXHRcdFx0PC9zcGFuPlxuXHRcdFx0PHN2Z1xuXHRcdFx0XHQqbmdJZj1cImlzRmluaXNoZWRcIlxuXHRcdFx0XHRmaWxsPVwiY3VycmVudENvbG9yXCJcblx0XHRcdFx0Y2RzSWNvbj1cImNoZWNrbWFyay0tZmlsbGVkXCJcblx0XHRcdFx0Y2xhc3M9XCJjZHMtLXByb2dyZXNzLWJhcl9fc3RhdHVzLWljb25cIj5cblx0XHRcdDwvc3ZnPlxuXHRcdFx0PHN2Z1xuXHRcdFx0XHQqbmdJZj1cImlzRXJyb3JcIlxuXHRcdFx0XHRmaWxsPVwiY3VycmVudENvbG9yXCJcblx0XHRcdFx0Y2RzSWNvbj1cImVycm9yLS1maWxsZWRcIlxuXHRcdFx0XHRjbGFzcz1cImNkcy0tcHJvZ3Jlc3MtYmFyX19zdGF0dXMtaWNvblwiPlxuXHRcdFx0PC9zdmc+XG5cdFx0PC9kaXY+XG5cdFx0PGRpdlxuXHRcdFx0Y2xhc3M9XCJjZHMtLXByb2dyZXNzLWJhcl9fdHJhY2tcIlxuXHRcdFx0cm9sZT1cInByb2dyZXNzYmFyXCJcblx0XHRcdFthdHRyLmFyaWEtaW52YWxpZF09XCJpc0Vycm9yXCJcblx0XHRcdFthdHRyLmxhYmVsbGVkYnldPVwiaWRcIlxuXHRcdFx0W2F0dHIuZGVzY3JpYmVkYnldPVwiaGVscGVyVGV4dCA/IGhlbHBlcklkOiBudWxsXCJcblx0XHRcdFthdHRyLmFyaWEtdmFsdWVtaW5dPVwiIWluZGV0ZXJtaW5hdGUgPyAwIDogbnVsbFwiXG5cdFx0XHRbYXR0ci5hcmlhLXZhbHVlbWF4XT1cIiFpbmRldGVybWluYXRlID8gbWF4IDogbnVsbFwiXG5cdFx0XHRbYXR0ci5hcmlhLXZhbHVlbm93XT1cIiFpbmRldGVybWluYXRlID8gdmFsdWUgOiBudWxsXCI+XG5cdFx0XHQ8ZGl2XG5cdFx0XHRcdGNsYXNzPVwiY2RzLS1wcm9ncmVzcy1iYXJfX2JhclwiXG5cdFx0XHRcdFtuZ1N0eWxlXT1cIntcblx0XHRcdFx0XHQndHJhbnNmb3JtJzogIWlzRmluaXNoZWQgJiYgIWlzRXJyb3IgPyBwZXJjZW50YWdlIDogbnVsbFxuXHRcdFx0XHR9XCI+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0XHQ8ZGl2XG5cdFx0XHRbaWRdPVwiaGVscGVySWRcIlxuXHRcdFx0Km5nSWY9XCJoZWxwZXJUZXh0XCJcblx0XHRcdGNsYXNzPVwiY2RzLS1wcm9ncmVzcy1iYXJfX2hlbHBlci10ZXh0XCI+XG5cdFx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzVGVtcGxhdGUoaGVscGVyVGV4dClcIj57e2hlbHBlclRleHR9fTwvbmctY29udGFpbmVyPlxuXHRcdFx0PG5nLXRlbXBsYXRlICpuZ0lmPVwiaXNUZW1wbGF0ZShoZWxwZXJUZXh0KVwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImhlbHBlclRleHRcIj48L25nLXRlbXBsYXRlPlxuXHRcdDwvZGl2PlxuXHRgXG59KVxuZXhwb3J0IGNsYXNzIFByb2dyZXNzQmFyIHtcblx0LyoqXG5cdCAqIEN1cnJlbnQgdmFsdWVcblx0ICovXG5cdEBJbnB1dCgpIHNldCB2YWx1ZShudW06IG51bWJlciB8IHVuZGVmaW5lZCkge1xuXHRcdHRoaXMuX3ZhbHVlID0gbnVtO1xuXHRcdC8vIFZhbGlkYXRlIG51bWJlclxuXHRcdGlmIChudW0gPiB0aGlzLm1heCkge1xuXHRcdFx0dGhpcy5fdmFsdWUgPSB0aGlzLm1heDtcblx0XHR9XG5cdFx0aWYgKG51bSA8IDApIHtcblx0XHRcdHRoaXMuX3ZhbHVlID0gMDtcblx0XHR9XG5cdFx0Ly8gU2V0IHZhbHVlcyBiYXNlZCBvbiBjdXJyZW50IHN0YXRlXG5cdFx0aWYgKHRoaXMuaXNFcnJvcikge1xuXHRcdFx0dGhpcy5fdmFsdWUgPSAwO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5pc0ZpbmlzaGVkKSB7XG5cdFx0XHR0aGlzLl92YWx1ZSA9IHRoaXMubWF4O1xuXHRcdH1cblx0fVxuXG5cdGdldCB2YWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWU7XG5cdH1cblxuXHRnZXQgcGVyY2VudGFnZSgpIHtcblx0XHRyZXR1cm4gYHNjYWxlWCgke3RoaXMudmFsdWUgLyB0aGlzLm1heH0pYDtcblx0fVxuXHQvLyBTaXplXG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tcHJvZ3Jlc3MtYmFyLS1iaWdcIikgZ2V0IGJpZ0JhcigpIHtcblx0XHRyZXR1cm4gdGhpcy5zaXplID09PSBcImJpZ1wiO1xuXHR9XG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tcHJvZ3Jlc3MtYmFyLS1zbWFsbFwiKSBnZXQgc21hbGxCYXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2l6ZSA9PT0gXCJzbWFsbFwiO1xuXHR9XG5cdC8vIFR5cGVcblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MuY2RzLS1wcm9ncmVzcy1iYXItLWRlZmF1bHRcIikgZ2V0IGRlZmF1bHRUeXBlKCkge1xuXHRcdHJldHVybiB0aGlzLnR5cGUgPT09IFwiZGVmYXVsdFwiO1xuXHR9XG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tcHJvZ3Jlc3MtYmFyLS1pbmRlbnRlZFwiKSBnZXQgaW5kZW50ZWRUeXBlKCkge1xuXHRcdHJldHVybiB0aGlzLnR5cGUgPT09IFwiaW5kZW50ZWRcIjtcblx0fVxuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy5jZHMtLXByb2dyZXNzLWJhci0taW5saW5lXCIpIGdldCBpbmxpbmVUeXBlKCkge1xuXHRcdHJldHVybiB0aGlzLnR5cGUgPT09IFwiaW5saW5lXCI7XG5cdH1cblx0Ly8gU3RhdHVzXG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tcHJvZ3Jlc3MtYmFyLS1maW5pc2hlZFwiKSBnZXQgaXNGaW5pc2hlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5zdGF0dXMgPT09IFwiZmluaXNoZWRcIjtcblx0fVxuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy5jZHMtLXByb2dyZXNzLWJhci0tZXJyb3JcIikgZ2V0IGlzRXJyb3IoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RhdHVzID09PSBcImVycm9yXCI7XG5cdH1cblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MuY2RzLS1wcm9ncmVzcy1iYXItLWluZGV0ZXJtaW5hdGVcIikgZ2V0IGluZGV0ZXJtaW5hdGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhdGhpcy5pc0ZpbmlzaGVkICYmICF0aGlzLmlzRXJyb3I7XG5cdH1cblx0c3RhdGljIHByb2dyZXNzQmFyQ291bnRlciA9IDA7XG5cblx0QElucHV0KCkgaWQgPSBgcHJvZ3Jlc3MtYmFyLSR7UHJvZ3Jlc3NCYXIucHJvZ3Jlc3NCYXJDb3VudGVyKyt9YDtcblx0aGVscGVySWQgPSBgcHJvZ3Jlc3MtYmFyLWhlbHBlci0ke1Byb2dyZXNzQmFyLnByb2dyZXNzQmFyQ291bnRlcn1gO1xuXHQvKipcblx0ICogRGVzY3JpcHRpb24gb2YgdGhlIHByb2dyZXNzIGJhclxuXHQgKi9cblx0QElucHV0KCkgbGFiZWw6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cdC8qKlxuXHQgKiBDdXJyZW50IHByb2dyZXNzIHRleHR1YWwgcmVwcmVzZW50YXRpb25cblx0ICovXG5cdEBJbnB1dCgpIGhlbHBlclRleHQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cdC8qKlxuXHQgKiBNYXhpbXVtIHZhbHVlXG5cdCAqL1xuXHRASW5wdXQoKSBtYXggPSAxMDA7XG5cdC8qKlxuXHQgKiBBbGlnbm1lbnQgdmFyaWFudCBvZiB0aGUgcHJvZ3Jlc3MgYmFyLCBkZWZhdWx0IGlzIGBkZWZhdWx0YFxuXHQgKi9cblx0QElucHV0KCkgdHlwZTogXCJkZWZhdWx0XCIgfCBcImlubGluZVwiIHwgXCJpbmRlbnRlZFwiID0gXCJkZWZhdWx0XCI7XG5cdC8qKlxuXHQgKiBDdXJyZW50IHN0YXR1cyBvZiB0aGUgcHJvZ3Jlc3MgYmFyLCBkZWZhdWx0IGlzIGBhY3RpdmVgXG5cdCAqL1xuXHRASW5wdXQoKSBzdGF0dXM6IFwiYWN0aXZlXCIgfCBcImZpbmlzaGVkXCIgfCBcImVycm9yXCIgPSBcImFjdGl2ZVwiO1xuXHQvKipcblx0ICogU2l6ZSBvZiB0aGUgcHJvZ3Jlc3MgYmFyLCBkZWZhdWx0IGlzIGBiaWdgXG5cdCAqL1xuXHRASW5wdXQoKSBzaXplOiBcInNtYWxsXCIgfCBcImJpZ1wiID0gXCJiaWdcIjtcblxuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy5jZHMtLXByb2dyZXNzLWJhclwiKSBkZWZhdWx0Q2xhc3MgPSB0cnVlO1xuXHRwcml2YXRlIF92YWx1ZSA9IHVuZGVmaW5lZDtcblxuXHRpc1RlbXBsYXRlKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVGVtcGxhdGVSZWY7XG5cdH1cbn1cbiJdfQ==