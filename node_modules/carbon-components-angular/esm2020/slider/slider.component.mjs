import { Component, HostBinding, Input, Output, EventEmitter, ViewChild, TemplateRef, ViewChildren } from "@angular/core";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
import * as i0 from "@angular/core";
import * as i1 from "carbon-components-angular/utils";
import * as i2 from "@angular/common";
/**
 * Used to select from ranges of values. [See here](https://www.carbondesignsystem.com/components/slider/usage) for usage information.
 *
 * [See demo](../../?path=/story/components-slider--advanced)
 *
 * The simplest possible slider usage looks something like:
 *
 * ```html
 *	<cds-slider></cds-slider>
 * ```
 *
 * That will render a slider without labels or alternative value input. Labels can be provided by
 * elements with `[minLabel]` and `[maxLabel]` attributes, and an `input` (may use the `ibmInput` directive) can be supplied
 * for use as an alternative value field.
 *
 * ex:
 *
 * ```html
 * <!-- Full example -->
 * <cds-slider>
 *		<span minLabel>0GB</span>
 *		<span maxLabel>100GB</span>
 *		<input/>
 * </cds-slider>
 *
 * <!-- with just an input -->
 * <cds-slider>
 *		<input/>
 * </cds-slider>
 *
 * <!-- with just one label -->
 * <cds-slider>
 *		<span maxLabel>Maximum</span>
 * </cds-slider>
 * ```
 *
 * Slider supports `NgModel` by default, as well as two way binding to the `value` input.
 */
export class Slider {
    constructor(elementRef, eventService, changeDetection) {
        this.elementRef = elementRef;
        this.eventService = eventService;
        this.changeDetection = changeDetection;
        /** The interval for our range */
        this.step = 1;
        /** Base ID for the slider. The min and max labels get IDs `${this.id}-bottom-range` and `${this.id}-top-range` respectively */
        this.id = `slider-${Slider.count++}`;
        /** Value used to "multiply" the `step` when using arrow keys to select values */
        this.shiftMultiplier = 4;
        /** Set to `true` for a loading slider */
        this.skeleton = false;
        /** Set to `true` for a slider without arrow key interactions. */
        this.disableArrowKeys = false;
        /** Emits every time a new value is selected */
        this.valueChange = new EventEmitter();
        this.hostClass = true;
        this.labelId = `${this.id}-label`;
        this.bottomRangeId = `${this.id}-bottom-range`;
        this.topRangeId = `${this.id}-top-range`;
        this.fractionComplete = 0;
        this.isMouseDown = false;
        this._min = 0;
        this._max = 100;
        this._value = [this.min];
        this._previousValue = [this.min];
        this._disabled = false;
        this._focusedThumbIndex = 0;
        /** Send changes back to the model */
        this.propagateChange = (_) => { };
        /** Callback to notify the model when our input has been touched */
        this.onTouched = () => { };
    }
    /** The lower bound of our range */
    set min(v) {
        if (!v) {
            return;
        }
        this._min = v;
        // force the component to update
        this.value = this.value;
    }
    get min() {
        return this._min;
    }
    /** The upper bound of our range */
    set max(v) {
        if (!v) {
            return;
        }
        this._max = v;
        // force the component to update
        this.value = this.value;
    }
    get max() {
        return this._max;
    }
    /** Set the initial value. Available for two way binding */
    set value(v) {
        if (!v) {
            v = [this.min];
        }
        if (typeof v === "number" || typeof v === "string") {
            v = [Number(v)];
        }
        if (v[0] < this.min) {
            v[0] = this.min;
        }
        if (v[0] > this.max) {
            v[0] = this.max;
        }
        if (this.isRange()) {
            if (this._previousValue[0] !== v[0]) { // left moved
                if (v[0] > v[1] - this.step) {
                    // stop the left handle if surpassing the right one
                    v[0] = v[1] - this.step;
                }
                else if (v[0] > this.max) {
                    v[0] = this.max;
                }
                else if (v[0] < this.min) {
                    v[0] = this.min;
                }
            }
            if (this._previousValue[1] !== v[1]) { // right moved
                if (v[1] > this.max) {
                    v[1] = this.max;
                }
                else if (v[1] < this._value[0] + this.step) {
                    // stop the right handle if surpassing the left one
                    v[1] = this._value[0] + this.step;
                }
                else if (v[1] < this.min) {
                    v[1] = this.min;
                }
            }
        }
        this._previousValue = [...this._value]; // store a copy, enable detection which handle moved
        this._value = [...v]; // triggers change detection when ngModel value is an array (for range)
        if (this.isRange() && this.filledTrack) {
            this.updateTrackRangeWidth();
        }
        else if (this.filledTrack) {
            this.filledTrack.nativeElement.style.transform = `translate(0%, -50%) ${this.scaleX(this.getFractionComplete(v[0]))}`;
        }
        if (this.inputs && this.inputs.length) {
            this.inputs.forEach((input, index) => {
                input.value = this._value[index].toString();
            });
        }
        const valueToEmit = this.isRange() ? v : v[0];
        this.propagateChange(valueToEmit);
        this.valueChange.emit(valueToEmit);
    }
    get value() {
        if (this.isRange()) {
            return this._value;
        }
        return this._value[0];
    }
    /** Disables the range visually and functionally */
    set disabled(v) {
        this._disabled = v;
        // for some reason `this.input` never exists here, so we have to query for it here too
        const inputs = this.getInputs();
        if (inputs && inputs.length > 0) {
            inputs.forEach(input => input.disabled = v);
        }
    }
    get disabled() {
        return this._disabled;
    }
    ngAfterViewInit() {
        // bind mousemove and mouseup to the document so we don't have issues tracking the mouse
        this.eventService.onDocument("mousemove", this.onMouseMove.bind(this));
        this.eventService.onDocument("mouseup", this.onMouseUp.bind(this));
        // apply any values we got from before the view initialized
        this.changeDetection.detectChanges();
        // TODO: ontouchstart/ontouchmove/ontouchend
        // set up the optional input
        this.inputs = this.getInputs();
        if (this.inputs && this.inputs.length > 0) {
            this.inputs.forEach((input, index) => {
                input.type = "number";
                input.classList.add("cds--slider-text-input");
                input.classList.add("cds--text-input");
                input.setAttribute("aria-labelledby", `${this.bottomRangeId} ${this.topRangeId}`);
                input.value = index < this._value.length ? this._value[index].toString() : this.max.toString();
                // bind events on our optional input
                this.eventService.on(input, "change", event => this.onChange(event, index));
                if (index === 0) {
                    this.eventService.on(input, "focus", this.onFocus.bind(this));
                }
            });
        }
    }
    trackThumbsBy(index, item) {
        return index;
    }
    /** Register a change propagation function for `ControlValueAccessor` */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /** Register a callback to notify when our input has been touched */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /** Receives a value from the model */
    writeValue(v) {
        this.value = v;
    }
    /**
     * Returns the amount of "completeness" of a value as a fraction of the total track width
     */
    getFractionComplete(value) {
        if (!this.track) {
            return 0;
        }
        const trackWidth = this.track.nativeElement.getBoundingClientRect().width;
        return this.convertToPx(value) / trackWidth;
    }
    /** Helper function to return the CSS transform `scaleX` function */
    scaleX(complete) {
        return `scaleX(${complete})`;
    }
    /** Converts a given px value to a "real" value in our range */
    convertToValue(pxAmount) {
        // basic concept borrowed from carbon-components
        // https://github.com/carbon-design-system/carbon/blob/43bf3abdc2f8bdaa38aa84e0f733adde1e1e8894/src/components/slider/slider.js#L147-L151
        const range = this.max - this.min;
        const trackWidth = this.track.nativeElement.getBoundingClientRect().width;
        const unrounded = pxAmount / trackWidth;
        const rounded = Math.round((range * unrounded) / this.step) * this.step;
        return rounded + this.min;
    }
    /** Converts a given "real" value to a px value we can update the view with */
    convertToPx(value) {
        if (!this.track) {
            return 0;
        }
        const trackWidth = this.track.nativeElement.getBoundingClientRect().width;
        if (value >= this.max) {
            return trackWidth;
        }
        if (value <= this.min) {
            return 0;
        }
        // account for value shifting by subtracting min from value and max
        return Math.round(trackWidth * ((value - this.min) / (this.max - this.min)));
    }
    /**
     * Increments the value by the step value, or the step value multiplied by the `multiplier` argument.
     *
     * @argument multiplier Defaults to `1`, multiplied with the step value.
     */
    incrementValue(multiplier = 1, index = 0) {
        this._value[index] = this._value[index] + (this.step * multiplier);
        this.value = this.value; // run the setter
    }
    /**
     * Decrements the value by the step value, or the step value multiplied by the `multiplier` argument.
     *
     * @argument multiplier Defaults to `1`, multiplied with the step value.
     */
    decrementValue(multiplier = 1, index = 0) {
        this._value[index] = this._value[index] - (this.step * multiplier);
        this.value = this.value; // run the setter
    }
    /**
     * Determines if the slider is in range mode.
     */
    isRange() {
        return this._value.length > 1;
    }
    /**
     * Range mode only.
     * Updates the track width to span from the low thumb to the high thumb
     */
    updateTrackRangeWidth() {
        const fraction = this.getFractionComplete(this._value[0]);
        const fraction2 = this.getFractionComplete(this._value[1]);
        this.filledTrack.nativeElement.style.transform = `translate(${fraction * 100}%, -50%) ${this.scaleX(fraction2 - fraction)}`;
    }
    /** Change handler for the optional input */
    onChange(event, index) {
        this._value[index] = Number(event.target.value);
        this.value = this.value;
    }
    /** Handles clicks on the range track, and setting the value to it's "real" equivalent */
    onClick(event) {
        if (this.disabled) {
            return;
        }
        const trackLeft = this.track.nativeElement.getBoundingClientRect().left;
        this._value[0] = this.convertToValue(event.clientX - trackLeft);
        this.value = this.value;
    }
    /** Focus handler for the optional input */
    onFocus({ target }) {
        target.select();
    }
    /** Mouse move handler. Responsible for updating the value and visual selection based on mouse movement */
    onMouseMove(event) {
        if (this.disabled || !this.isMouseDown) {
            return;
        }
        const track = this.track.nativeElement.getBoundingClientRect();
        let value;
        if (event.clientX - track.left <= track.width
            && event.clientX - track.left >= 0) {
            value = this.convertToValue(event.clientX - track.left);
        }
        // if the mouse is beyond the max, set the value to `max`
        if (event.clientX - track.left > track.width) {
            value = this.max;
        }
        // if the mouse is below the min, set the value to `min`
        if (event.clientX - track.left < 0) {
            value = this.min;
        }
        if (value !== undefined) {
            this._value[this._focusedThumbIndex] = value;
            this.value = this.value;
        }
    }
    /**
     * Enables the `onMouseMove` handler
     *
     * @param {boolean} thumb If true then `thumb` is clicked down, otherwise `thumb2` is clicked down.
     */
    onMouseDown(event, index = 0) {
        event.preventDefault();
        if (this.disabled) {
            return;
        }
        this._focusedThumbIndex = index;
        this.thumbs.toArray()[index].nativeElement.focus();
        this.isMouseDown = true;
    }
    /** Disables the `onMouseMove` handler */
    onMouseUp() {
        this.isMouseDown = false;
    }
    /**
     * Calls `incrementValue` for ArrowRight and ArrowUp, `decrementValue` for ArrowLeft and ArrowDown.
     *
     * @param {boolean} thumb If true then `thumb` is pressed down, otherwise `thumb2` is pressed down.
     */
    onKeyDown(event, index = 0) {
        if (this.disableArrowKeys) {
            return;
        }
        const multiplier = event.shiftKey ? this.shiftMultiplier : 1;
        if (event.key === "ArrowLeft" || event.key === "ArrowDown") {
            this.decrementValue(multiplier, index);
            this.thumbs.toArray()[index].nativeElement.focus();
            event.preventDefault();
        }
        else if (event.key === "ArrowRight" || event.key === "ArrowUp") {
            this.incrementValue(multiplier, index);
            this.thumbs.toArray()[index].nativeElement.focus();
            event.preventDefault();
        }
    }
    isTemplate(value) {
        return value instanceof TemplateRef;
    }
    /** Get optional input fields */
    getInputs() {
        return this.elementRef.nativeElement.querySelectorAll("input:not([type=range])");
    }
}
/** Used to generate unique IDs */
Slider.count = 0;
Slider.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Slider, deps: [{ token: i0.ElementRef }, { token: i1.EventService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
Slider.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: Slider, selector: "cds-slider, ibm-slider", inputs: { min: "min", max: "max", step: "step", value: "value", id: "id", shiftMultiplier: "shiftMultiplier", skeleton: "skeleton", label: "label", disableArrowKeys: "disableArrowKeys", disabled: "disabled" }, outputs: { valueChange: "valueChange" }, host: { properties: { "class.cds--form-item": "this.hostClass" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: Slider,
            multi: true
        }
    ], viewQueries: [{ propertyName: "track", first: true, predicate: ["track"], descendants: true }, { propertyName: "filledTrack", first: true, predicate: ["filledTrack"], descendants: true }, { propertyName: "range", first: true, predicate: ["range"], descendants: true }, { propertyName: "thumbs", predicate: ["thumbs"], descendants: true }], ngImport: i0, template: `
		<ng-container *ngIf="!skeleton; else skeletonTemplate">
			<label
				*ngIf="label"
				[for]="id"
				[id]="labelId"
				class="cds--label"
				[ngClass]="{'cds--label--disabled': disabled}">
				<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
				<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
			</label>
			<div class="cds--slider-container">
				<label [id]="bottomRangeId" class="cds--slider__range-label">
					<ng-content select="[minLabel]"></ng-content>
				</label>
				<div
					class="cds--slider"
					[ngClass]="{'cds--slider--disabled': disabled}">
					<ng-container *ngIf="!isRange()">
						<div
							#thumbs
							role="slider"
							[id]="id"
							[attr.aria-labelledby]="labelId"
							class="cds--slider__thumb"
							[ngStyle]="{left: getFractionComplete(value) * 100 + '%'}"
							tabindex="0"
							(mousedown)="onMouseDown($event)"
							(keydown)="onKeyDown($event)">
						</div>
					</ng-container>
					<ng-container *ngIf="isRange()">
						<div
							#thumbs
							*ngFor="let thumb of value; let i = index; trackBy: trackThumbsBy"
							role="slider"
							[id]="id + (i > 0 ? '-' + i : '')"
							[attr.aria-labelledby]="labelId"
							class="cds--slider__thumb"
							[ngStyle]="{left: getFractionComplete(thumb) * 100 + '%'}"
							tabindex="0"
							(mousedown)="onMouseDown($event, i)"
							(keydown)="onKeyDown($event, i)">
						</div>
					</ng-container>
					<div
						#track
						class="cds--slider__track"
						(click)="onClick($event)">
					</div>
					<div
						#filledTrack
						class="cds--slider__filled-track">
					</div>
					<input
						#range
						aria-label="slider"
						class="cds--slider__input"
						type="range"
						[step]="step"
						[min]="min"
						[max]="max"
						[value]="value.toString()">
				</div>
				<label [id]="topRangeId" class="cds--slider__range-label">
					<ng-content select="[maxLabel]"></ng-content>
				</label>
				<ng-content select="input"></ng-content>
			</div>
		</ng-container>

		<ng-template #skeletonTemplate>
			<label *ngIf="label" class="cds--label cds--skeleton"></label>
			<div class="cds--slider-container cds--skeleton">
				<span class="cds--slider__range-label"></span>
				<div class="cds--slider">
					<div class="cds--slider__thumb"></div>
					<div class="cds--slider__track"></div>
					<div class="cds--slider__filled-track"></div>
				</div>
				<span class="cds--slider__range-label"></span>
			</div>
		</ng-template>
	`, isInline: true, dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Slider, decorators: [{
            type: Component,
            args: [{
                    selector: "cds-slider, ibm-slider",
                    template: `
		<ng-container *ngIf="!skeleton; else skeletonTemplate">
			<label
				*ngIf="label"
				[for]="id"
				[id]="labelId"
				class="cds--label"
				[ngClass]="{'cds--label--disabled': disabled}">
				<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
				<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
			</label>
			<div class="cds--slider-container">
				<label [id]="bottomRangeId" class="cds--slider__range-label">
					<ng-content select="[minLabel]"></ng-content>
				</label>
				<div
					class="cds--slider"
					[ngClass]="{'cds--slider--disabled': disabled}">
					<ng-container *ngIf="!isRange()">
						<div
							#thumbs
							role="slider"
							[id]="id"
							[attr.aria-labelledby]="labelId"
							class="cds--slider__thumb"
							[ngStyle]="{left: getFractionComplete(value) * 100 + '%'}"
							tabindex="0"
							(mousedown)="onMouseDown($event)"
							(keydown)="onKeyDown($event)">
						</div>
					</ng-container>
					<ng-container *ngIf="isRange()">
						<div
							#thumbs
							*ngFor="let thumb of value; let i = index; trackBy: trackThumbsBy"
							role="slider"
							[id]="id + (i > 0 ? '-' + i : '')"
							[attr.aria-labelledby]="labelId"
							class="cds--slider__thumb"
							[ngStyle]="{left: getFractionComplete(thumb) * 100 + '%'}"
							tabindex="0"
							(mousedown)="onMouseDown($event, i)"
							(keydown)="onKeyDown($event, i)">
						</div>
					</ng-container>
					<div
						#track
						class="cds--slider__track"
						(click)="onClick($event)">
					</div>
					<div
						#filledTrack
						class="cds--slider__filled-track">
					</div>
					<input
						#range
						aria-label="slider"
						class="cds--slider__input"
						type="range"
						[step]="step"
						[min]="min"
						[max]="max"
						[value]="value.toString()">
				</div>
				<label [id]="topRangeId" class="cds--slider__range-label">
					<ng-content select="[maxLabel]"></ng-content>
				</label>
				<ng-content select="input"></ng-content>
			</div>
		</ng-container>

		<ng-template #skeletonTemplate>
			<label *ngIf="label" class="cds--label cds--skeleton"></label>
			<div class="cds--slider-container cds--skeleton">
				<span class="cds--slider__range-label"></span>
				<div class="cds--slider">
					<div class="cds--slider__thumb"></div>
					<div class="cds--slider__track"></div>
					<div class="cds--slider__filled-track"></div>
				</div>
				<span class="cds--slider__range-label"></span>
			</div>
		</ng-template>
	`,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: Slider,
                            multi: true
                        }
                    ]
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.EventService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { min: [{
                type: Input
            }], max: [{
                type: Input
            }], step: [{
                type: Input
            }], value: [{
                type: Input
            }], id: [{
                type: Input
            }], shiftMultiplier: [{
                type: Input
            }], skeleton: [{
                type: Input
            }], label: [{
                type: Input
            }], disableArrowKeys: [{
                type: Input
            }], disabled: [{
                type: Input
            }], valueChange: [{
                type: Output
            }], hostClass: [{
                type: HostBinding,
                args: ["class.cds--form-item"]
            }], thumbs: [{
                type: ViewChildren,
                args: ["thumbs"]
            }], track: [{
                type: ViewChild,
                args: ["track"]
            }], filledTrack: [{
                type: ViewChild,
                args: ["filledTrack"]
            }], range: [{
                type: ViewChild,
                args: ["range"]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zbGlkZXIvc2xpZGVyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULFdBQVcsRUFDWCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFFWixTQUFTLEVBRVQsV0FBVyxFQUNYLFlBQVksRUFHWixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXdCLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7QUFHekU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FxQ0c7QUErRkgsTUFBTSxPQUFPLE1BQU07SUE4SWxCLFlBQ1csVUFBc0IsRUFDdEIsWUFBMEIsRUFDNUIsZUFBa0M7UUFGaEMsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN0QixpQkFBWSxHQUFaLFlBQVksQ0FBYztRQUM1QixvQkFBZSxHQUFmLGVBQWUsQ0FBbUI7UUF4SDNDLGlDQUFpQztRQUN4QixTQUFJLEdBQUcsQ0FBQyxDQUFDO1FBc0VsQiwrSEFBK0g7UUFDdEgsT0FBRSxHQUFHLFVBQVUsTUFBTSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7UUFDekMsaUZBQWlGO1FBQ3hFLG9CQUFlLEdBQUcsQ0FBQyxDQUFDO1FBQzdCLHlDQUF5QztRQUNoQyxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBRzFCLGlFQUFpRTtRQUN4RCxxQkFBZ0IsR0FBRyxLQUFLLENBQUM7UUFjbEMsK0NBQStDO1FBQ3JDLGdCQUFXLEdBQW9DLElBQUksWUFBWSxFQUFFLENBQUM7UUFDdkMsY0FBUyxHQUFHLElBQUksQ0FBQztRQU8vQyxZQUFPLEdBQUcsR0FBRyxJQUFJLENBQUMsRUFBRSxRQUFRLENBQUM7UUFDN0Isa0JBQWEsR0FBRyxHQUFHLElBQUksQ0FBQyxFQUFFLGVBQWUsQ0FBQztRQUMxQyxlQUFVLEdBQUcsR0FB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QUFXO3NCQUFwQyxTQUFTO3VCQUFDLGFBQWE7Z0JBQ0osS0FBSztzQkFBeEIsU0FBUzt1QkFBQyxPQUFPIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0Q29tcG9uZW50LFxuXHRIb3N0QmluZGluZyxcblx0SW5wdXQsXG5cdE91dHB1dCxcblx0RXZlbnRFbWl0dGVyLFxuXHRBZnRlclZpZXdJbml0LFxuXHRWaWV3Q2hpbGQsXG5cdEVsZW1lbnRSZWYsXG5cdFRlbXBsYXRlUmVmLFxuXHRWaWV3Q2hpbGRyZW4sXG5cdFF1ZXJ5TGlzdCxcblx0Q2hhbmdlRGV0ZWN0b3JSZWZcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xuaW1wb3J0IHsgRXZlbnRTZXJ2aWNlIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvdXRpbHNcIjtcblxuLyoqXG4gKiBVc2VkIHRvIHNlbGVjdCBmcm9tIHJhbmdlcyBvZiB2YWx1ZXMuIFtTZWUgaGVyZV0oaHR0cHM6Ly93d3cuY2FyYm9uZGVzaWduc3lzdGVtLmNvbS9jb21wb25lbnRzL3NsaWRlci91c2FnZSkgZm9yIHVzYWdlIGluZm9ybWF0aW9uLlxuICpcbiAqIFtTZWUgZGVtb10oLi4vLi4vP3BhdGg9L3N0b3J5L2NvbXBvbmVudHMtc2xpZGVyLS1hZHZhbmNlZClcbiAqXG4gKiBUaGUgc2ltcGxlc3QgcG9zc2libGUgc2xpZGVyIHVzYWdlIGxvb2tzIHNvbWV0aGluZyBsaWtlOlxuICpcbiAqIGBgYGh0bWxcbiAqXHQ8Y2RzLXNsaWRlcj48L2Nkcy1zbGlkZXI+XG4gKiBgYGBcbiAqXG4gKiBUaGF0IHdpbGwgcmVuZGVyIGEgc2xpZGVyIHdpdGhvdXQgbGFiZWxzIG9yIGFsdGVybmF0aXZlIHZhbHVlIGlucHV0LiBMYWJlbHMgY2FuIGJlIHByb3ZpZGVkIGJ5XG4gKiBlbGVtZW50cyB3aXRoIGBbbWluTGFiZWxdYCBhbmQgYFttYXhMYWJlbF1gIGF0dHJpYnV0ZXMsIGFuZCBhbiBgaW5wdXRgIChtYXkgdXNlIHRoZSBgaWJtSW5wdXRgIGRpcmVjdGl2ZSkgY2FuIGJlIHN1cHBsaWVkXG4gKiBmb3IgdXNlIGFzIGFuIGFsdGVybmF0aXZlIHZhbHVlIGZpZWxkLlxuICpcbiAqIGV4OlxuICpcbiAqIGBgYGh0bWxcbiAqIDwhLS0gRnVsbCBleGFtcGxlIC0tPlxuICogPGNkcy1zbGlkZXI+XG4gKlx0XHQ8c3BhbiBtaW5MYWJlbD4wR0I8L3NwYW4+XG4gKlx0XHQ8c3BhbiBtYXhMYWJlbD4xMDBHQjwvc3Bhbj5cbiAqXHRcdDxpbnB1dC8+XG4gKiA8L2Nkcy1zbGlkZXI+XG4gKlxuICogPCEtLSB3aXRoIGp1c3QgYW4gaW5wdXQgLS0+XG4gKiA8Y2RzLXNsaWRlcj5cbiAqXHRcdDxpbnB1dC8+XG4gKiA8L2Nkcy1zbGlkZXI+XG4gKlxuICogPCEtLSB3aXRoIGp1c3Qgb25lIGxhYmVsIC0tPlxuICogPGNkcy1zbGlkZXI+XG4gKlx0XHQ8c3BhbiBtYXhMYWJlbD5NYXhpbXVtPC9zcGFuPlxuICogPC9jZHMtc2xpZGVyPlxuICogYGBgXG4gKlxuICogU2xpZGVyIHN1cHBvcnRzIGBOZ01vZGVsYCBieSBkZWZhdWx0LCBhcyB3ZWxsIGFzIHR3byB3YXkgYmluZGluZyB0byB0aGUgYHZhbHVlYCBpbnB1dC5cbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImNkcy1zbGlkZXIsIGlibS1zbGlkZXJcIixcblx0dGVtcGxhdGU6IGBcblx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIXNrZWxldG9uOyBlbHNlIHNrZWxldG9uVGVtcGxhdGVcIj5cblx0XHRcdDxsYWJlbFxuXHRcdFx0XHQqbmdJZj1cImxhYmVsXCJcblx0XHRcdFx0W2Zvcl09XCJpZFwiXG5cdFx0XHRcdFtpZF09XCJsYWJlbElkXCJcblx0XHRcdFx0Y2xhc3M9XCJjZHMtLWxhYmVsXCJcblx0XHRcdFx0W25nQ2xhc3NdPVwieydjZHMtLWxhYmVsLS1kaXNhYmxlZCc6IGRpc2FibGVkfVwiPlxuXHRcdFx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzVGVtcGxhdGUobGFiZWwpXCI+e3tsYWJlbH19PC9uZy1jb250YWluZXI+XG5cdFx0XHRcdDxuZy10ZW1wbGF0ZSAqbmdJZj1cImlzVGVtcGxhdGUobGFiZWwpXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwibGFiZWxcIj48L25nLXRlbXBsYXRlPlxuXHRcdFx0PC9sYWJlbD5cblx0XHRcdDxkaXYgY2xhc3M9XCJjZHMtLXNsaWRlci1jb250YWluZXJcIj5cblx0XHRcdFx0PGxhYmVsIFtpZF09XCJib3R0b21SYW5nZUlkXCIgY2xhc3M9XCJjZHMtLXNsaWRlcl9fcmFuZ2UtbGFiZWxcIj5cblx0XHRcdFx0XHQ8bmctY29udGVudCBzZWxlY3Q9XCJbbWluTGFiZWxdXCI+PC9uZy1jb250ZW50PlxuXHRcdFx0XHQ8L2xhYmVsPlxuXHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0Y2xhc3M9XCJjZHMtLXNsaWRlclwiXG5cdFx0XHRcdFx0W25nQ2xhc3NdPVwieydjZHMtLXNsaWRlci0tZGlzYWJsZWQnOiBkaXNhYmxlZH1cIj5cblx0XHRcdFx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzUmFuZ2UoKVwiPlxuXHRcdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0XHQjdGh1bWJzXG5cdFx0XHRcdFx0XHRcdHJvbGU9XCJzbGlkZXJcIlxuXHRcdFx0XHRcdFx0XHRbaWRdPVwiaWRcIlxuXHRcdFx0XHRcdFx0XHRbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVwibGFiZWxJZFwiXG5cdFx0XHRcdFx0XHRcdGNsYXNzPVwiY2RzLS1zbGlkZXJfX3RodW1iXCJcblx0XHRcdFx0XHRcdFx0W25nU3R5bGVdPVwie2xlZnQ6IGdldEZyYWN0aW9uQ29tcGxldGUodmFsdWUpICogMTAwICsgJyUnfVwiXG5cdFx0XHRcdFx0XHRcdHRhYmluZGV4PVwiMFwiXG5cdFx0XHRcdFx0XHRcdChtb3VzZWRvd24pPVwib25Nb3VzZURvd24oJGV2ZW50KVwiXG5cdFx0XHRcdFx0XHRcdChrZXlkb3duKT1cIm9uS2V5RG93bigkZXZlbnQpXCI+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8L25nLWNvbnRhaW5lcj5cblx0XHRcdFx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiaXNSYW5nZSgpXCI+XG5cdFx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHRcdCN0aHVtYnNcblx0XHRcdFx0XHRcdFx0Km5nRm9yPVwibGV0IHRodW1iIG9mIHZhbHVlOyBsZXQgaSA9IGluZGV4OyB0cmFja0J5OiB0cmFja1RodW1ic0J5XCJcblx0XHRcdFx0XHRcdFx0cm9sZT1cInNsaWRlclwiXG5cdFx0XHRcdFx0XHRcdFtpZF09XCJpZCArIChpID4gMCA/ICctJyArIGkgOiAnJylcIlxuXHRcdFx0XHRcdFx0XHRbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVwibGFiZWxJZFwiXG5cdFx0XHRcdFx0XHRcdGNsYXNzPVwiY2RzLS1zbGlkZXJfX3RodW1iXCJcblx0XHRcdFx0XHRcdFx0W25nU3R5bGVdPVwie2xlZnQ6IGdldEZyYWN0aW9uQ29tcGxldGUodGh1bWIpICogMTAwICsgJyUnfVwiXG5cdFx0XHRcdFx0XHRcdHRhYmluZGV4PVwiMFwiXG5cdFx0XHRcdFx0XHRcdChtb3VzZWRvd24pPVwib25Nb3VzZURvd24oJGV2ZW50LCBpKVwiXG5cdFx0XHRcdFx0XHRcdChrZXlkb3duKT1cIm9uS2V5RG93bigkZXZlbnQsIGkpXCI+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8L25nLWNvbnRhaW5lcj5cblx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHQjdHJhY2tcblx0XHRcdFx0XHRcdGNsYXNzPVwiY2RzLS1zbGlkZXJfX3RyYWNrXCJcblx0XHRcdFx0XHRcdChjbGljayk9XCJvbkNsaWNrKCRldmVudClcIj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHQjZmlsbGVkVHJhY2tcblx0XHRcdFx0XHRcdGNsYXNzPVwiY2RzLS1zbGlkZXJfX2ZpbGxlZC10cmFja1wiPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxpbnB1dFxuXHRcdFx0XHRcdFx0I3JhbmdlXG5cdFx0XHRcdFx0XHRhcmlhLWxhYmVsPVwic2xpZGVyXCJcblx0XHRcdFx0XHRcdGNsYXNzPVwiY2RzLS1zbGlkZXJfX2lucHV0XCJcblx0XHRcdFx0XHRcdHR5cGU9XCJyYW5nZVwiXG5cdFx0XHRcdFx0XHRbc3RlcF09XCJzdGVwXCJcblx0XHRcdFx0XHRcdFttaW5dPVwibWluXCJcblx0XHRcdFx0XHRcdFttYXhdPVwibWF4XCJcblx0XHRcdFx0XHRcdFt2YWx1ZV09XCJ2YWx1ZS50b1N0cmluZygpXCI+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8bGFiZWwgW2lkXT1cInRvcFJhbmdlSWRcIiBjbGFzcz1cImNkcy0tc2xpZGVyX19yYW5nZS1sYWJlbFwiPlxuXHRcdFx0XHRcdDxuZy1jb250ZW50IHNlbGVjdD1cIlttYXhMYWJlbF1cIj48L25nLWNvbnRlbnQ+XG5cdFx0XHRcdDwvbGFiZWw+XG5cdFx0XHRcdDxuZy1jb250ZW50IHNlbGVjdD1cImlucHV0XCI+PC9uZy1jb250ZW50PlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9uZy1jb250YWluZXI+XG5cblx0XHQ8bmctdGVtcGxhdGUgI3NrZWxldG9uVGVtcGxhdGU+XG5cdFx0XHQ8bGFiZWwgKm5nSWY9XCJsYWJlbFwiIGNsYXNzPVwiY2RzLS1sYWJlbCBjZHMtLXNrZWxldG9uXCI+PC9sYWJlbD5cblx0XHRcdDxkaXYgY2xhc3M9XCJjZHMtLXNsaWRlci1jb250YWluZXIgY2RzLS1za2VsZXRvblwiPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImNkcy0tc2xpZGVyX19yYW5nZS1sYWJlbFwiPjwvc3Bhbj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImNkcy0tc2xpZGVyXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImNkcy0tc2xpZGVyX190aHVtYlwiPjwvZGl2PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJjZHMtLXNsaWRlcl9fdHJhY2tcIj48L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY2RzLS1zbGlkZXJfX2ZpbGxlZC10cmFja1wiPjwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJjZHMtLXNsaWRlcl9fcmFuZ2UtbGFiZWxcIj48L3NwYW4+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L25nLXRlbXBsYXRlPlxuXHRgLFxuXHRwcm92aWRlcnM6IFtcblx0XHR7XG5cdFx0XHRwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcblx0XHRcdHVzZUV4aXN0aW5nOiBTbGlkZXIsXG5cdFx0XHRtdWx0aTogdHJ1ZVxuXHRcdH1cblx0XVxufSlcbmV4cG9ydCBjbGFzcyBTbGlkZXIgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG5cdC8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMgKi9cblx0cHJpdmF0ZSBzdGF0aWMgY291bnQgPSAwO1xuXG5cdC8qKiBUaGUgbG93ZXIgYm91bmQgb2Ygb3VyIHJhbmdlICovXG5cdEBJbnB1dCgpIHNldCBtaW4odikge1xuXHRcdGlmICghdikgeyByZXR1cm47IH1cblx0XHR0aGlzLl9taW4gPSB2O1xuXHRcdC8vIGZvcmNlIHRoZSBjb21wb25lbnQgdG8gdXBkYXRlXG5cdFx0dGhpcy52YWx1ZSA9IHRoaXMudmFsdWU7XG5cdH1cblx0Z2V0IG1pbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWluO1xuXHR9XG5cdC8qKiBUaGUgdXBwZXIgYm91bmQgb2Ygb3VyIHJhbmdlICovXG5cdEBJbnB1dCgpIHNldCBtYXgodikge1xuXHRcdGlmICghdikgeyByZXR1cm47IH1cblx0XHR0aGlzLl9tYXggPSB2O1xuXHRcdC8vIGZvcmNlIHRoZSBjb21wb25lbnQgdG8gdXBkYXRlXG5cdFx0dGhpcy52YWx1ZSA9IHRoaXMudmFsdWU7XG5cdH1cblxuXHRnZXQgbWF4KCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXg7XG5cdH1cblx0LyoqIFRoZSBpbnRlcnZhbCBmb3Igb3VyIHJhbmdlICovXG5cdEBJbnB1dCgpIHN0ZXAgPSAxO1xuXHQvKiogU2V0IHRoZSBpbml0aWFsIHZhbHVlLiBBdmFpbGFibGUgZm9yIHR3byB3YXkgYmluZGluZyAqL1xuXHRASW5wdXQoKSBzZXQgdmFsdWUodikge1xuXHRcdGlmICghdikge1xuXHRcdFx0diA9IFt0aGlzLm1pbl07XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2ID0gW051bWJlcih2KV07XG5cdFx0fVxuXG5cdFx0aWYgKHZbMF0gPCB0aGlzLm1pbikge1xuXHRcdFx0dlswXSA9IHRoaXMubWluO1xuXHRcdH1cblxuXHRcdGlmICh2WzBdID4gdGhpcy5tYXgpIHtcblx0XHRcdHZbMF0gPSB0aGlzLm1heDtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5pc1JhbmdlKCkpIHtcblx0XHRcdGlmICh0aGlzLl9wcmV2aW91c1ZhbHVlWzBdICE9PSB2WzBdKSB7IC8vIGxlZnQgbW92ZWRcblx0XHRcdFx0aWYgKHZbMF0gPiB2WzFdIC0gdGhpcy5zdGVwKSB7XG5cdFx0XHRcdFx0Ly8gc3RvcCB0aGUgbGVmdCBoYW5kbGUgaWYgc3VycGFzc2luZyB0aGUgcmlnaHQgb25lXG5cdFx0XHRcdFx0dlswXSA9IHZbMV0gLSB0aGlzLnN0ZXA7XG5cdFx0XHRcdH0gZWxzZSBpZiAodlswXSA+IHRoaXMubWF4KSB7XG5cdFx0XHRcdFx0dlswXSA9IHRoaXMubWF4O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHZbMF0gPCB0aGlzLm1pbikge1xuXHRcdFx0XHRcdHZbMF0gPSB0aGlzLm1pbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fcHJldmlvdXNWYWx1ZVsxXSAhPT0gdlsxXSkgeyAvLyByaWdodCBtb3ZlZFxuXHRcdFx0XHRpZiAodlsxXSA+IHRoaXMubWF4KSB7XG5cdFx0XHRcdFx0dlsxXSA9IHRoaXMubWF4O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHZbMV0gPCB0aGlzLl92YWx1ZVswXSArIHRoaXMuc3RlcCkge1xuXHRcdFx0XHRcdC8vIHN0b3AgdGhlIHJpZ2h0IGhhbmRsZSBpZiBzdXJwYXNzaW5nIHRoZSBsZWZ0IG9uZVxuXHRcdFx0XHRcdHZbMV0gPSB0aGlzLl92YWx1ZVswXSArIHRoaXMuc3RlcDtcblx0XHRcdFx0fSBlbHNlIGlmICh2WzFdIDwgdGhpcy5taW4pIHtcblx0XHRcdFx0XHR2WzFdID0gdGhpcy5taW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9wcmV2aW91c1ZhbHVlID0gWy4uLnRoaXMuX3ZhbHVlXTsgLy8gc3RvcmUgYSBjb3B5LCBlbmFibGUgZGV0ZWN0aW9uIHdoaWNoIGhhbmRsZSBtb3ZlZFxuXHRcdHRoaXMuX3ZhbHVlID0gWy4uLnZdOyAvLyB0cmlnZ2VycyBjaGFuZ2UgZGV0ZWN0aW9uIHdoZW4gbmdNb2RlbCB2YWx1ZSBpcyBhbiBhcnJheSAoZm9yIHJhbmdlKVxuXG5cdFx0aWYgKHRoaXMuaXNSYW5nZSgpICYmIHRoaXMuZmlsbGVkVHJhY2spIHtcblx0XHRcdHRoaXMudXBkYXRlVHJhY2tSYW5nZVdpZHRoKCk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLmZpbGxlZFRyYWNrKSB7XG5cdFx0XHR0aGlzLmZpbGxlZFRyYWNrLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgwJSwgLTUwJSkgJHt0aGlzLnNjYWxlWCh0aGlzLmdldEZyYWN0aW9uQ29tcGxldGUodlswXSkpfWA7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaW5wdXRzICYmIHRoaXMuaW5wdXRzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5pbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGluZGV4KSA9PiB7XG5cdFx0XHRcdGlucHV0LnZhbHVlID0gdGhpcy5fdmFsdWVbaW5kZXhdLnRvU3RyaW5nKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRjb25zdCB2YWx1ZVRvRW1pdCA9IHRoaXMuaXNSYW5nZSgpID8gdiA6IHZbMF07XG5cdFx0dGhpcy5wcm9wYWdhdGVDaGFuZ2UodmFsdWVUb0VtaXQpO1xuXHRcdHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh2YWx1ZVRvRW1pdCk7XG5cdH1cblxuXHRnZXQgdmFsdWUoKSB7XG5cdFx0aWYgKHRoaXMuaXNSYW5nZSgpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdmFsdWU7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl92YWx1ZVswXTtcblx0fVxuXG5cdC8qKiBCYXNlIElEIGZvciB0aGUgc2xpZGVyLiBUaGUgbWluIGFuZCBtYXggbGFiZWxzIGdldCBJRHMgYCR7dGhpcy5pZH0tYm90dG9tLXJhbmdlYCBhbmQgYCR7dGhpcy5pZH0tdG9wLXJhbmdlYCByZXNwZWN0aXZlbHkgKi9cblx0QElucHV0KCkgaWQgPSBgc2xpZGVyLSR7U2xpZGVyLmNvdW50Kyt9YDtcblx0LyoqIFZhbHVlIHVzZWQgdG8gXCJtdWx0aXBseVwiIHRoZSBgc3RlcGAgd2hlbiB1c2luZyBhcnJvdyBrZXlzIHRvIHNlbGVjdCB2YWx1ZXMgKi9cblx0QElucHV0KCkgc2hpZnRNdWx0aXBsaWVyID0gNDtcblx0LyoqIFNldCB0byBgdHJ1ZWAgZm9yIGEgbG9hZGluZyBzbGlkZXIgKi9cblx0QElucHV0KCkgc2tlbGV0b24gPSBmYWxzZTtcblx0LyoqIFNldHMgdGhlIHRleHQgaW5zaWRlIHRoZSBgbGFiZWxgIHRhZyAqL1xuXHRASW5wdXQoKSBsYWJlbDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55Pjtcblx0LyoqIFNldCB0byBgdHJ1ZWAgZm9yIGEgc2xpZGVyIHdpdGhvdXQgYXJyb3cga2V5IGludGVyYWN0aW9ucy4gKi9cblx0QElucHV0KCkgZGlzYWJsZUFycm93S2V5cyA9IGZhbHNlO1xuXHQvKiogRGlzYWJsZXMgdGhlIHJhbmdlIHZpc3VhbGx5IGFuZCBmdW5jdGlvbmFsbHkgKi9cblx0QElucHV0KCkgc2V0IGRpc2FibGVkKHYpIHtcblx0XHR0aGlzLl9kaXNhYmxlZCA9IHY7XG5cdFx0Ly8gZm9yIHNvbWUgcmVhc29uIGB0aGlzLmlucHV0YCBuZXZlciBleGlzdHMgaGVyZSwgc28gd2UgaGF2ZSB0byBxdWVyeSBmb3IgaXQgaGVyZSB0b29cblx0XHRjb25zdCBpbnB1dHMgPSB0aGlzLmdldElucHV0cygpO1xuXHRcdGlmIChpbnB1dHMgJiYgaW5wdXRzLmxlbmd0aCA+IDApIHtcblx0XHRcdGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IGlucHV0LmRpc2FibGVkID0gdik7XG5cdFx0fVxuXHR9XG5cblx0Z2V0IGRpc2FibGVkKCkge1xuXHRcdHJldHVybiB0aGlzLl9kaXNhYmxlZDtcblx0fVxuXHQvKiogRW1pdHMgZXZlcnkgdGltZSBhIG5ldyB2YWx1ZSBpcyBzZWxlY3RlZCAqL1xuXHRAT3V0cHV0KCkgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxudW1iZXIgfCBudW1iZXJbXT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tZm9ybS1pdGVtXCIpIGhvc3RDbGFzcyA9IHRydWU7XG5cdEBWaWV3Q2hpbGRyZW4oXCJ0aHVtYnNcIikgdGh1bWJzOiBRdWVyeUxpc3Q8RWxlbWVudFJlZj47XG5cblx0QFZpZXdDaGlsZChcInRyYWNrXCIpIHRyYWNrOiBFbGVtZW50UmVmO1xuXHRAVmlld0NoaWxkKFwiZmlsbGVkVHJhY2tcIikgZmlsbGVkVHJhY2s6IEVsZW1lbnRSZWY7XG5cdEBWaWV3Q2hpbGQoXCJyYW5nZVwiKSByYW5nZTogRWxlbWVudFJlZjtcblxuXHRwdWJsaWMgbGFiZWxJZCA9IGAke3RoaXMuaWR9LWxhYmVsYDtcblx0cHVibGljIGJvdHRvbVJhbmdlSWQgPSBgJHt0aGlzLmlkfS1ib3R0b20tcmFuZ2VgO1xuXHRwdWJsaWMgdG9wUmFuZ2VJZCA9IGAke3RoaXMuaWR9LXRvcC1yYW5nZWA7XG5cdHB1YmxpYyBmcmFjdGlvbkNvbXBsZXRlID0gMDtcblxuXHRwcm90ZWN0ZWQgaXNNb3VzZURvd24gPSBmYWxzZTtcblx0cHJvdGVjdGVkIGlucHV0czogSFRNTElucHV0RWxlbWVudFtdO1xuXHRwcm90ZWN0ZWQgX21pbiA9IDA7XG5cdHByb3RlY3RlZCBfbWF4ID0gMTAwO1xuXHRwcm90ZWN0ZWQgX3ZhbHVlID0gW3RoaXMubWluXTtcblx0cHJvdGVjdGVkIF9wcmV2aW91c1ZhbHVlID0gW3RoaXMubWluXTtcblx0cHJvdGVjdGVkIF9kaXNhYmxlZCA9IGZhbHNlO1xuXHRwcm90ZWN0ZWQgX2ZvY3VzZWRUaHVtYkluZGV4ID0gMDtcblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRwcm90ZWN0ZWQgZWxlbWVudFJlZjogRWxlbWVudFJlZixcblx0XHRwcm90ZWN0ZWQgZXZlbnRTZXJ2aWNlOiBFdmVudFNlcnZpY2UsXG5cdFx0cHJpdmF0ZSBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdG9yUmVmXG5cdCkge31cblxuXHRuZ0FmdGVyVmlld0luaXQoKSB7XG5cdFx0Ly8gYmluZCBtb3VzZW1vdmUgYW5kIG1vdXNldXAgdG8gdGhlIGRvY3VtZW50IHNvIHdlIGRvbid0IGhhdmUgaXNzdWVzIHRyYWNraW5nIHRoZSBtb3VzZVxuXHRcdHRoaXMuZXZlbnRTZXJ2aWNlLm9uRG9jdW1lbnQoXCJtb3VzZW1vdmVcIiwgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTtcblx0XHR0aGlzLmV2ZW50U2VydmljZS5vbkRvY3VtZW50KFwibW91c2V1cFwiLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcblxuXHRcdC8vIGFwcGx5IGFueSB2YWx1ZXMgd2UgZ290IGZyb20gYmVmb3JlIHRoZSB2aWV3IGluaXRpYWxpemVkXG5cdFx0dGhpcy5jaGFuZ2VEZXRlY3Rpb24uZGV0ZWN0Q2hhbmdlcygpO1xuXG5cdFx0Ly8gVE9ETzogb250b3VjaHN0YXJ0L29udG91Y2htb3ZlL29udG91Y2hlbmRcblxuXHRcdC8vIHNldCB1cCB0aGUgb3B0aW9uYWwgaW5wdXRcblx0XHR0aGlzLmlucHV0cyA9IHRoaXMuZ2V0SW5wdXRzKCk7XG5cdFx0aWYgKHRoaXMuaW5wdXRzICYmIHRoaXMuaW5wdXRzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRoaXMuaW5wdXRzLmZvckVhY2goKGlucHV0LCBpbmRleCkgPT4ge1xuXHRcdFx0XHRpbnB1dC50eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdFx0aW5wdXQuY2xhc3NMaXN0LmFkZChcImNkcy0tc2xpZGVyLXRleHQtaW5wdXRcIik7XG5cdFx0XHRcdGlucHV0LmNsYXNzTGlzdC5hZGQoXCJjZHMtLXRleHQtaW5wdXRcIik7XG5cdFx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiLCBgJHt0aGlzLmJvdHRvbVJhbmdlSWR9ICR7dGhpcy50b3BSYW5nZUlkfWApO1xuXG5cdFx0XHRcdGlucHV0LnZhbHVlID0gaW5kZXggPCB0aGlzLl92YWx1ZS5sZW5ndGggPyB0aGlzLl92YWx1ZVtpbmRleF0udG9TdHJpbmcoKSA6IHRoaXMubWF4LnRvU3RyaW5nKCk7XG5cdFx0XHRcdC8vIGJpbmQgZXZlbnRzIG9uIG91ciBvcHRpb25hbCBpbnB1dFxuXHRcdFx0XHR0aGlzLmV2ZW50U2VydmljZS5vbihpbnB1dCwgXCJjaGFuZ2VcIiwgZXZlbnQgPT4gdGhpcy5vbkNoYW5nZShldmVudCwgaW5kZXgpKTtcblxuXHRcdFx0XHRpZiAoaW5kZXggPT09IDApIHtcblx0XHRcdFx0XHR0aGlzLmV2ZW50U2VydmljZS5vbihpbnB1dCwgXCJmb2N1c1wiLCB0aGlzLm9uRm9jdXMuYmluZCh0aGlzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdHRyYWNrVGh1bWJzQnkoaW5kZXg6IG51bWJlciwgaXRlbTogYW55KSB7XG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9XG5cblx0LyoqIFNlbmQgY2hhbmdlcyBiYWNrIHRvIHRoZSBtb2RlbCAqL1xuXHRwcm9wYWdhdGVDaGFuZ2UgPSAoXzogYW55KSA9PiB7IH07XG5cblx0LyoqIFJlZ2lzdGVyIGEgY2hhbmdlIHByb3BhZ2F0aW9uIGZ1bmN0aW9uIGZvciBgQ29udHJvbFZhbHVlQWNjZXNzb3JgICovXG5cdHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSkge1xuXHRcdHRoaXMucHJvcGFnYXRlQ2hhbmdlID0gZm47XG5cdH1cblxuXHQvKiogQ2FsbGJhY2sgdG8gbm90aWZ5IHRoZSBtb2RlbCB3aGVuIG91ciBpbnB1dCBoYXMgYmVlbiB0b3VjaGVkICovXG5cdG9uVG91Y2hlZDogKCkgPT4gYW55ID0gKCkgPT4geyB9O1xuXG5cdC8qKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIG5vdGlmeSB3aGVuIG91ciBpbnB1dCBoYXMgYmVlbiB0b3VjaGVkICovXG5cdHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpIHtcblx0XHR0aGlzLm9uVG91Y2hlZCA9IGZuO1xuXHR9XG5cblx0LyoqIFJlY2VpdmVzIGEgdmFsdWUgZnJvbSB0aGUgbW9kZWwgKi9cblx0d3JpdGVWYWx1ZSh2OiBhbnkpIHtcblx0XHR0aGlzLnZhbHVlID0gdjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhbW91bnQgb2YgXCJjb21wbGV0ZW5lc3NcIiBvZiBhIHZhbHVlIGFzIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHRyYWNrIHdpZHRoXG5cdCAqL1xuXHRnZXRGcmFjdGlvbkNvbXBsZXRlKHZhbHVlOiBudW1iZXIpIHtcblx0XHRpZiAoIXRoaXMudHJhY2spIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdGNvbnN0IHRyYWNrV2lkdGggPSB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG5cdFx0cmV0dXJuIHRoaXMuY29udmVydFRvUHgodmFsdWUpIC8gdHJhY2tXaWR0aDtcblx0fVxuXG5cdC8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBDU1MgdHJhbnNmb3JtIGBzY2FsZVhgIGZ1bmN0aW9uICovXG5cdHNjYWxlWChjb21wbGV0ZSkge1xuXHRcdHJldHVybiBgc2NhbGVYKCR7Y29tcGxldGV9KWA7XG5cdH1cblxuXHQvKiogQ29udmVydHMgYSBnaXZlbiBweCB2YWx1ZSB0byBhIFwicmVhbFwiIHZhbHVlIGluIG91ciByYW5nZSAqL1xuXHRjb252ZXJ0VG9WYWx1ZShweEFtb3VudCkge1xuXHRcdC8vIGJhc2ljIGNvbmNlcHQgYm9ycm93ZWQgZnJvbSBjYXJib24tY29tcG9uZW50c1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXJib24tZGVzaWduLXN5c3RlbS9jYXJib24vYmxvYi80M2JmM2FiZGMyZjhiZGFhMzhhYTg0ZTBmNzMzYWRkZTFlMWU4ODk0L3NyYy9jb21wb25lbnRzL3NsaWRlci9zbGlkZXIuanMjTDE0Ny1MMTUxXG5cdFx0Y29uc3QgcmFuZ2UgPSB0aGlzLm1heCAtIHRoaXMubWluO1xuXHRcdGNvbnN0IHRyYWNrV2lkdGggPSB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG5cdFx0Y29uc3QgdW5yb3VuZGVkID0gcHhBbW91bnQgLyB0cmFja1dpZHRoO1xuXHRcdGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKChyYW5nZSAqIHVucm91bmRlZCkgLyB0aGlzLnN0ZXApICogdGhpcy5zdGVwO1xuXHRcdHJldHVybiByb3VuZGVkICsgdGhpcy5taW47XG5cdH1cblxuXHQvKiogQ29udmVydHMgYSBnaXZlbiBcInJlYWxcIiB2YWx1ZSB0byBhIHB4IHZhbHVlIHdlIGNhbiB1cGRhdGUgdGhlIHZpZXcgd2l0aCAqL1xuXHRjb252ZXJ0VG9QeCh2YWx1ZSkge1xuXHRcdGlmICghdGhpcy50cmFjaykge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdHJhY2tXaWR0aCA9IHRoaXMudHJhY2submF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblx0XHRpZiAodmFsdWUgPj0gdGhpcy5tYXgpIHtcblx0XHRcdHJldHVybiB0cmFja1dpZHRoO1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSA8PSB0aGlzLm1pbikge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gYWNjb3VudCBmb3IgdmFsdWUgc2hpZnRpbmcgYnkgc3VidHJhY3RpbmcgbWluIGZyb20gdmFsdWUgYW5kIG1heFxuXHRcdHJldHVybiBNYXRoLnJvdW5kKHRyYWNrV2lkdGggKiAoKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKSk7XG5cdH1cblxuXHQvKipcblx0ICogSW5jcmVtZW50cyB0aGUgdmFsdWUgYnkgdGhlIHN0ZXAgdmFsdWUsIG9yIHRoZSBzdGVwIHZhbHVlIG11bHRpcGxpZWQgYnkgdGhlIGBtdWx0aXBsaWVyYCBhcmd1bWVudC5cblx0ICpcblx0ICogQGFyZ3VtZW50IG11bHRpcGxpZXIgRGVmYXVsdHMgdG8gYDFgLCBtdWx0aXBsaWVkIHdpdGggdGhlIHN0ZXAgdmFsdWUuXG5cdCAqL1xuXHRpbmNyZW1lbnRWYWx1ZShtdWx0aXBsaWVyID0gMSwgaW5kZXggPSAwKSB7XG5cdFx0dGhpcy5fdmFsdWVbaW5kZXhdID0gdGhpcy5fdmFsdWVbaW5kZXhdICsgKHRoaXMuc3RlcCAqIG11bHRpcGxpZXIpO1xuXHRcdHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlOyAvLyBydW4gdGhlIHNldHRlclxuXHR9XG5cblx0LyoqXG5cdCAqIERlY3JlbWVudHMgdGhlIHZhbHVlIGJ5IHRoZSBzdGVwIHZhbHVlLCBvciB0aGUgc3RlcCB2YWx1ZSBtdWx0aXBsaWVkIGJ5IHRoZSBgbXVsdGlwbGllcmAgYXJndW1lbnQuXG5cdCAqXG5cdCAqIEBhcmd1bWVudCBtdWx0aXBsaWVyIERlZmF1bHRzIHRvIGAxYCwgbXVsdGlwbGllZCB3aXRoIHRoZSBzdGVwIHZhbHVlLlxuXHQgKi9cblx0ZGVjcmVtZW50VmFsdWUobXVsdGlwbGllciA9IDEsIGluZGV4ID0gMCkge1xuXHRcdHRoaXMuX3ZhbHVlW2luZGV4XSA9IHRoaXMuX3ZhbHVlW2luZGV4XSAtICh0aGlzLnN0ZXAgKiBtdWx0aXBsaWVyKTtcblx0XHR0aGlzLnZhbHVlID0gdGhpcy52YWx1ZTsgLy8gcnVuIHRoZSBzZXR0ZXJcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBzbGlkZXIgaXMgaW4gcmFuZ2UgbW9kZS5cblx0ICovXG5cdGlzUmFuZ2UoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlLmxlbmd0aCA+IDE7XG5cdH1cblxuXHQvKipcblx0ICogUmFuZ2UgbW9kZSBvbmx5LlxuXHQgKiBVcGRhdGVzIHRoZSB0cmFjayB3aWR0aCB0byBzcGFuIGZyb20gdGhlIGxvdyB0aHVtYiB0byB0aGUgaGlnaCB0aHVtYlxuXHQgKi9cblx0dXBkYXRlVHJhY2tSYW5nZVdpZHRoKCkge1xuXHRcdGNvbnN0IGZyYWN0aW9uID0gdGhpcy5nZXRGcmFjdGlvbkNvbXBsZXRlKHRoaXMuX3ZhbHVlWzBdKTtcblx0XHRjb25zdCBmcmFjdGlvbjIgPSB0aGlzLmdldEZyYWN0aW9uQ29tcGxldGUodGhpcy5fdmFsdWVbMV0pO1xuXHRcdHRoaXMuZmlsbGVkVHJhY2submF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZnJhY3Rpb24gKiAxMDB9JSwgLTUwJSkgJHt0aGlzLnNjYWxlWChmcmFjdGlvbjIgLSBmcmFjdGlvbil9YDtcblx0fVxuXG5cdC8qKiBDaGFuZ2UgaGFuZGxlciBmb3IgdGhlIG9wdGlvbmFsIGlucHV0ICovXG5cdG9uQ2hhbmdlKGV2ZW50LCBpbmRleCkge1xuXHRcdHRoaXMuX3ZhbHVlW2luZGV4XSA9IE51bWJlcihldmVudC50YXJnZXQudmFsdWUpO1xuXHRcdHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlO1xuXHR9XG5cblx0LyoqIEhhbmRsZXMgY2xpY2tzIG9uIHRoZSByYW5nZSB0cmFjaywgYW5kIHNldHRpbmcgdGhlIHZhbHVlIHRvIGl0J3MgXCJyZWFsXCIgZXF1aXZhbGVudCAqL1xuXHRvbkNsaWNrKGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XG5cdFx0Y29uc3QgdHJhY2tMZWZ0ID0gdGhpcy50cmFjay5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0dGhpcy5fdmFsdWVbMF0gPSB0aGlzLmNvbnZlcnRUb1ZhbHVlKGV2ZW50LmNsaWVudFggLSB0cmFja0xlZnQpO1xuXHRcdHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlO1xuXHR9XG5cblx0LyoqIEZvY3VzIGhhbmRsZXIgZm9yIHRoZSBvcHRpb25hbCBpbnB1dCAqL1xuXHRvbkZvY3VzKHt0YXJnZXR9KSB7XG5cdFx0dGFyZ2V0LnNlbGVjdCgpO1xuXHR9XG5cblx0LyoqIE1vdXNlIG1vdmUgaGFuZGxlci4gUmVzcG9uc2libGUgZm9yIHVwZGF0aW5nIHRoZSB2YWx1ZSBhbmQgdmlzdWFsIHNlbGVjdGlvbiBiYXNlZCBvbiBtb3VzZSBtb3ZlbWVudCAqL1xuXHRvbk1vdXNlTW92ZShldmVudCkge1xuXHRcdGlmICh0aGlzLmRpc2FibGVkIHx8ICF0aGlzLmlzTW91c2VEb3duKSB7IHJldHVybjsgfVxuXHRcdGNvbnN0IHRyYWNrID0gdGhpcy50cmFjay5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0bGV0IHZhbHVlO1xuXG5cdFx0aWYgKFxuXHRcdFx0ZXZlbnQuY2xpZW50WCAtIHRyYWNrLmxlZnQgPD0gdHJhY2sud2lkdGhcblx0XHRcdCYmIGV2ZW50LmNsaWVudFggLSB0cmFjay5sZWZ0ID49IDBcblx0XHQpIHtcblx0XHRcdHZhbHVlID0gdGhpcy5jb252ZXJ0VG9WYWx1ZShldmVudC5jbGllbnRYIC0gdHJhY2subGVmdCk7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgdGhlIG1vdXNlIGlzIGJleW9uZCB0aGUgbWF4LCBzZXQgdGhlIHZhbHVlIHRvIGBtYXhgXG5cdFx0aWYgKGV2ZW50LmNsaWVudFggLSB0cmFjay5sZWZ0ID4gdHJhY2sud2lkdGgpIHtcblx0XHRcdHZhbHVlID0gdGhpcy5tYXg7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgdGhlIG1vdXNlIGlzIGJlbG93IHRoZSBtaW4sIHNldCB0aGUgdmFsdWUgdG8gYG1pbmBcblx0XHRpZiAoZXZlbnQuY2xpZW50WCAtIHRyYWNrLmxlZnQgPCAwKSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMubWluO1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl92YWx1ZVt0aGlzLl9mb2N1c2VkVGh1bWJJbmRleF0gPSB2YWx1ZTtcblx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGVzIHRoZSBgb25Nb3VzZU1vdmVgIGhhbmRsZXJcblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSB0aHVtYiBJZiB0cnVlIHRoZW4gYHRodW1iYCBpcyBjbGlja2VkIGRvd24sIG90aGVyd2lzZSBgdGh1bWIyYCBpcyBjbGlja2VkIGRvd24uXG5cdCAqL1xuXHRvbk1vdXNlRG93bihldmVudCwgaW5kZXggPSAwKSB7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cblx0XHR0aGlzLl9mb2N1c2VkVGh1bWJJbmRleCA9IGluZGV4O1xuXHRcdHRoaXMudGh1bWJzLnRvQXJyYXkoKVtpbmRleF0ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuXHRcdHRoaXMuaXNNb3VzZURvd24gPSB0cnVlO1xuXHR9XG5cblx0LyoqIERpc2FibGVzIHRoZSBgb25Nb3VzZU1vdmVgIGhhbmRsZXIgKi9cblx0b25Nb3VzZVVwKCkge1xuXHRcdHRoaXMuaXNNb3VzZURvd24gPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxscyBgaW5jcmVtZW50VmFsdWVgIGZvciBBcnJvd1JpZ2h0IGFuZCBBcnJvd1VwLCBgZGVjcmVtZW50VmFsdWVgIGZvciBBcnJvd0xlZnQgYW5kIEFycm93RG93bi5cblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSB0aHVtYiBJZiB0cnVlIHRoZW4gYHRodW1iYCBpcyBwcmVzc2VkIGRvd24sIG90aGVyd2lzZSBgdGh1bWIyYCBpcyBwcmVzc2VkIGRvd24uXG5cdCAqL1xuXHRvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGluZGV4ID0gMCkge1xuXHRcdGlmICh0aGlzLmRpc2FibGVBcnJvd0tleXMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Y29uc3QgbXVsdGlwbGllciA9IGV2ZW50LnNoaWZ0S2V5ID8gdGhpcy5zaGlmdE11bHRpcGxpZXIgOiAxO1xuXHRcdGlmIChldmVudC5rZXkgPT09IFwiQXJyb3dMZWZ0XCIgfHwgZXZlbnQua2V5ID09PSBcIkFycm93RG93blwiKSB7XG5cdFx0XHR0aGlzLmRlY3JlbWVudFZhbHVlKG11bHRpcGxpZXIsIGluZGV4KTtcblx0XHRcdHRoaXMudGh1bWJzLnRvQXJyYXkoKVtpbmRleF0ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJBcnJvd1JpZ2h0XCIgfHwgZXZlbnQua2V5ID09PSBcIkFycm93VXBcIikge1xuXHRcdFx0dGhpcy5pbmNyZW1lbnRWYWx1ZShtdWx0aXBsaWVyLCBpbmRleCk7XG5cdFx0XHR0aGlzLnRodW1icy50b0FycmF5KClbaW5kZXhdLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9XG5cblx0cHVibGljIGlzVGVtcGxhdGUodmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZjtcblx0fVxuXG5cdC8qKiBHZXQgb3B0aW9uYWwgaW5wdXQgZmllbGRzICovXG5cdHByb3RlY3RlZCBnZXRJbnB1dHMoKTogSFRNTElucHV0RWxlbWVudFtdIHtcblx0XHRyZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcImlucHV0Om5vdChbdHlwZT1yYW5nZV0pXCIpO1xuXHR9XG59XG4iXX0=