import { Checkbox } from "carbon-components-angular/checkbox";
import { Component, Input, HostBinding, TemplateRef } from "@angular/core";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
import * as i0 from "@angular/core";
import * as i1 from "carbon-components-angular/i18n";
import * as i2 from "@angular/common";
/**
 * Defines the set of states for a toggle component.
 */
export var ToggleState;
(function (ToggleState) {
    ToggleState[ToggleState["Init"] = 0] = "Init";
    ToggleState[ToggleState["Checked"] = 1] = "Checked";
    ToggleState[ToggleState["Unchecked"] = 2] = "Unchecked";
})(ToggleState || (ToggleState = {}));
/**
 * [See demo](../../?path=/story/components-toggle--basic)
 *
 * ```html
 * <cds-toggle [(ngModel)]="toggleState">Toggle</cds-toggle>
 * ```
 */
export class Toggle extends Checkbox {
    /**
     * Creates an instance of Toggle.
     */
    constructor(changeDetectorRef, i18n) {
        super(changeDetectorRef);
        this.changeDetectorRef = changeDetectorRef;
        this.i18n = i18n;
        /**
         * Size of the toggle component.
         */
        this.size = "md";
        /**
         * Set to `true` to hide the toggle label & set toggle on/off text to label.
         */
        this.hideLabel = false;
        this.skeleton = false;
        this.toggleClass = true;
        /**
         * The unique id allocated to the `Toggle`.
         */
        this.id = "toggle-" + Toggle.toggleCount;
        this._offValues = this.i18n.getOverridable("TOGGLE.OFF");
        this._onValues = this.i18n.getOverridable("TOGGLE.ON");
        Toggle.toggleCount++;
    }
    /**
     * Text that is set on the left side of the toggle.
     */
    set offText(value) {
        this._offValues.override(value);
    }
    get offText() {
        return this._offValues.value;
    }
    /**
     * Text that is set on the right side of the toggle.
     */
    set onText(value) {
        this._onValues.override(value);
    }
    get onText() {
        return this._onValues.value;
    }
    get disabledClass() {
        return this.disabled;
    }
    get formItem() {
        return !this.skeleton;
    }
    /**
     * `ControlValueAccessor` method to programmatically disable the toggle input.
     *
     * ex: `this.formGroup.get("myToggle").disable();`
     *
     * @param isDisabled `true` to disable the input
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    getOffText() {
        return this._offValues.subject;
    }
    getOnText() {
        return this._onValues.subject;
    }
    getCheckedText() {
        if (this.checked) {
            return this._onValues.subject;
        }
        return this._offValues.subject;
    }
    /**
     * Creates instance of `ToggleChange` used to propagate the change event.
     */
    emitChangeEvent() {
        this.checkedChange.emit(this.checked);
        this.propagateChange(this.checked);
    }
    isTemplate(value) {
        return value instanceof TemplateRef;
    }
}
/**
 * Variable used for creating unique ids for toggle components.
 */
Toggle.toggleCount = 0;
Toggle.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Toggle, deps: [{ token: i0.ChangeDetectorRef }, { token: i1.I18n }], target: i0.ɵɵFactoryTarget.Component });
Toggle.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: Toggle, selector: "cds-toggle, ibm-toggle", inputs: { offText: "offText", onText: "onText", label: "label", size: "size", hideLabel: "hideLabel", skeleton: "skeleton" }, host: { properties: { "class.cds--toggle--skeleton": "this.skeleton", "class.cds--toggle": "this.toggleClass", "class.cds--toggle--disabled": "this.disabledClass", "class.cds--form-item": "this.formItem" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: Toggle,
            multi: true
        }
    ], usesInheritance: true, ngImport: i0, template: `
		<ng-container *ngIf="!skeleton; else skeletonTemplate;">
			<button
				class="cds--toggle__button"
				[disabled]="disabled"
				[id]="id"
				role="switch"
				type="button"
				[attr.aria-checked]="checked"
				(click)="onClick($event)">
			</button>
			<label
				class="cds--toggle__label"
				[for]="id">
				<span
					class="cds--toggle__label-text"
					[ngClass]="{
						'cds--visually-hidden': hideLabel
					}">
					<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
					<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
				</span>
				<div
					class="cds--toggle__appearance"
					[ngClass]="{
						'cds--toggle__appearance--sm': size === 'sm'
					}">
					<div
						class="cds--toggle__switch"
						[ngClass]="{
							'cds--toggle__switch--checked': checked
						}">
						<svg
							*ngIf="size === 'sm'"
							class='cds--toggle__check'
							width="6px"
							height="5px"
							viewBox="0 0 6 5">
							<path d="M2.2 2.7L5 0 6 1 2.2 5 0 2.7 1 1.5z" />
						</svg>
					</div>
					<span class="cds--toggle__text">
						{{(hideLabel ? label : (getCheckedText() | async))}}
					</span>
				</div>
			</label>
		</ng-container>
		<ng-template #skeletonTemplate>
			<div class="cds--toggle__skeleton-circle"></div>
			<div class="cds--toggle__skeleton-rectangle"></div>
		</ng-template>
	`, isInline: true, dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "pipe", type: i2.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Toggle, decorators: [{
            type: Component,
            args: [{
                    selector: "cds-toggle, ibm-toggle",
                    template: `
		<ng-container *ngIf="!skeleton; else skeletonTemplate;">
			<button
				class="cds--toggle__button"
				[disabled]="disabled"
				[id]="id"
				role="switch"
				type="button"
				[attr.aria-checked]="checked"
				(click)="onClick($event)">
			</button>
			<label
				class="cds--toggle__label"
				[for]="id">
				<span
					class="cds--toggle__label-text"
					[ngClass]="{
						'cds--visually-hidden': hideLabel
					}">
					<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
					<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
				</span>
				<div
					class="cds--toggle__appearance"
					[ngClass]="{
						'cds--toggle__appearance--sm': size === 'sm'
					}">
					<div
						class="cds--toggle__switch"
						[ngClass]="{
							'cds--toggle__switch--checked': checked
						}">
						<svg
							*ngIf="size === 'sm'"
							class='cds--toggle__check'
							width="6px"
							height="5px"
							viewBox="0 0 6 5">
							<path d="M2.2 2.7L5 0 6 1 2.2 5 0 2.7 1 1.5z" />
						</svg>
					</div>
					<span class="cds--toggle__text">
						{{(hideLabel ? label : (getCheckedText() | async))}}
					</span>
				</div>
			</label>
		</ng-container>
		<ng-template #skeletonTemplate>
			<div class="cds--toggle__skeleton-circle"></div>
			<div class="cds--toggle__skeleton-rectangle"></div>
		</ng-template>
	`,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: Toggle,
                            multi: true
                        }
                    ]
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i1.I18n }]; }, propDecorators: { offText: [{
                type: Input
            }], onText: [{
                type: Input
            }], label: [{
                type: Input
            }], size: [{
                type: Input
            }], hideLabel: [{
                type: Input
            }], skeleton: [{
                type: HostBinding,
                args: ["class.cds--toggle--skeleton"]
            }, {
                type: Input
            }], toggleClass: [{
                type: HostBinding,
                args: ["class.cds--toggle"]
            }], disabledClass: [{
                type: HostBinding,
                args: ["class.cds--toggle--disabled"]
            }], formItem: [{
                type: HostBinding,
                args: ["class.cds--form-item"]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90b2dnbGUvdG9nZ2xlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDOUQsT0FBTyxFQUVOLFNBQVMsRUFDVCxLQUFLLEVBQ0wsV0FBVyxFQUNYLFdBQVcsRUFDWCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7OztBQUtuRDs7R0FFRztBQUNILE1BQU0sQ0FBTixJQUFZLFdBSVg7QUFKRCxXQUFZLFdBQVc7SUFDdEIsNkNBQUksQ0FBQTtJQUNKLG1EQUFPLENBQUE7SUFDUCx1REFBUyxDQUFBO0FBQ1YsQ0FBQyxFQUpXLFdBQVcsS0FBWCxXQUFXLFFBSXRCO0FBRUQ7Ozs7OztHQU1HO0FBK0RILE1BQU0sT0FBTyxNQUFPLFNBQVEsUUFBUTtJQTREbkM7O09BRUc7SUFDSCxZQUFzQixpQkFBb0MsRUFBWSxJQUFVO1FBQy9FLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBREosc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQUFZLFNBQUksR0FBSixJQUFJLENBQU07UUE5QmhGOztXQUVHO1FBQ00sU0FBSSxHQUFnQixJQUFJLENBQUM7UUFDbEM7O1dBRUc7UUFDTSxjQUFTLEdBQUcsS0FBSyxDQUFDO1FBRTBCLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFFcEMsZ0JBQVcsR0FBRyxJQUFJLENBQUM7UUFTckQ7O1dBRUc7UUFDSCxPQUFFLEdBQUcsU0FBUyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUM7UUFFMUIsZUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ3BELGNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FB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aGVja2JveCB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2NoZWNrYm94XCI7XG5pbXBvcnQge1xuXHRDaGFuZ2VEZXRlY3RvclJlZixcblx0Q29tcG9uZW50LFxuXHRJbnB1dCxcblx0SG9zdEJpbmRpbmcsXG5cdFRlbXBsYXRlUmVmXG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xuXG5pbXBvcnQgeyBJMThuIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvaTE4blwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gXCJyeGpzXCI7XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgc2V0IG9mIHN0YXRlcyBmb3IgYSB0b2dnbGUgY29tcG9uZW50LlxuICovXG5leHBvcnQgZW51bSBUb2dnbGVTdGF0ZSB7XG5cdEluaXQsXG5cdENoZWNrZWQsXG5cdFVuY2hlY2tlZFxufVxuXG4vKipcbiAqIFtTZWUgZGVtb10oLi4vLi4vP3BhdGg9L3N0b3J5L2NvbXBvbmVudHMtdG9nZ2xlLS1iYXNpYylcbiAqXG4gKiBgYGBodG1sXG4gKiA8Y2RzLXRvZ2dsZSBbKG5nTW9kZWwpXT1cInRvZ2dsZVN0YXRlXCI+VG9nZ2xlPC9jZHMtdG9nZ2xlPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuXHRzZWxlY3RvcjogXCJjZHMtdG9nZ2xlLCBpYm0tdG9nZ2xlXCIsXG5cdHRlbXBsYXRlOiBgXG5cdFx0PG5nLWNvbnRhaW5lciAqbmdJZj1cIiFza2VsZXRvbjsgZWxzZSBza2VsZXRvblRlbXBsYXRlO1wiPlxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRjbGFzcz1cImNkcy0tdG9nZ2xlX19idXR0b25cIlxuXHRcdFx0XHRbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuXHRcdFx0XHRbaWRdPVwiaWRcIlxuXHRcdFx0XHRyb2xlPVwic3dpdGNoXCJcblx0XHRcdFx0dHlwZT1cImJ1dHRvblwiXG5cdFx0XHRcdFthdHRyLmFyaWEtY2hlY2tlZF09XCJjaGVja2VkXCJcblx0XHRcdFx0KGNsaWNrKT1cIm9uQ2xpY2soJGV2ZW50KVwiPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0XHQ8bGFiZWxcblx0XHRcdFx0Y2xhc3M9XCJjZHMtLXRvZ2dsZV9fbGFiZWxcIlxuXHRcdFx0XHRbZm9yXT1cImlkXCI+XG5cdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0Y2xhc3M9XCJjZHMtLXRvZ2dsZV9fbGFiZWwtdGV4dFwiXG5cdFx0XHRcdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0XHRcdFx0J2Nkcy0tdmlzdWFsbHktaGlkZGVuJzogaGlkZUxhYmVsXG5cdFx0XHRcdFx0fVwiPlxuXHRcdFx0XHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCIhaXNUZW1wbGF0ZShsYWJlbClcIj57e2xhYmVsfX08L25nLWNvbnRhaW5lcj5cblx0XHRcdFx0XHQ8bmctdGVtcGxhdGUgKm5nSWY9XCJpc1RlbXBsYXRlKGxhYmVsKVwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImxhYmVsXCI+PC9uZy10ZW1wbGF0ZT5cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0Y2xhc3M9XCJjZHMtLXRvZ2dsZV9fYXBwZWFyYW5jZVwiXG5cdFx0XHRcdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0XHRcdFx0J2Nkcy0tdG9nZ2xlX19hcHBlYXJhbmNlLS1zbSc6IHNpemUgPT09ICdzbSdcblx0XHRcdFx0XHR9XCI+XG5cdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0Y2xhc3M9XCJjZHMtLXRvZ2dsZV9fc3dpdGNoXCJcblx0XHRcdFx0XHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdFx0XHRcdFx0J2Nkcy0tdG9nZ2xlX19zd2l0Y2gtLWNoZWNrZWQnOiBjaGVja2VkXG5cdFx0XHRcdFx0XHR9XCI+XG5cdFx0XHRcdFx0XHQ8c3ZnXG5cdFx0XHRcdFx0XHRcdCpuZ0lmPVwic2l6ZSA9PT0gJ3NtJ1wiXG5cdFx0XHRcdFx0XHRcdGNsYXNzPSdjZHMtLXRvZ2dsZV9fY2hlY2snXG5cdFx0XHRcdFx0XHRcdHdpZHRoPVwiNnB4XCJcblx0XHRcdFx0XHRcdFx0aGVpZ2h0PVwiNXB4XCJcblx0XHRcdFx0XHRcdFx0dmlld0JveD1cIjAgMCA2IDVcIj5cblx0XHRcdFx0XHRcdFx0PHBhdGggZD1cIk0yLjIgMi43TDUgMCA2IDEgMi4yIDUgMCAyLjcgMSAxLjV6XCIgLz5cblx0XHRcdFx0XHRcdDwvc3ZnPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiY2RzLS10b2dnbGVfX3RleHRcIj5cblx0XHRcdFx0XHRcdHt7KGhpZGVMYWJlbCA/IGxhYmVsIDogKGdldENoZWNrZWRUZXh0KCkgfCBhc3luYykpfX1cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9sYWJlbD5cblx0XHQ8L25nLWNvbnRhaW5lcj5cblx0XHQ8bmctdGVtcGxhdGUgI3NrZWxldG9uVGVtcGxhdGU+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwiY2RzLS10b2dnbGVfX3NrZWxldG9uLWNpcmNsZVwiPjwvZGl2PlxuXHRcdFx0PGRpdiBjbGFzcz1cImNkcy0tdG9nZ2xlX19za2VsZXRvbi1yZWN0YW5nbGVcIj48L2Rpdj5cblx0XHQ8L25nLXRlbXBsYXRlPlxuXHRgLFxuXHRwcm92aWRlcnM6IFtcblx0XHR7XG5cdFx0XHRwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcblx0XHRcdHVzZUV4aXN0aW5nOiBUb2dnbGUsXG5cdFx0XHRtdWx0aTogdHJ1ZVxuXHRcdH1cblx0XVxufSlcbmV4cG9ydCBjbGFzcyBUb2dnbGUgZXh0ZW5kcyBDaGVja2JveCB7XG5cdC8qKlxuXHQgKiBWYXJpYWJsZSB1c2VkIGZvciBjcmVhdGluZyB1bmlxdWUgaWRzIGZvciB0b2dnbGUgY29tcG9uZW50cy5cblx0ICovXG5cdHN0YXRpYyB0b2dnbGVDb3VudCA9IDA7XG5cblx0LyoqXG5cdCAqIFRleHQgdGhhdCBpcyBzZXQgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgdG9nZ2xlLlxuXHQgKi9cblx0QElucHV0KClcblx0c2V0IG9mZlRleHQodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX29mZlZhbHVlcy5vdmVycmlkZSh2YWx1ZSk7XG5cdH1cblxuXHRnZXQgb2ZmVGV4dCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fb2ZmVmFsdWVzLnZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRleHQgdGhhdCBpcyBzZXQgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHRvZ2dsZS5cblx0ICovXG5cdEBJbnB1dCgpXG5cdHNldCBvblRleHQodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX29uVmFsdWVzLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXG5cdGdldCBvblRleHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX29uVmFsdWVzLnZhbHVlO1xuXHR9XG5cdC8qKlxuXHQgKiBUZXh0IHRoYXQgaXMgc2V0IGFzIHRoZSBsYWJlbCBvZiB0aGUgdG9nZ2xlLlxuXHQgKi9cblx0QElucHV0KCkgbGFiZWw6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cdC8qKlxuXHQgKiBTaXplIG9mIHRoZSB0b2dnbGUgY29tcG9uZW50LlxuXHQgKi9cblx0QElucHV0KCkgc2l6ZTogXCJzbVwiIHwgXCJtZFwiID0gXCJtZFwiO1xuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCB0byBoaWRlIHRoZSB0b2dnbGUgbGFiZWwgJiBzZXQgdG9nZ2xlIG9uL29mZiB0ZXh0IHRvIGxhYmVsLlxuXHQgKi9cblx0QElucHV0KCkgaGlkZUxhYmVsID0gZmFsc2U7XG5cblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MuY2RzLS10b2dnbGUtLXNrZWxldG9uXCIpIEBJbnB1dCgpIHNrZWxldG9uID0gZmFsc2U7XG5cblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MuY2RzLS10b2dnbGVcIikgdG9nZ2xlQ2xhc3MgPSB0cnVlO1xuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy5jZHMtLXRvZ2dsZS0tZGlzYWJsZWRcIikgZ2V0IGRpc2FibGVkQ2xhc3MgKCkge1xuXHRcdHJldHVybiB0aGlzLmRpc2FibGVkO1xuXHR9XG5cblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MuY2RzLS1mb3JtLWl0ZW1cIikgZ2V0IGZvcm1JdGVtKCkge1xuXHRcdHJldHVybiAhdGhpcy5za2VsZXRvbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgdW5pcXVlIGlkIGFsbG9jYXRlZCB0byB0aGUgYFRvZ2dsZWAuXG5cdCAqL1xuXHRpZCA9IFwidG9nZ2xlLVwiICsgVG9nZ2xlLnRvZ2dsZUNvdW50O1xuXG5cdHByb3RlY3RlZCBfb2ZmVmFsdWVzID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVE9HR0xFLk9GRlwiKTtcblx0cHJvdGVjdGVkIF9vblZhbHVlcyA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRPR0dMRS5PTlwiKTtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgVG9nZ2xlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IocHJvdGVjdGVkIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZiwgcHJvdGVjdGVkIGkxOG46IEkxOG4pIHtcblx0XHRzdXBlcihjaGFuZ2VEZXRlY3RvclJlZik7XG5cdFx0VG9nZ2xlLnRvZ2dsZUNvdW50Kys7XG5cdH1cblxuXHQvKipcblx0ICogYENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBtZXRob2QgdG8gcHJvZ3JhbW1hdGljYWxseSBkaXNhYmxlIHRoZSB0b2dnbGUgaW5wdXQuXG5cdCAqXG5cdCAqIGV4OiBgdGhpcy5mb3JtR3JvdXAuZ2V0KFwibXlUb2dnbGVcIikuZGlzYWJsZSgpO2Bcblx0ICpcblx0ICogQHBhcmFtIGlzRGlzYWJsZWQgYHRydWVgIHRvIGRpc2FibGUgdGhlIGlucHV0XG5cdCAqL1xuXHRzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pIHtcblx0XHR0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcblx0fVxuXG5cdGdldE9mZlRleHQoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblx0XHRyZXR1cm4gdGhpcy5fb2ZmVmFsdWVzLnN1YmplY3Q7XG5cdH1cblxuXHRnZXRPblRleHQoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblx0XHRyZXR1cm4gdGhpcy5fb25WYWx1ZXMuc3ViamVjdDtcblx0fVxuXG5cdGdldENoZWNrZWRUZXh0KCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cdFx0aWYgKHRoaXMuY2hlY2tlZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX29uVmFsdWVzLnN1YmplY3Q7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9vZmZWYWx1ZXMuc3ViamVjdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGluc3RhbmNlIG9mIGBUb2dnbGVDaGFuZ2VgIHVzZWQgdG8gcHJvcGFnYXRlIHRoZSBjaGFuZ2UgZXZlbnQuXG5cdCAqL1xuXHRlbWl0Q2hhbmdlRXZlbnQoKSB7XG5cdFx0dGhpcy5jaGVja2VkQ2hhbmdlLmVtaXQodGhpcy5jaGVja2VkKTtcblx0XHR0aGlzLnByb3BhZ2F0ZUNoYW5nZSh0aGlzLmNoZWNrZWQpO1xuXHR9XG5cblx0cHVibGljIGlzVGVtcGxhdGUodmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZjtcblx0fVxufVxuIl19