import * as i2 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { Component, HostBinding, Injectable, EventEmitter, Input, Output, HostListener, Optional, ContentChild, NgModule } from '@angular/core';
import * as i3 from 'carbon-components-angular/icon';
import { IconModule } from 'carbon-components-angular/icon';
import { ReplaySubject, Subscription } from 'rxjs';

class ContextMenuDividerComponent {
    constructor() {
        this.dividerClass = true;
        this.role = "separator";
    }
}
ContextMenuDividerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ContextMenuDividerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ContextMenuDividerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: ContextMenuDividerComponent, selector: "cds-context-menu-divider, ibm-context-menu-divider", host: { properties: { "class.cds--menu-item-divider": "this.dividerClass", "attr.role": "this.role" } }, ngImport: i0, template: "", isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ContextMenuDividerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: "cds-context-menu-divider, ibm-context-menu-divider",
                    template: ""
                }]
        }], propDecorators: { dividerClass: [{
                type: HostBinding,
                args: ["class.cds--menu-item-divider"]
            }], role: [{
                type: HostBinding,
                args: ["attr.role"]
            }] } });

class ContextMenuSelectionService {
    constructor() {
        this.selectionSubject = new ReplaySubject(1);
        this.value = [];
        this.selectionObservable = this.selectionSubject.asObservable();
    }
    selectRadio(value) {
        if (!value) {
            return;
        }
        this.selectionSubject.next(value);
        this.value = [value];
    }
    selectCheckbox(value) {
        if (!value) {
            return;
        }
        if (this.value.includes(value)) {
            this.value = this.value.filter(v => v !== value);
        }
        else {
            this.value.push(value);
        }
        this.selectionSubject.next(this.value);
    }
    selectCheckboxes(value) {
        if (!value) {
            return;
        }
        this.value = value;
        this.selectionSubject.next(value);
    }
}
ContextMenuSelectionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ContextMenuSelectionService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ContextMenuSelectionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ContextMenuSelectionService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ContextMenuSelectionService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });

class ContextMenuGroupComponent {
    constructor(contextMenuSelectionService) {
        this.contextMenuSelectionService = contextMenuSelectionService;
        this.role = "group";
        this.label = null;
        this.value = [];
        this.type = null;
        this.valueChange = new EventEmitter();
        this.subscription = new Subscription();
    }
    get radioGroup() { return this.type === "radio"; }
    get group() { return this.type === "checkbox"; }
    ngOnInit() {
        const { selectionObservable } = this.contextMenuSelectionService;
        const subscription = selectionObservable.subscribe(value => {
            this.valueChange.emit(value);
        });
        this.subscription.add(subscription);
    }
    ngOnChanges(changes) {
        if (changes.value) {
            if (this.type === "radio") {
                this.contextMenuSelectionService.selectRadio(changes.value.currentValue);
            }
            if (this.type === "checkbox") {
                this.contextMenuSelectionService.selectCheckboxes(changes.value.currentValue);
            }
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
ContextMenuGroupComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ContextMenuGroupComponent, deps: [{ token: ContextMenuSelectionService }], target: i0.ɵɵFactoryTarget.Component });
ContextMenuGroupComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: ContextMenuGroupComponent, selector: "cds-context-menu-group, ibm-context-menu-group", inputs: { label: "label", value: "value", type: "type" }, outputs: { valueChange: "valueChange" }, host: { properties: { "attr.role": "this.role", "class.cds--menu-item-radio-group": "this.radioGroup", "class.cds--menu-item-group": "this.group", "attr.aria-label": "this.label" } }, providers: [ContextMenuSelectionService], usesOnChanges: true, ngImport: i0, template: `
		<ng-content></ng-content>
	`, isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ContextMenuGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: "cds-context-menu-group, ibm-context-menu-group",
                    template: `
		<ng-content></ng-content>
	`,
                    providers: [ContextMenuSelectionService]
                }]
        }], ctorParameters: function () { return [{ type: ContextMenuSelectionService }]; }, propDecorators: { role: [{
                type: HostBinding,
                args: ["attr.role"]
            }], radioGroup: [{
                type: HostBinding,
                args: ["class.cds--menu-item-radio-group"]
            }], group: [{
                type: HostBinding,
                args: ["class.cds--menu-item-group"]
            }], label: [{
                type: HostBinding,
                args: ["attr.aria-label"]
            }, {
                type: Input
            }], value: [{
                type: Input
            }], type: [{
                type: Input
            }], valueChange: [{
                type: Output
            }] } });

class ContextMenuComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.open = false;
        this.position = {
            left: 0,
            top: 0
        };
        this.contextMenu = true;
        this.role = "menu";
        this.tabindex = "-1";
    }
    get contextMenuOpen() { return this.open; }
    get showMenu() { return this.open; }
    get leftPosition() { return this.position.left; }
    get topPosition() { return this.position.top; }
    get classIcons() {
        const svgElement = this.elementRef.nativeElement
            .querySelector(".cds--menu-item .cds--menu-item__icon svg");
        return svgElement;
    }
    ngOnChanges(changes) {
        if (changes.open && changes.open.currentValue) {
            this.focusMenu();
        }
    }
    focusMenu() {
        // wait until the next tick to let the DOM settle before changing the focus
        setTimeout(() => {
            const list = this.elementRef.nativeElement;
            const firstOption = list.querySelector(".cds--menu-item");
            firstOption.focus();
        });
    }
    handleNavigation(event) {
        const list = this.elementRef.nativeElement;
        const subMenus = Array.from(list.querySelectorAll("cds-context-menu[role=menu]"));
        const menuItems = Array.from(list.querySelectorAll(".cds--menu-item"))
            .filter(menuItem => !subMenus.some(subMenu => subMenu.contains(menuItem)));
        const currentIndex = menuItems.findIndex(menuItem => parseInt(menuItem.getAttribute("tabindex"), 10) === 0);
        const currentMenuItem = menuItems[currentIndex];
        switch (event.key) {
            case "ArrowDown": {
                if (document.activeElement === list) {
                    menuItems[0].focus();
                }
                else {
                    if (currentIndex !== -1 && currentIndex < menuItems.length - 1) {
                        menuItems[currentIndex + 1].focus();
                    }
                }
                break;
            }
            case "ArrowUp": {
                if (document.activeElement === list) {
                    menuItems[menuItems.length - 1].focus();
                }
                else {
                    if (currentIndex !== -1 && currentIndex > 0) {
                        menuItems[currentIndex - 1].focus();
                    }
                }
                break;
            }
            case "ArrowRight": {
                if (currentIndex !== -1 && subMenus.some(subMenu => currentMenuItem.contains(subMenu))) {
                    currentMenuItem.click();
                }
                break;
            }
            case "ArrowLeft": {
                const parent = currentMenuItem.parentElement.closest(".cds--menu-item, .cds--menu-item");
                if (parent) {
                    parent.focus();
                }
                break;
            }
        }
    }
}
ContextMenuComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ContextMenuComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
ContextMenuComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: ContextMenuComponent, selector: "cds-context-menu, ibm-context-menu", inputs: { open: "open", position: "position" }, host: { listeners: { "keydown": "handleNavigation($event)" }, properties: { "class.cds--menu": "this.contextMenu", "class.cds--menu--open": "this.contextMenuOpen", "class.cds--menu--shown": "this.showMenu", "attr.role": "this.role", "attr.tabindex": "this.tabindex", "style.left.px": "this.leftPosition", "style.top.px": "this.topPosition", "class.cds--menu--with-icons": "this.classIcons" } }, usesOnChanges: true, ngImport: i0, template: `
			<ng-content></ng-content>
	`, isInline: true, styles: [":host{display:block}\n"] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ContextMenuComponent, decorators: [{
            type: Component,
            args: [{ selector: "cds-context-menu, ibm-context-menu", template: `
			<ng-content></ng-content>
	`, styles: [":host{display:block}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { open: [{
                type: Input
            }], position: [{
                type: Input
            }], contextMenu: [{
                type: HostBinding,
                args: ["class.cds--menu"]
            }], contextMenuOpen: [{
                type: HostBinding,
                args: ["class.cds--menu--open"]
            }], showMenu: [{
                type: HostBinding,
                args: ["class.cds--menu--shown"]
            }], role: [{
                type: HostBinding,
                args: ["attr.role"]
            }], tabindex: [{
                type: HostBinding,
                args: ["attr.tabindex"]
            }], leftPosition: [{
                type: HostBinding,
                args: ["style.left.px"]
            }], topPosition: [{
                type: HostBinding,
                args: ["style.top.px"]
            }], classIcons: [{
                type: HostBinding,
                args: ["class.cds--menu--with-icons"]
            }], handleNavigation: [{
                type: HostListener,
                args: ["keydown", ["$event"]]
            }] } });

class ContextMenuItemComponent {
    constructor(elementRef, contextMenuSelectionService) {
        this.elementRef = elementRef;
        this.contextMenuSelectionService = contextMenuSelectionService;
        this.optionClass = true;
        this.role = "menuitem";
        this.tabindex = -1;
        this.ariaHasPopup = null;
        this.ariaExpanded = null;
        this.label = "";
        this.info = "";
        this.type = null;
        this.checked = false;
        this.icon = "";
        this.value = "";
        this.checkedChange = new EventEmitter();
        this.hasChildren = false;
        this.selectable = false;
        this.subscriptions = new Subscription();
    }
    get ariaChecked() {
        return this.type === "checkbox" ?
            (this.checked ? true : false) : null;
    }
    ngOnInit() {
        switch (this.type) {
            case "checkbox": {
                this.role = "menuitemcheckbox";
                this.selectable = true;
                break;
            }
            case "radio": {
                this.role = "menuitemradio";
                this.selectable = true;
                break;
            }
            default: {
                this.role = "menuitem";
            }
        }
        if (this.type && this.contextMenuSelectionService && this.value) {
            const { selectionObservable } = this.contextMenuSelectionService;
            const subscription = selectionObservable.subscribe((value) => {
                if (this.type === "radio") {
                    this.handleSelection(value === this.value);
                }
                if (this.type === "checkbox") {
                    this.handleSelection(value.includes(this.value));
                }
            });
            this.subscriptions.add(subscription);
        }
    }
    ngAfterContentInit() {
        if (this.childContextMenu) {
            this.hasChildren = true;
            this.ariaHasPopup = true;
            this.ariaExpanded = false;
        }
    }
    handleClick(event) {
        event.stopPropagation();
        if (this.hasChildren) {
            this.openSubMenu();
            this.childContextMenu.focusMenu();
        }
        if (this.type) {
            this.handleSelection(!this.checked);
        }
        if (this.contextMenuSelectionService) {
            if (this.type === "radio") {
                this.contextMenuSelectionService.selectRadio(this.value);
            }
            if (this.type === "checkbox") {
                this.contextMenuSelectionService.selectCheckbox(this.value);
            }
        }
    }
    handleSelection(selected) {
        this.checked = selected;
        this.checkedChange.emit(this.checked);
    }
    openSubMenu() {
        if (this.childContextMenu) {
            this.childContextMenu.open = true;
            this.ariaExpanded = true;
            const dimensions = this.elementRef.nativeElement.getBoundingClientRect();
            this.childContextMenu.position.left = dimensions.left + dimensions.width;
            // subtract 4px to account for margins
            this.childContextMenu.position.top = dimensions.top - 4;
        }
    }
    closeSubMenu() {
        if (this.childContextMenu) {
            this.childContextMenu.open = false;
            this.ariaExpanded = false;
        }
    }
    handleMouseOver() {
        this.openSubMenu();
    }
    handleMouseOut() {
        this.closeSubMenu();
    }
    handleFocus() {
        this.tabindex = 0;
        if (this.hasChildren && this.ariaExpanded) {
            this.closeSubMenu();
        }
    }
    handleBlur() {
        this.tabindex = -1;
    }
    focusItem() {
        this.elementRef.nativeElement.focus();
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
}
ContextMenuItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ContextMenuItemComponent, deps: [{ token: i0.ElementRef }, { token: ContextMenuSelectionService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
ContextMenuItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: ContextMenuItemComponent, selector: "cds-context-menu-item, ibm-context-menu-item", inputs: { label: "label", info: "info", type: "type", checked: "checked", icon: "icon", value: "value" }, outputs: { checkedChange: "checkedChange" }, host: { listeners: { "keydown.enter": "handleClick($event)", "keydown.space": "handleClick($event)", "click": "handleClick($event)", "mouseover": "handleMouseOver()", "mouseout": "handleMouseOut()", "focus": "handleFocus()", "blur": "handleBlur()" }, properties: { "class.cds--menu-item": "this.optionClass", "attr.role": "this.role", "attr.tabindex": "this.tabindex", "attr.aria-haspopup": "this.ariaHasPopup", "attr.aria-expanded": "this.ariaExpanded", "attr.aria-checked": "this.ariaChecked" } }, queries: [{ propertyName: "childContextMenu", first: true, predicate: ContextMenuComponent, descendants: true, static: true }], ngImport: i0, template: `
		<div class="cds--menu-item__icon">
			<svg *ngIf="selectable && checked" cdsIcon="checkmark" size="16"></svg>
			<svg *ngIf="!selectable && icon" [cdsIcon]="icon" size="16"></svg>
		</div>
		<div class="cds--menu-item__label" [title]="label">{{label}}</div>
		<div class="cds--menu-item__shortcut">
			<ng-container *ngIf="info">{{info}}</ng-container>
			<svg *ngIf="hasChildren" cdsIcon="caret--right" size="16"></svg>
		</div>
		<ng-content></ng-content>
	`, isInline: true, styles: [":host{grid-template-columns:1rem 1fr max-content}\n"], dependencies: [{ kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.IconDirective, selector: "[cdsIcon], [ibmIcon]", inputs: ["ibmIcon", "cdsIcon", "size", "title", "ariaLabel", "ariaLabelledBy", "ariaHidden", "isFocusable"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ContextMenuItemComponent, decorators: [{
            type: Component,
            args: [{ selector: "cds-context-menu-item, ibm-context-menu-item", template: `
		<div class="cds--menu-item__icon">
			<svg *ngIf="selectable && checked" cdsIcon="checkmark" size="16"></svg>
			<svg *ngIf="!selectable && icon" [cdsIcon]="icon" size="16"></svg>
		</div>
		<div class="cds--menu-item__label" [title]="label">{{label}}</div>
		<div class="cds--menu-item__shortcut">
			<ng-container *ngIf="info">{{info}}</ng-container>
			<svg *ngIf="hasChildren" cdsIcon="caret--right" size="16"></svg>
		</div>
		<ng-content></ng-content>
	`, styles: [":host{grid-template-columns:1rem 1fr max-content}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: ContextMenuSelectionService, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { optionClass: [{
                type: HostBinding,
                args: ["class.cds--menu-item"]
            }], role: [{
                type: HostBinding,
                args: ["attr.role"]
            }], tabindex: [{
                type: HostBinding,
                args: ["attr.tabindex"]
            }], ariaHasPopup: [{
                type: HostBinding,
                args: ["attr.aria-haspopup"]
            }], ariaExpanded: [{
                type: HostBinding,
                args: ["attr.aria-expanded"]
            }], ariaChecked: [{
                type: HostBinding,
                args: ["attr.aria-checked"]
            }], label: [{
                type: Input
            }], info: [{
                type: Input
            }], type: [{
                type: Input
            }], checked: [{
                type: Input
            }], icon: [{
                type: Input
            }], value: [{
                type: Input
            }], checkedChange: [{
                type: Output
            }], childContextMenu: [{
                type: ContentChild,
                args: [ContextMenuComponent, { static: true }]
            }], handleClick: [{
                type: HostListener,
                args: ["keydown.enter", ["$event"]]
            }, {
                type: HostListener,
                args: ["keydown.space", ["$event"]]
            }, {
                type: HostListener,
                args: ["click", ["$event"]]
            }], handleMouseOver: [{
                type: HostListener,
                args: ["mouseover"]
            }], handleMouseOut: [{
                type: HostListener,
                args: ["mouseout"]
            }], handleFocus: [{
                type: HostListener,
                args: ["focus"]
            }], handleBlur: [{
                type: HostListener,
                args: ["blur"]
            }] } });

class ContextMenuModule {
}
ContextMenuModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ContextMenuModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ContextMenuModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.3.0", ngImport: i0, type: ContextMenuModule, declarations: [ContextMenuDividerComponent,
        ContextMenuGroupComponent,
        ContextMenuItemComponent,
        ContextMenuComponent], imports: [CommonModule, IconModule], exports: [ContextMenuDividerComponent,
        ContextMenuGroupComponent,
        ContextMenuItemComponent,
        ContextMenuComponent] });
ContextMenuModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ContextMenuModule, imports: [CommonModule, IconModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ContextMenuModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        ContextMenuDividerComponent,
                        ContextMenuGroupComponent,
                        ContextMenuItemComponent,
                        ContextMenuComponent
                    ],
                    exports: [
                        ContextMenuDividerComponent,
                        ContextMenuGroupComponent,
                        ContextMenuItemComponent,
                        ContextMenuComponent
                    ],
                    imports: [CommonModule, IconModule]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { ContextMenuComponent, ContextMenuDividerComponent, ContextMenuGroupComponent, ContextMenuItemComponent, ContextMenuModule };
//# sourceMappingURL=carbon-components-angular-context-menu.mjs.map
