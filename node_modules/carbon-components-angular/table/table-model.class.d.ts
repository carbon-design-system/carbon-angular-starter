/**
 *
 * carbon-angular v0.0.0 | table-model.class.d.ts
 *
 * Copyright 2014, 2023 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { EventEmitter } from "@angular/core";
import { PaginationModel } from "carbon-components-angular/pagination";
import { TableHeaderItem } from "./table-header-item.class";
import { TableItem } from "./table-item.class";
import { Subject } from "rxjs";
export declare type HeaderType = number | "select" | "expand";
/**
 * TableModel represents a data model for two-dimensional data. It's used for all things table
 * (table component, table toolbar, pagination, etc)
 *
 * TableModel manages its internal data integrity very well if you use the provided helper
 * functions for modifying rows and columns and assigning header and data in that order.
 *
 * It also provides direct access to the data so you can read and modify it.
 * If you change the structure of the data (by directly pushing into the arrays or otherwise),
 * keep in mind to keep the data structure intact.
 *
 * Header length and length of every line in the data should be equal.
 *
 * If they are not consistent, unexpected things will happen.
 *
 * Use the provided functions when in doubt.
 */
export declare class TableModel implements PaginationModel {
    /**
     * The number of models instantiated, used for (among other things) unique id generation
     */
    protected static COUNT: number;
    /**
     * Sets data of the table.
     *
     * Make sure all rows are the same length to keep the column count accurate.
     */
    set data(newData: TableItem[][]);
    dataChange: EventEmitter<any>;
    rowsSelectedChange: EventEmitter<number>;
    rowsExpandedChange: EventEmitter<number>;
    /**
     * Gets emitted when `selectAll` is called. Emits false if all rows are deselected and true if
     * all rows are selected.
     */
    selectAllChange: Subject<boolean>;
    /**
     * Gets the full data.
     *
     * You can use it to alter individual `TableItem`s but if you need to change
     * table structure, use `addRow()` and/or `addColumn()`
     */
    get data(): TableItem[][];
    /**
     * Contains information about selection state of rows in the table.
     */
    rowsSelected: boolean[];
    /**
     * Contains information about expanded state of rows in the table.
     */
    rowsExpanded: boolean[];
    /**
     * Contains information about initial index of rows in the table
     */
    rowsIndices: number[];
    /**
     * Contains information about the context of the row.
     *
     * It affects styling of the row to reflect the context.
     *
     * string can be one of `"success" | "warning" | "info" | "error" | ""` and it's
     * empty or undefined by default
     */
    rowsContext: string[];
    /**
     * Contains class name(s) of the row.
     *
     * It affects styling of the row to reflect the appended class name(s).
     *
     * It's empty or undefined by default
     */
    rowsClass: string[];
    /**
     * Contains information about the header cells of the table.
     */
    header: TableHeaderItem[];
    /**
     * Tracks the current page.
     */
    currentPage: number;
    /**
     * Length of page.
     */
    pageLength: number;
    /**
     * Set to true when there is no more data to load in the table
     */
    isEnd: boolean;
    /**
     * Set to true when lazy loading to show loading indicator
     */
    isLoading: boolean;
    /**
     * Absolute total number of rows of the table.
     */
    protected _totalDataLength: number;
    /**
     * Manually set data length in case the data in the table doesn't
     * correctly reflect all the data that table is to display.
     *
     * Example: if you have multiple pages of data that table will display
     * but you're loading one at a time.
     *
     * Set to `null` to reset to default behavior.
     */
    set totalDataLength(length: number);
    /**
     * Total length of data that table has access to, or the amount manually set
     */
    get totalDataLength(): number;
    /**
     * Used in `data`
     */
    protected _data: TableItem[][];
    /**
     * The number of models instantiated, this is to make sure each table has a different
     * model count for unique id generation.
     */
    protected tableModelCount: number;
    constructor();
    /**
     * Returns an id for the given column
     *
     * @param column the column to generate an id for
     * @param row the row of the header to generate an id for
     */
    getId(column: HeaderType, row?: number): string;
    /**
     * Returns the id of the header. Used to link the cells with headers (or headers with headers)
     *
     * @param column the column to start getting headers for
     * @param colSpan the number of columns to get headers for (defaults to 1)
     */
    getHeaderId(column: HeaderType, colSpan?: number): string;
    /**
     * Finds closest header by trying the `column` and then working its way to the left
     *
     * @param column the target column
     */
    getHeader(column: number): TableHeaderItem;
    /**
     * Returns how many rows is currently selected
     */
    selectedRowsCount(): number;
    /**
     * Returns how many rows is currently expanded
     */
    expandedRowsCount(): number;
    /**
     * Returns `index`th row of the table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    row(index: number): TableItem[];
    /**
     * Adds a row to the `index`th row or appends to table if index not provided.
     *
     * If row is shorter than other rows or not provided, it will be padded with
     * empty `TableItem` elements.
     *
     * If row is longer than other rows, others will be extended to match so no data is lost.
     *
     * If called on an empty table with no parameters, it creates a 1x1 table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param [row]
     * @param [index]
     */
    addRow(row?: TableItem[], index?: number): void;
    /**
     * Deletes `index`th row.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    deleteRow(index: number): void;
    hasExpandableRows(): boolean;
    isRowExpandable(index: number): boolean;
    isRowExpanded(index: number): boolean;
    getRowContext(index: number): string;
    /**
     * Returns `index`th column of the table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    column(index: number): TableItem[];
    /**
     * Adds a column to the `index`th column or appends to table if index not provided.
     *
     * If column is shorter than other columns or not provided, it will be padded with
     * empty `TableItem` elements.
     *
     * If column is longer than other columns, others will be extended to match so no data is lost.
     *
     * If called on an empty table with no parameters, it creates a 1x1 table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param [column]
     * @param [index]
     */
    addColumn(column?: TableItem[], index?: number): void;
    /**
     * Deletes `index`th column.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    deleteColumn(index: number): void;
    moveColumn(indexFrom: number, indexTo: number): void;
    /**
     * cycle through the three sort states
     * @param index
     */
    cycleSortState(index: number): void;
    /**
     * Sorts the data currently present in the model based on `compare()`
     *
     * Direction is set by `ascending` and `descending` properties of `TableHeaderItem`
     * in `index`th column.
     *
     * @param index The column based on which it's sorting
     */
    sort(index: number): void;
    /**
     * Appends `rowsSelected` and `rowsExpanded` info to model data.
     *
     * When sorting rows, do this first so information about row selection
     * gets sorted with the other row info.
     *
     * Call `popRowSelectionFromModelData()` after sorting to make everything
     * right with the world again.
     */
    pushRowStateToModelData(): void;
    /**
     * Restores `rowsSelected` from data pushed by `pushRowSelectionToModelData()`
     *
     * Call after sorting data (if you previously pushed to maintain selection order)
     * to make everything right with the world again.
     */
    popRowStateFromModelData(): void;
    /**
     * Checks if row is filtered out.
     *
     * @param index
     * @returns true if any of the filters in header filters out the `index`th row
     */
    isRowFiltered(index: number): boolean;
    /**
     * Select/deselect `index`th row based on value
     *
     * @param index index of the row to select
     * @param value state to set the row to. Defaults to `true`
     */
    selectRow(index: number, value?: boolean): void;
    /**
     * Selects or deselects all rows in the model
     *
     * @param value state to set all rows to. Defaults to `true`
     */
    selectAll(value?: boolean): void;
    isRowSelected(index: number): boolean;
    /**
     * Checks if row is disabled or not.
     */
    isRowDisabled(index: number): boolean;
    /**
     * Expands/Collapses `index`th row based on value
     *
     * @param index index of the row to expand or collapse
     * @param value expanded state of the row. `true` is expanded and `false` is collapsed
     */
    expandRow(index: number, value?: boolean): void;
    /**
     * Gets the true index of a row based on it's relative position.
     * Like in Python, positive numbers start from the top and
     * negative numbers start from the bottom.
     *
     * @param index
     */
    protected realRowIndex(index: number): number;
    /**
     * Gets the true index of a column based on it's relative position.
     * Like in Python, positive numbers start from the top and
     * negative numbers start from the bottom.
     *
     * @param index
     */
    protected realColumnIndex(index: number): number;
    /**
     * Generic function to calculate the real index of something.
     * Used by `realRowIndex()` and `realColumnIndex()`
     *
     * @param index
     * @param length
     */
    protected realIndex(index: number, length: number): number;
}
