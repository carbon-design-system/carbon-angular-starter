{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Utilites to manipulate the position of elements relative to other elements\n */\n\nexport enum PLACEMENTS {\n\tLEFT = \"left\",\n\tRIGHT = \"right\",\n\tTOP = \"top\",\n\tBOTTOM = \"bottom\"\n}\n\nexport interface AbsolutePosition {\n\ttop: number;\n\tleft: number;\n\tposition?: AbsolutePosition;\n}\n\nexport type Offset = { top: number, left: number };\n\nexport type ReferenceRect = {\n\ttop: number;\n\tleft: number;\n\theight: number;\n\twidth: number;\n};\n\nexport type Positions = {\n\t[key: string]: (referenceOffset: Offset, target: HTMLElement, referenceRect: ReferenceRect) => AbsolutePosition\n};\n\nexport const defaultPositions: Positions = {\n\t[PLACEMENTS.LEFT]: (referenceOffset: Offset, target: HTMLElement, referenceRect: ReferenceRect): AbsolutePosition => ({\n\t\ttop: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),\n\t\tleft: Math.round(referenceOffset.left - target.offsetWidth)\n\t}),\n\t[PLACEMENTS.RIGHT]: (referenceOffset: Offset, target: HTMLElement, referenceRect: ReferenceRect): AbsolutePosition => ({\n\t\ttop: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),\n\t\tleft: Math.round(referenceOffset.left + referenceRect.width)\n\t}),\n\t[PLACEMENTS.TOP]: (referenceOffset: Offset, target: HTMLElement, referenceRect: ReferenceRect): AbsolutePosition => ({\n\t\ttop: Math.round(referenceOffset.top - target.offsetHeight),\n\t\tleft: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)\n\t}),\n\t[PLACEMENTS.BOTTOM]: (referenceOffset: Offset, target: HTMLElement, referenceRect: ReferenceRect): AbsolutePosition => ({\n\t\ttop: Math.round(referenceOffset.top + referenceRect.height),\n\t\tleft: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)\n\t})\n};\n\nconst windowRef = typeof window !== \"undefined\" ? window : {\n\tinnerHeight: 0,\n\tscrollY: 0,\n\tinnerWidth: 0,\n\tscrollX: 0\n};\n\nexport class Position {\n\tprotected positions = defaultPositions;\n\n\tconstructor(positions: Positions = {}) {\n\t\tthis.positions = Object.assign({}, defaultPositions, positions);\n\t}\n\n\tgetRelativeOffset(target: HTMLElement): Offset {\n\t\t// start with the initial element offsets\n\t\tlet offsets = {\n\t\t\tleft: target.offsetLeft,\n\t\t\ttop: target.offsetTop\n\t\t};\n\t\t// get each static (i.e. not absolute or relative) offsetParent and sum the left/right offsets\n\t\twhile (target.offsetParent && getComputedStyle(target.offsetParent).position === \"static\") {\n\t\t\toffsets.left += target.offsetLeft;\n\t\t\toffsets.top += target.offsetTop;\n\t\t\ttarget = target.offsetParent as HTMLElement;\n\t\t}\n\t\treturn offsets;\n\t}\n\n\tgetAbsoluteOffset(target: HTMLElement): Offset {\n\t\tlet currentNode = target;\n\t\tlet margins = {\n\t\t\ttop: 0,\n\t\t\tleft: 0\n\t\t};\n\n\t\t// searches for containing elements with additional margins\n\t\twhile (currentNode.offsetParent) {\n\t\t\tconst computed = getComputedStyle(currentNode.offsetParent);\n\t\t\t// find static elements with additional margins\n\t\t\t// since they tend to throw off our positioning\n\t\t\t// (usually this is just the body)\n\t\t\tif (\n\t\t\t\tcomputed.position === \"static\" &&\n\t\t\t\tcomputed.marginLeft &&\n\t\t\t\tcomputed.marginTop\n\t\t\t) {\n\t\t\t\tif (parseInt(computed.marginTop, 10)) {\n\t\t\t\t\tmargins.top += parseInt(computed.marginTop, 10);\n\t\t\t\t}\n\t\t\t\tif (parseInt(computed.marginLeft, 10)) {\n\t\t\t\t\tmargins.left += parseInt(computed.marginLeft, 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrentNode = currentNode.offsetParent as HTMLElement;\n\t\t}\n\n\t\tconst targetRect = target.getBoundingClientRect();\n\t\tconst relativeRect = document.body.getBoundingClientRect();\n\t\treturn {\n\t\t\ttop: targetRect.top - relativeRect.top + margins.top,\n\t\t\tleft: targetRect.left - relativeRect.left + margins.left\n\t\t};\n\t}\n\n\t// finds the position relative to the `reference` element\n\tfindRelative(reference: Element, target: Element, placement: string): AbsolutePosition {\n\t\tconst referenceOffset = this.getRelativeOffset(reference as HTMLElement);\n\t\tconst referenceRect = reference.getBoundingClientRect();\n\t\treturn this.calculatePosition(referenceOffset, referenceRect, target, placement);\n\t}\n\n\tfindAbsolute(reference: Element, target: Element, placement: string): AbsolutePosition {\n\t\tconst referenceOffset = this.getAbsoluteOffset(reference as HTMLElement);\n\t\tconst referenceRect = reference.getBoundingClientRect();\n\t\treturn this.calculatePosition(referenceOffset, referenceRect, target, placement);\n\t}\n\n\tfindPosition(reference: Element,\n\t\ttarget: Element,\n\t\tplacement: string,\n\t\toffsetFunction = this.getAbsoluteOffset.bind(this)): AbsolutePosition {\n\t\tconst referenceOffset = offsetFunction(reference as HTMLElement);\n\t\tconst referenceRect = reference.getBoundingClientRect();\n\t\treturn this.calculatePosition(referenceOffset, referenceRect, target, placement);\n\t}\n\n\tfindPositionAt(offset: Offset, target: Element, placement: string): AbsolutePosition {\n\t\treturn this.calculatePosition(offset, {top: 0, left: 0, height: 0, width: 0}, target, placement);\n\t}\n\n\t/**\n\t * Get the dimensions of an element from an AbsolutePosition and a reference element\n\t */\n\tgetPlacementBox(target: HTMLElement, position: AbsolutePosition) {\n\t\tconst targetBottom = target.offsetHeight + position.top;\n\t\tconst targetRight = target.offsetWidth + position.left;\n\n\t\treturn {\n\t\t\ttop: position.top,\n\t\t\tbottom: targetBottom,\n\t\t\tleft: position.left,\n\t\t\tright: targetRight\n\t\t};\n\t}\n\n\taddOffset(position: AbsolutePosition, top = 0, left = 0): AbsolutePosition {\n\t\treturn Object.assign({}, position, {\n\t\t\ttop: position.top + top,\n\t\t\tleft: position.left + left\n\t\t});\n\t}\n\n\tsetElement(element: Element, position: AbsolutePosition): void {\n\t\t(element as HTMLElement).style.top = `${position.top}px`;\n\t\t(element as HTMLElement).style.left = `${position.left}px`;\n\t}\n\n\tfindBestPlacement(\n\t\treference: Element,\n\t\ttarget: Element,\n\t\tplacements: string[],\n\t\tcontainerFunction: () => ReferenceRect = this.defaultContainerFunction.bind(this),\n\t\tpositionFunction = this.findPosition.bind(this)) {\n\t\t/**\n\t\t * map over the array of placements and weight them based on the percentage of visible area\n\t\t * where visible area is defined as the area not obscured by the window borders\n\t\t */\n\t\tconst weightedPlacements = placements.map(placement => {\n\t\t\tconst pos = positionFunction(reference, target, placement);\n\t\t\tlet box = this.getPlacementBox((target as HTMLElement), pos);\n\t\t\tlet hiddenHeight = 0;\n\t\t\tlet hiddenWidth = 0;\n\t\t\tconst container = containerFunction();\n\t\t\t// the element is exceeding from top or bottom of its container\n\t\t\tif (box.top < container.top) {\n\t\t\t\thiddenHeight = container.top - box.top;\n\t\t\t} else if (box.bottom > container.height) {\n\t\t\t\thiddenHeight = box.bottom - container.height;\n\t\t\t}\n\t\t\t// the element is exceeding from left or right of its container\n\t\t\tif (box.left < container.left) {\n\t\t\t\thiddenWidth = container.left - box.left;\n\t\t\t} else if (box.right > container.width) {\n\t\t\t\thiddenWidth = box.right - container.width;\n\t\t\t}\n\t\t\t// if one of the hidden dimensions is 0 but the other is > 0\n\t\t\t// we want to have a positive area, so setting the null one to 1\n\t\t\tif (hiddenHeight && !hiddenWidth) {\n\t\t\t\thiddenWidth = 1;\n\t\t\t} else if (hiddenWidth && !hiddenHeight) {\n\t\t\t\thiddenHeight = 1;\n\t\t\t}\n\t\t\tconst area = (target as HTMLElement).offsetHeight * (target as HTMLElement).offsetWidth;\n\t\t\tconst hiddenArea = hiddenHeight * hiddenWidth;\n\t\t\t// if visibleArea is 0 it means the element is fully outside container bounds\n\t\t\t// and visiblePercent will then be 0\n\t\t\tlet visibleArea = area - hiddenArea;\n\t\t\tconst visiblePercent = visibleArea / area;\n\t\t\treturn {\n\t\t\t\tplacement,\n\t\t\t\tweight: visiblePercent\n\t\t\t};\n\t\t});\n\n\t\t// sort the placements from best to worst\n\t\tweightedPlacements.sort((a, b) => b.weight - a.weight);\n\t\t// pick the best!\n\t\treturn weightedPlacements[0].placement;\n\t}\n\n\tfindBestPlacementAt(\n\t\toffset: Offset,\n\t\ttarget: Element,\n\t\tplacements: string[],\n\t\tcontainerFunction: () => ReferenceRect = this.defaultContainerFunction.bind(this)) {\n\t\tconst positionAt = (_: any, target: Element, placement: string) => {\n\t\t\treturn this.findPositionAt(offset, target, placement);\n\t\t};\n\n\t\treturn this.findBestPlacement(null as any, target, placements, containerFunction, positionAt);\n\t}\n\n\tprotected defaultContainerFunction(): ReferenceRect {\n\t\treturn {\n\t\t\t// we go with window here, because that's going to be the simple/common case\n\t\t\ttop: 0,\n\t\t\tleft: 0,\n\t\t\theight: windowRef.innerHeight,\n\t\t\twidth: windowRef.innerWidth\n\t\t};\n\t}\n\n\tprotected calculatePosition(\n\t\treferenceOffset: Offset,\n\t\treferenceRect: ReferenceRect,\n\t\ttarget: Element,\n\t\tplacement: string): AbsolutePosition {\n\n\t\tif (this.positions[placement]) {\n\t\t\treturn this.positions[placement](referenceOffset, target as HTMLElement, referenceRect);\n\t\t}\n\t\tconsole.error(\"No function found for placement, defaulting to 0,0\");\n\t\treturn { left: 0, top: 0 };\n\t}\n}\n\nexport const position = new Position();\n\nexport default Position;\n"]}