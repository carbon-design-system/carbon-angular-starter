{"version":3,"sources":["../src/index.ts","index.ts"],"names":[],"mappings":"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","file":"demo.eb8cdb6d.js","sourceRoot":"../../demo","sourcesContent":["/**\n * Utilites to manipulate the position of elements relative to other elements\n */\n\nexport enum PLACEMENTS {\n\tLEFT = \"left\",\n\tRIGHT = \"right\",\n\tTOP = \"top\",\n\tBOTTOM = \"bottom\"\n}\n\nexport interface AbsolutePosition {\n\ttop: number;\n\tleft: number;\n\tposition?: AbsolutePosition;\n}\n\nexport type Offset = { top: number, left: number };\n\nexport type ReferenceRect = {\n\ttop: number;\n\tleft: number;\n\theight: number;\n\twidth: number;\n};\n\nexport type Positions = {\n\t[key: string]: (referenceOffset: Offset, target: HTMLElement, referenceRect: ReferenceRect) => AbsolutePosition\n};\n\nexport const defaultPositions: Positions = {\n\t[PLACEMENTS.LEFT]: (referenceOffset: Offset, target: HTMLElement, referenceRect: ReferenceRect): AbsolutePosition => ({\n\t\ttop: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),\n\t\tleft: Math.round(referenceOffset.left - target.offsetWidth)\n\t}),\n\t[PLACEMENTS.RIGHT]: (referenceOffset: Offset, target: HTMLElement, referenceRect: ReferenceRect): AbsolutePosition => ({\n\t\ttop: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),\n\t\tleft: Math.round(referenceOffset.left + referenceRect.width)\n\t}),\n\t[PLACEMENTS.TOP]: (referenceOffset: Offset, target: HTMLElement, referenceRect: ReferenceRect): AbsolutePosition => ({\n\t\ttop: Math.round(referenceOffset.top - target.offsetHeight),\n\t\tleft: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)\n\t}),\n\t[PLACEMENTS.BOTTOM]: (referenceOffset: Offset, target: HTMLElement, referenceRect: ReferenceRect): AbsolutePosition => ({\n\t\ttop: Math.round(referenceOffset.top + referenceRect.height),\n\t\tleft: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)\n\t})\n};\n\nconst windowRef = typeof window !== \"undefined\" ? window : {\n\tinnerHeight: 0,\n\tscrollY: 0,\n\tinnerWidth: 0,\n\tscrollX: 0\n};\n\nexport class Position {\n\tprotected positions = defaultPositions;\n\n\tconstructor(positions: Positions = {}) {\n\t\tthis.positions = Object.assign({}, defaultPositions, positions);\n\t}\n\n\tgetRelativeOffset(target: HTMLElement): Offset {\n\t\t// start with the initial element offsets\n\t\tlet offsets = {\n\t\t\tleft: target.offsetLeft,\n\t\t\ttop: target.offsetTop\n\t\t};\n\t\t// get each static (i.e. not absolute or relative) offsetParent and sum the left/right offsets\n\t\twhile (target.offsetParent && getComputedStyle(target.offsetParent).position === \"static\") {\n\t\t\toffsets.left += target.offsetLeft;\n\t\t\toffsets.top += target.offsetTop;\n\t\t\ttarget = target.offsetParent as HTMLElement;\n\t\t}\n\t\treturn offsets;\n\t}\n\n\tgetAbsoluteOffset(target: HTMLElement): Offset {\n\t\tlet currentNode = target;\n\t\tlet margins = {\n\t\t\ttop: 0,\n\t\t\tleft: 0\n\t\t};\n\n\t\t// searches for containing elements with additional margins\n\t\twhile (currentNode.offsetParent) {\n\t\t\tconst computed = getComputedStyle(currentNode.offsetParent);\n\t\t\t// find static elements with additional margins\n\t\t\t// since they tend to throw off our positioning\n\t\t\t// (usually this is just the body)\n\t\t\tif (\n\t\t\t\tcomputed.position === \"static\" &&\n\t\t\t\tcomputed.marginLeft &&\n\t\t\t\tcomputed.marginTop\n\t\t\t) {\n\t\t\t\tif (parseInt(computed.marginTop, 10)) {\n\t\t\t\t\tmargins.top += parseInt(computed.marginTop, 10);\n\t\t\t\t}\n\t\t\t\tif (parseInt(computed.marginLeft, 10)) {\n\t\t\t\t\tmargins.left += parseInt(computed.marginLeft, 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrentNode = currentNode.offsetParent as HTMLElement;\n\t\t}\n\n\t\tconst targetRect = target.getBoundingClientRect();\n\t\tconst relativeRect = document.body.getBoundingClientRect();\n\t\treturn {\n\t\t\ttop: targetRect.top - relativeRect.top + margins.top,\n\t\t\tleft: targetRect.left - relativeRect.left + margins.left\n\t\t};\n\t}\n\n\t// finds the position relative to the `reference` element\n\tfindRelative(reference: Element, target: Element, placement: string): AbsolutePosition {\n\t\tconst referenceOffset = this.getRelativeOffset(reference as HTMLElement);\n\t\tconst referenceRect = reference.getBoundingClientRect();\n\t\treturn this.calculatePosition(referenceOffset, referenceRect, target, placement);\n\t}\n\n\tfindAbsolute(reference: Element, target: Element, placement: string): AbsolutePosition {\n\t\tconst referenceOffset = this.getAbsoluteOffset(reference as HTMLElement);\n\t\tconst referenceRect = reference.getBoundingClientRect();\n\t\treturn this.calculatePosition(referenceOffset, referenceRect, target, placement);\n\t}\n\n\tfindPosition(reference: Element,\n\t\ttarget: Element,\n\t\tplacement: string,\n\t\toffsetFunction = this.getAbsoluteOffset.bind(this)): AbsolutePosition {\n\t\tconst referenceOffset = offsetFunction(reference as HTMLElement);\n\t\tconst referenceRect = reference.getBoundingClientRect();\n\t\treturn this.calculatePosition(referenceOffset, referenceRect, target, placement);\n\t}\n\n\tfindPositionAt(offset: Offset, target: Element, placement: string): AbsolutePosition {\n\t\treturn this.calculatePosition(offset, {top: 0, left: 0, height: 0, width: 0}, target, placement);\n\t}\n\n\t/**\n\t * Get the dimensions of an element from an AbsolutePosition and a reference element\n\t */\n\tgetPlacementBox(target: HTMLElement, position: AbsolutePosition) {\n\t\tconst targetBottom = target.offsetHeight + position.top;\n\t\tconst targetRight = target.offsetWidth + position.left;\n\n\t\treturn {\n\t\t\ttop: position.top,\n\t\t\tbottom: targetBottom,\n\t\t\tleft: position.left,\n\t\t\tright: targetRight\n\t\t};\n\t}\n\n\taddOffset(position: AbsolutePosition, top = 0, left = 0): AbsolutePosition {\n\t\treturn Object.assign({}, position, {\n\t\t\ttop: position.top + top,\n\t\t\tleft: position.left + left\n\t\t});\n\t}\n\n\tsetElement(element: Element, position: AbsolutePosition): void {\n\t\t(element as HTMLElement).style.top = `${position.top}px`;\n\t\t(element as HTMLElement).style.left = `${position.left}px`;\n\t}\n\n\tfindBestPlacement(\n\t\treference: Element,\n\t\ttarget: Element,\n\t\tplacements: string[],\n\t\tcontainerFunction: () => ReferenceRect = this.defaultContainerFunction.bind(this),\n\t\tpositionFunction = this.findPosition.bind(this)) {\n\t\t/**\n\t\t * map over the array of placements and weight them based on the percentage of visible area\n\t\t * where visible area is defined as the area not obscured by the window borders\n\t\t */\n\t\tconst weightedPlacements = placements.map(placement => {\n\t\t\tconst pos = positionFunction(reference, target, placement);\n\t\t\tlet box = this.getPlacementBox((target as HTMLElement), pos);\n\t\t\tlet hiddenHeight = 0;\n\t\t\tlet hiddenWidth = 0;\n\t\t\tconst container = containerFunction();\n\t\t\t// the element is exceeding from top or bottom of its container\n\t\t\tif (box.top < container.top) {\n\t\t\t\thiddenHeight = container.top - box.top;\n\t\t\t} else if (box.bottom > container.height) {\n\t\t\t\thiddenHeight = box.bottom - container.height;\n\t\t\t}\n\t\t\t// the element is exceeding from left or right of its container\n\t\t\tif (box.left < container.left) {\n\t\t\t\thiddenWidth = container.left - box.left;\n\t\t\t} else if (box.right > container.width) {\n\t\t\t\thiddenWidth = box.right - container.width;\n\t\t\t}\n\t\t\t// if one of the hidden dimensions is 0 but the other is > 0\n\t\t\t// we want to have a positive area, so setting the null one to 1\n\t\t\tif (hiddenHeight && !hiddenWidth) {\n\t\t\t\thiddenWidth = 1;\n\t\t\t} else if (hiddenWidth && !hiddenHeight) {\n\t\t\t\thiddenHeight = 1;\n\t\t\t}\n\t\t\tconst area = (target as HTMLElement).offsetHeight * (target as HTMLElement).offsetWidth;\n\t\t\tconst hiddenArea = hiddenHeight * hiddenWidth;\n\t\t\t// if visibleArea is 0 it means the element is fully outside container bounds\n\t\t\t// and visiblePercent will then be 0\n\t\t\tlet visibleArea = area - hiddenArea;\n\t\t\tconst visiblePercent = visibleArea / area;\n\t\t\treturn {\n\t\t\t\tplacement,\n\t\t\t\tweight: visiblePercent\n\t\t\t};\n\t\t});\n\n\t\t// sort the placements from best to worst\n\t\tweightedPlacements.sort((a, b) => b.weight - a.weight);\n\t\t// pick the best!\n\t\treturn weightedPlacements[0].placement;\n\t}\n\n\tfindBestPlacementAt(\n\t\toffset: Offset,\n\t\ttarget: Element,\n\t\tplacements: string[],\n\t\tcontainerFunction: () => ReferenceRect = this.defaultContainerFunction.bind(this)) {\n\t\tconst positionAt = (_: any, target: Element, placement: string) => {\n\t\t\treturn this.findPositionAt(offset, target, placement);\n\t\t};\n\n\t\treturn this.findBestPlacement(null as any, target, placements, containerFunction, positionAt);\n\t}\n\n\tprotected defaultContainerFunction(): ReferenceRect {\n\t\treturn {\n\t\t\t// we go with window here, because that's going to be the simple/common case\n\t\t\ttop: 0,\n\t\t\tleft: 0,\n\t\t\theight: windowRef.innerHeight,\n\t\t\twidth: windowRef.innerWidth\n\t\t};\n\t}\n\n\tprotected calculatePosition(\n\t\treferenceOffset: Offset,\n\t\treferenceRect: ReferenceRect,\n\t\ttarget: Element,\n\t\tplacement: string): AbsolutePosition {\n\n\t\tif (this.positions[placement]) {\n\t\t\treturn this.positions[placement](referenceOffset, target as HTMLElement, referenceRect);\n\t\t}\n\t\tconsole.error(\"No function found for placement, defaulting to 0,0\");\n\t\treturn { left: 0, top: 0 };\n\t}\n}\n\nexport const position = new Position();\n\nexport default Position;\n","import Position, { position } from \"./../src\";\n\nconst positionDemoElements = (referenceSelector, targetSelector, placement) => {\n\tconst position = new Position();\n\n\tconst reference = document.querySelector(referenceSelector);\n\tconst target = document.querySelector<HTMLElement>(targetSelector);\n\n\tconst pos = position.findPosition(reference, target, placement);\n\n\tposition.setElement(target, pos);\n};\n\npositionDemoElements(\".ref0\", \".tar0\", \"right\");\npositionDemoElements(\".ref1\", \".tar1\", \"right\");\npositionDemoElements(\".ref2\", \".tar2\", \"right\");\npositionDemoElements(\".ref3\", \".tar3\", \"bottom\");\npositionDemoElements(\".ref4\", \".tar4\", \"right\");\npositionDemoElements(\".ref5\", \".tar5\", \"right\");\npositionDemoElements(\".ref6\", \".tar6\", \"right\");\npositionDemoElements(\".ref7\", \".tar7\", \"right\");\npositionDemoElements(\".ref10\", \".tar10\", \"bottom\");\n\ndocument.addEventListener(\"click\", (event: MouseEvent) => {\n\tif (document.querySelector<HTMLInputElement>(\".ref8 .demo-enabled\").checked) {\n\t\tconst target = document.querySelector<HTMLElement>(\".tar8\");\n\t\tconst pos = position.findPositionAt({top: event.pageY, left: event.pageX}, target, \"bottom\");\n\n\t\tposition.setElement(target, pos);\n\t}\n});\n\ndocument.addEventListener(\"mousemove\", (event: MouseEvent) => {\n\tif (document.querySelector<HTMLInputElement>(\".ref9 .demo-enabled\").checked) {\n\t\tconst target = document.querySelector<HTMLElement>(\".tar9\");\n\t\tconst pos = position.findPositionAt({ top: event.pageY, left: event.pageX }, target, \"bottom\");\n\n\t\tposition.setElement(target, pos);\n\t}\n});\n\ndocument.addEventListener(\"keydown\", (event: KeyboardEvent) => {\n\tswitch (event.key) {\n\t\tcase \"1\": {\n\t\t\t\tconst input = document.querySelector<HTMLInputElement>(\".ref8 .demo-enabled\");\n\t\t\t\tinput.checked = !input.checked;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase \"2\": {\n\t\t\t\tconst input = document.querySelector<HTMLInputElement>(\".ref9 .demo-enabled\");\n\t\t\t\tinput.checked = !input.checked;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t}\n});\n"]}